<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Linkgo⭐</title>
    <link rel="manifest" href="https://lingshing.github.io/Linkgostart/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Linkgo">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/Lingshing/Linkgostart/refs/heads/main/linkgo-icon.jpg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ----------------------- 全局与主题样式 ----------------------- */
        :root {
            /* 主题变量 */
            --bg-color-primary: #f0f0f5; 
            --bg-color-secondary: #ffffff; 
            --text-color-primary: #1c1c1e; 
            --text-color-secondary: #8e8e93; 
            --accent-color: #7B9E6D; 
            --danger-color: #E8AF98;
            --warning-color: #A89F4D;
            --shadow-light: 0 4px 12px rgba(0, 0, 0, 0.05);
            --shadow-dark: 0 4px 12px rgba(0, 0, 0, 0.3);
            --input-bg: #f7f7f7;
            --input-border: #e0e0e0; 
            --radius-default: 16px; 
            --bubble-radius: 4px; /* 需求4: 气泡圆角不要那么圆 */

            --phone-width: 100%;
            --phone-height: 100vh;
        }

        .dark-mode {
            --bg-color-primary: #121212;
            --bg-color-secondary: #1e1e1e;
            --text-color-primary: #e0e0e0; /* 统一白色文字 */
            --text-color-secondary: #aaa; /* 提高对比度 */
            --accent-color: #8AAE7F;
            --shadow-light: 0 4px 12px rgba(0, 0, 0, 0.5);
            --shadow-dark: 0 4px 12px rgba(0, 0, 0, 0.8);
            --input-bg: #2b2b2b;
            --input-border: #444;
            --danger-color: #D17A6B;
        }
        

        /* 基础样式和动效 */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color-primary);
            font-family: -apple-system, BlinkMacSystemFont, 
                 'SF Pro Text', 'Helvetica Neue', 
                 'PingFang SC', 'Hiragino Sans GB',
                 sans-serif;
    -webkit-font-smoothing: antialiased;  /* 字体抗锯齿 */
    -moz-osx-font-smoothing: grayscale;
            transition: background-color 0.3s;
            color: var(--text-color-primary); /* 确保所有文字颜色统一 */
        }
        
        .clickable:active {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }

        .phone-frame {
            width: var(--phone-width);
            height: var(--phone-height);
            background: linear-gradient(145deg, var(--bg-color-primary), var(--bg-color-primary));
            border-radius: 0;
            box-shadow: var(--shadow-dark);
            padding: 10px;
            box-sizing: border-box;
            position: relative;
        }

        .phone-screen {
            width: 100%;
            height: 100%;
            background-color: var(--bg-color-secondary);
            border-radius: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .status-bar {
            width: 100%;
            height: 0px; /* 需求4: 只保留最小高度 */
            background-color: var(--bg-color-secondary);
            box-sizing: border-box;
        }

        /* ----------------------- APP 图标和主界面 ----------------------- */
        /* 添加这行，让图标颜色继承父元素颜色 */
        .fas, .fab {
             color: inherit;
        }

        .app-container {
            flex-grow: 1;
            width: 100%;
            padding: 40px 20px;
            display: flex;
            justify-content: center; 
            align-items: flex-start;
            gap: 40px; 
        }

        .app-icon {
            text-align: center;
            cursor: pointer;
            width: 65px; 
        }
        
        .app-icon .app-icon-image {
             transition: transform 0.1s ease;
        }
        .app-icon:active .app-icon-image {
             transform: scale(0.95);
        }

        .app-icon-image {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(8px); 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            border-radius: var(--radius-default); 
            margin: 0 auto 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            color: #ffffff; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* ----------------------- 页面切换结构 ----------------------- */
        .page {
            position: absolute;
            inset: 0;
            top: 0px; /* 调整状态栏高度 */
            background: var(--bg-color-secondary);
            display: none; 
            flex-direction: column;
            color: var(--text-color-primary);
        }

        .page-header {
            display: flex;
            align-items: center;
            padding: 10px 15px; 
            /* 修改点：背景改为透明(透出手机底色) 或 直接写 black */
            background-color: var(--bg-color-primary); 
            /* 修改点：去掉底部边框，让它看起来和背景一体 */
            border-bottom: none; 
            position: sticky;
            top: 0px;
            z-index: 2;
            height: 50px;
            box-sizing: border-box;
        }
        
        /* 设置页面调整 */
        .page-header h3 {
            flex-grow: 1;
            text-align: center; 
            margin: 0;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            /* 修改点：字号16px，不加粗 */
            font-size: 16px; 
            font-weight: normal; 
        }

        /* 需求3: 聊天室页面 */
        .page-header h3.small-title {
            font-size: 16px;
        }

        .back-button, .action-button, .manage-button {
            display: flex;
            align-items: center;
            cursor: pointer;
            color: var(--text-color-primary);
            padding: 5px;
            font-size: 16px;
            z-index: 3;
            transition: transform 0.1s ease;
        }
        .back-button:active, .action-button:active, .manage-button:active {
            transform: scale(0.94);
        }
        
        .back-button { margin-right: auto; }
        
        /* 需求2: 管理按钮 */
        .manage-button {
            margin-left: auto;
            margin-right: 15px;
            font-size: 16px;
        }

        /* 需求2: 加号放大 */
        .action-button.plus-btn {
            font-size: 16px; 
            font-weight: 300;
            line-height: 1;
        }
        /* 仅针对聊天窗口的三个点 */
#chat-window .action-button {
    font-size: 24px;
    font-weight: 700;
}
        .back-icon { margin-right: 5px; }

        /* ----------------------- 设置 & 选项页面样式 ----------------------- */
        #settings-page .content, #options-page .content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-group {
            margin-bottom: 30px; 
            padding: 15px;
            background-color: var(--input-bg);
            border-radius: var(--radius-default); 
            box-shadow: var(--shadow-light);
            border: 1px solid var(--input-border);
        }

        .settings-group h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-color-primary);
        }

        .settings-group label {
            display: block;
            margin: 15px 0 8px; 
            font-weight: bold;
            font-size: 14px;
            color: var(--text-color-primary);
        }

        .settings-group input:not([type="checkbox"]), 
.theme-switch-group button,
.options-save-btn,
.file-upload-btn,
.modal-content input {
    width: 100%;
    padding: 12px; 
    margin-bottom: 10px;
    border: 1px solid var(--input-border);
    border-radius: var(--radius-default); 
    background-color: var(--bg-color-secondary);
    color: var(--text-color-primary);
    box-sizing: border-box;
    transition: background-color 0.3s, border-color 0.3s;
}

/* 修复设置页面输入框颜色问题 */
#settings-page input[type="text"],
#settings-page input[type="password"],
#settings-page input[type="number"] {
    background-color: var(--input-bg) !important;
    border: 1px solid var(--input-border);
    border-radius: var(--radius-default);
    padding: 12px;
    width: 100%;
    color: var(--text-color-primary);
    box-sizing: border-box;
    transition: background-color 0.3s, border-color 0.3s;
}

#settings-page input[type="text"]:focus,
#settings-page input[type="password"]:focus,
#settings-page input[type="number"]:focus {
    outline: none;
    border-color: var(--accent-color);
    background-color: var(--input-bg) !important;
}

/* 专门为textarea添加样式，允许滚动 */
.settings-group textarea,
.modal-content textarea {
    width: 100%;
    padding: 12px; 
    margin-bottom: 10px;
    border: 1px solid var(--input-border);
    border-radius: var(--radius-default); 
    background-color: var(--bg-color-secondary);
    color: var(--text-color-primary);
    box-sizing: border-box;
    transition: background-color 0.3s, border-color 0.3s;
    resize: vertical !important;
    min-height: 80px;
    max-height: 300px;
    overflow-y: auto !important;
    scrollbar-width: thin;
}

/* 确保滚动条可见 */
.settings-group textarea::-webkit-scrollbar,
.modal-content textarea::-webkit-scrollbar {
    display: block;
    width: 6px;
}

.settings-group textarea::-webkit-scrollbar-thumb,
.modal-content textarea::-webkit-scrollbar-thumb {
    background-color: var(--input-border);
    border-radius: 3px;
}


        .options-save-btn, .theme-switch-group button {
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.1s ease;
        }

        .options-save-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 12px;
        }
        .options-save-btn:active {
            background-color: #0056b3;
            transform: scale(0.98);
        }

        /* ----------------------- 聊天室 (联系人) 页面样式 ----------------------- */
        #contacts-page .contacts-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 15px;
        }

        .contact-item {
            display: flex;
            align-items: center;
            padding: 15px 0; 
            border-bottom: 1px solid var(--input-border);
            cursor: pointer;
            transition: background-color 0.1s;
        }
        
        .contact-item:active { background-color: rgba(0, 0, 0, 0.05); } 
        
        /* 需求2: 删除按钮 */
        .delete-btn-wrapper {
            width: 0;
            overflow: hidden;
            transition: width 0.3s ease, margin-right 0.3s ease;
            margin-right: 0;
            display: flex;
            align-items: center;
        }
        .delete-btn-wrapper.show {
            width: 30px;
            margin-right: 10px;
        }
        .delete-icon {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background-color: var(--danger-color);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            line-height: 1;
            font-weight: bold;
        }

        /* 新增：批量删除选择框 */
        .contact-checkbox {
            width: 0;
            overflow: hidden;
            transition: width 0.3s ease, margin-right 0.3s ease;
            margin-right: 0;
            display: flex;
            align-items: center;
        }
        .contact-checkbox.show {
            width: 30px;
            margin-right: 10px;
        }
        
        .contact-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .contact-avatar {
            width: 45px;
            height: 45px;
            border-radius: 4px; /* 微信风格圆角 */
            background-color: var(--accent-color);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            margin-right: 15px;
            flex-shrink: 0;
            overflow: hidden;
        }
        .contact-avatar img { width: 100%; height: 100%; object-fit: cover; }


        /* ----------------------- 聊天窗口样式 ----------------------- */
        #chat-window { background-color: var(--bg-color-primary); }

        .chat-message { margin-bottom: 15px; display: flex; align-items: flex-start; width: 100%;}
        
        /* 需求4: AI在左边有头像，我在右边没头像 */
        .chat-message.ai { justify-content: flex-start; }
        .chat-message.user { justify-content: flex-end; }
        
        /* 确保AI的多个气泡之间有合适的间距 */
        .chat-message.ai {
            display: flex;
            /* 修改点：改为 flex-start 让头像和气泡顶部对齐 */
            align-items: flex-start; 
            margin-bottom: 15px;
        }

        .chat-message.ai .avatar {  
    width: 36px; 
    height: 36px; 
    margin-right: 8px; 
    flex-shrink: 0;
    border-radius: 8px; 
    /* 修改点：移除或调整顶部边距 */
    margin-top: 0; /* 将 4px 改为 0 */
}

.chat-message.ai:last-child {
    margin-bottom: 15px; /* 最后一个AI消息保持原来的间距 */
}

/* 确保用户消息和AI消息之间有正常间距 */
.chat-message.user {
    margin-bottom: 15px;
}

.chat-message.user .avatar { display: none; } /* 用户无头像 */

/* 消息容器：干干净净，没有任何 animation */
.chat-message {
    margin-bottom: 15px;
    display: flex;
    align-items: flex-start;
    width: 100%;
    /* 删除了 animation 属性，确保气泡生成时是静止的 */
}

/* 3. 气泡样式：去掉之前的禁用代码，保持干净 */
.chat-message .bubble {
    max-width: 70%;
    padding: 10px 12px;
    border-radius: var(--bubble-radius);
    line-height: 1.4;
    font-size: 17px;
    font-family: "PingFang SC", -apple-system, sans-serif;
    word-wrap: break-word;
    position: relative;
    
    /* 核心修改：这里不要再写 animation: none !important 了 */
}

/* --- 结束：替换代码 --- */

/* 4. 保持 AI 气泡的特定样式 */
.chat-message.ai .bubble {
    background-color: var(--bg-color-secondary);
    color: var(--text-color-primary);
    cursor: pointer;
    transition: background-color 0.1s;
}

/* 新增：点击时的反馈效果 */
.chat-message.ai .bubble:active {
    background-color: rgba(0, 0, 0, 0.05);
    transform: scale(0.99);
}

/* 深色模式适配 */
.dark-mode .chat-message.ai .bubble:active {
    background-color: rgba(255, 255, 255, 0.05);
}

        .chat-message.user .bubble {
    background-color: #95ec69;  /* 微信浅绿色 */
    color: black;              
    margin-right: 10px;
}

/* 白天模式保持不变，深色模式可以调整 */
.dark-mode .chat-message.user .bubble {
    background-color: #07C160;  /* 深色模式用微信绿 */
    color: black;
}
        
        /* 消息包装器 */
.messages-wrapper {
    flex: 1;
    position: relative;
    overflow: hidden;
}

/* 消息容器 */
.messages-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    overflow-y: auto;
    padding: 15px 0 5px 0;
    scrollbar-width: none;
    -ms-overflow-style: none;
    scroll-behavior: auto !important;
}

/* 确保最后一条消息不被遮挡 */
.messages-container::after {
    content: '';
    display: block;
    height: 0px; /* 输入框高度 + 安全距离 */
}

/* --- ⬇️ 新增：搜索条与弹窗头部样式 ⬇️ --- */

/* 1. 搜索条包装器（包含图标+输入框） */
.search-bar-wrapper {
    display: flex;
    align-items: center;
    background: var(--input-bg);
    border: 1px solid var(--input-border);
    border-radius: 8px;
    padding: 0 12px;
    margin-bottom: 10px;
    height: 38px; /* 固定高度 */
    flex-shrink: 0; /* 防止被压缩 */
}

/* 2. 搜索图标 */
.search-bar-wrapper i {
    color: var(--text-color-secondary);
    margin-right: 8px;
    font-size: 14px;
}

/* 3. 输入框（去掉自带边框，背景透明） */
.memory-search-box {
    border: none !important;
    background: transparent !important;
    padding: 0 !important;
    margin: 0 !important;
    height: 100%;
    width: 100%;
    flex-grow: 1;
    font-size: 14px;
    color: var(--text-color-primary);
    outline: none; /* 去掉聚焦蓝框 */
}

/* 4. 修复：弹窗头部对齐 */
.memory-header-row {
    display: flex;
    align-items: center; /* 垂直居中核心 */
    margin-bottom: 0;
    height: 40px; /* 给一个固定高度基准 */
    flex-shrink: 0;
}

.memory-back-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 40px;
    width: 40px; /* 增大触控区域 */
    margin-right: 0px;
    margin-left: -10px; /* 抵消一点左边距，视觉平衡 */
    cursor: pointer;
    font-size: 18px;
    color: var(--text-color-primary);
    transform: translateY(-7px);
}

#memory-modal-title {
    margin: 0;
    flex-grow: 1;
    line-height: 40px; /* 文字垂直居中 */
    font-size: 18px;
    color: var(--text-color-primary);
    /* 稍微往上提一点点(视觉补偿) */
    position: relative;
    top: -0.5px; 
}

/* 分类标签栏 (Tabs) - 修改：间距更小，显示更多 */
.memory-tabs {
    display: flex;
    gap: 6px;  /* 从 10px 改为 6px，更紧凑 */
    margin-bottom: 10px;
    overflow-x: auto;
    padding-bottom: 5px; 
    scrollbar-width: none; 
    flex-shrink: 0; /* 防止被压缩 */
}
.memory-tabs::-webkit-scrollbar { display: none; }

.memory-tab {
    padding: 5px 10px; /* 从 6px 12px 改小，更精致 */
    border-radius: 15px;
    background: var(--input-bg);
    color: var(--text-color-secondary);
    font-size: 13px;
    white-space: nowrap;
    border: 1px solid var(--input-border);
    cursor: pointer;
    transition: all 0.2s;
}

.memory-tab.active {
    background: var(--accent-color);
    color: white;
    border-color: var(--accent-color);
    font-weight: bold;
}

/* 档案内的 Tag 样式 */
.memory-tag {
    color: var(--accent-color);
    cursor: pointer;
    text-decoration: none;
    margin-right: 5px;
}
.memory-tag:hover {
    text-decoration: underline;
}

/* 轮数显示的样式 */
.memory-round-badge {
    background: rgba(0,0,0,0.05);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 11px;
    margin-right: 5px;
}
.dark-mode .memory-round-badge {
    background: rgba(255,255,255,0.1);
}

/* ----------------------- 输入框区域 - iOS风格 ----------------------- */
.chat-input-area {
    flex-shrink: 0;
    padding: 12px 16px 16px 16px; /* 增加内边距，让输入框抬高 */
    display: flex;
    align-items: flex-end;
    background-color: var(--bg-color-secondary);
    border-top: 1px solid var(--input-border);
    box-sizing: border-box;
    /* 移除min-height，让高度自适应 */
}

/* ----------------------- 无边框iOS风格输入框 ----------------------- */
.chat-input-area {
    flex-shrink: 0;
    padding: 16px 16px 20px 16px; /* 保持抬高效果 */
    display: flex;
    align-items: center;
    background-color: var(--bg-color-secondary);
    /* 完全移除边框 */
    border-top: none;
    box-sizing: border-box;
    /* 轻微阴影保持悬浮感，但更柔和 */
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.04);
    z-index: 10;
}

.dark-mode .chat-input-area {
    box-shadow: 0 -2px 15px rgba(0, 0, 0, 0.15);
    background-color: var(--bg-color-secondary);
}

/* 输入框本身 - 无边框版本 */
.chat-input-area textarea {
    flex-grow: 1;
    resize: none;
    min-height: 36px;
    max-height: 100px;
    padding: 9px 16px;
    /* 移除边框 */
    border: none;
    /* 保持圆角 */
    border-radius: 19px;
    margin: 0;
     font-size: 17px;
    font-family: "PingFang SC", -apple-system, sans-serif !important;
    -webkit-font-smoothing: antialiased;
    font-synthesis: style weight;
    box-sizing: border-box;
    background-color: var(--input-bg);
    color: var(--text-color-primary);
    transition: all 0.2s ease;
    line-height: 1.4;
    
    /* 只用内部阴影，不要外部边框 */
    box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.08);
    
    /* 隐藏滚动条 */
    overflow: hidden;
    -webkit-overflow-scrolling: touch;
}

.dark-mode .chat-input-area textarea {
    background-color: rgba(118, 118, 128, 0.24);
    color: var(--text-color-primary);
    box-shadow: inset 0 1px 6px rgba(0, 0, 0, 0.2);
}

/* 聚焦状态 - 只用阴影表示 */
.chat-input-area textarea:focus {
    outline: none;
    background-color: var(--input-bg);
    /* 聚焦时内部阴影加深 */
    box-shadow: inset 0 1px 6px rgba(0, 0, 0, 0.12),
                0 0 0 1px rgba(0, 122, 255, 0.2); /* 非常细的聚焦指示 */
}

.dark-mode .chat-input-area textarea:focus {
    box-shadow: inset 0 0.1px 1px rgba(255, 255, 255, 0.3),
                0 0 0 0.1px rgba(255, 255, 255, 0.3);
}

/* 确保所有textarea都有相同样式 */
textarea {
    resize: none !important;
    font-family: inherit; /* 继承字体 */
}

/* 隐藏textarea的三角标（各个浏览器） */
textarea::-webkit-resizer {
    display: none !important;
}
textarea::-moz-resize {
    display: none !important;
}
textarea::-ms-resize {
    display: none !important;
}

/* 修改所有输入框的光标颜色 */
input, textarea {
    caret-color: #07C160; 
}

/* 深色模式下的光标颜色 */
.dark-mode input,
.dark-mode textarea {
    caret-color: #07C160; 
}

/* === 新增：酒馆功能专用样式 === */
        .tavern-control-group {
            margin-bottom: 15px;
            background: var(--bg-color-secondary);
            padding: 10px;
            border-radius: 12px;
            border: 1px solid var(--input-border);
        }
        .tavern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-color-primary);
        }
        .tavern-list {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-color-primary);
            border-radius: 8px;
            padding: 5px;
        }
        .tavern-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 13px;
        }
        .tavern-item:last-child { border-bottom: none; }
        .tavern-tag {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 5px;
        }
        .tag-input { background: #e3f2fd; color: #1565c0; } /* 输入正则 */
        .tag-output { background: #e8f5e9; color: #2e7d32; } /* 输出正则 */
        .tag-depth { background: #fff3e0; color: #ef6c00; } /* 深度提示 */
        
        /* 开关样式 */
        .switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 20px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(14px); }


        /* ----------------------- 模态框/弹窗样式 ----------------------- */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 40;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: var(--bg-color-secondary);
            border-radius: var(--radius-default);
            width: 80%; 
            max-height: 80%;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

/* 新建角色弹窗优化样式 */
#new-contact-modal .modal-content {
    width: 85%;
    max-width: 400px;
    max-height: 85vh;
    padding: 24px;
    display: flex;
    flex-direction: column;
}

#new-contact-modal .modal-content h4 {
    margin-bottom: 24px;
    font-size: 20px;
    text-align: center;
    color: var(--text-color-primary);
}

#new-contact-modal .modal-scroll-area {
    flex: 1;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    margin-bottom: 16px;
}

#new-contact-modal .modal-scroll-area::-webkit-scrollbar {
    display: none;
}

#new-contact-modal .modal-content label {
    display: block;
    margin: 18px 0 8px 0;
    font-weight: 600;
    font-size: 15px;
    color: var(--text-color-primary);
}

#new-contact-modal .modal-content input,
#new-contact-modal .modal-content textarea {
    width: 100%;
    padding: 14px 16px;
    margin-bottom: 8px;
    border: 1px solid var(--input-border);
    border-radius: 12px;
    background-color: var(--bg-color-secondary);
    color: var(--text-color-primary);
    box-sizing: border-box;
    font-size: 16px;
}

#new-contact-modal .modal-content input:focus,
#new-contact-modal .modal-content textarea:focus {
    outline: none;
    /* 移除边框颜色变化和阴影 */
    border-color: var(--input-border);
}

#new-contact-modal .modal-content textarea:focus {
    min-height: 120px;
    line-height: 1.5;
}

#new-contact-modal .modal-footer {
    margin-top: 8px;
    padding-top: 20px;
    border-top: 1px solid var(--input-border);
}

#new-contact-modal .modal-footer button {
    padding: 14px 24px;
    font-size: 16px;
    font-weight: 600;
    border-radius: 12px;
}

/* 移除数字输入框箭头 */
input[type="number"] {
    -moz-appearance: textfield;
    appearance: textfield;
}

input[type="number"]::-webkit-outer-spin-button,
input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

#memory-content-container textarea {
    scrollbar-width: none;
    -ms-overflow-style: none;
    overflow-y: hidden; /* 强制隐藏垂直滚动条 */
}

#memory-content-container textarea::-webkit-scrollbar {
    display: none;
}

     
        .modal-content h4 { 
            margin-bottom: 20px; 
            color: var(--text-color-primary);
        }
        
        .modal-content label { 
            margin-top: 15px; 
            color: var(--text-color-primary);
        }

        .modal-footer {
            display: flex;
            justify-content: space-around;
            padding-top: 20px; 
            gap: 10px;
        }

        .modal-footer button {
            flex: 1;
            padding: 12px 10px;
            border-radius: var(--radius-default); 
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.1s ease;
        }
        
        .modal-footer button:active { transform: scale(0.96); }

        .modal-footer .save-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
        }

        .modal-footer .cancel-btn {
            background-color: var(--input-bg);
            color: var(--text-color-primary);
            border: 1px solid var(--input-border);
        }
        
        /* ----------------------- 选项页面 (Prompt/记忆/头像) ----------------------- */
        .options-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 0; 
            border-bottom: 1px solid var(--input-border);
            cursor: pointer;
            transition: background-color 0.1s;
        }
        .options-item:active { background-color: rgba(0, 0, 0, 0.05); }

        .options-item:last-child { border-bottom: none; }

        .options-item span { 
            font-weight: bold; 
            color: var(--text-color-primary);
        }
        
        .options-item .indicator {
            color: var(--text-color-secondary);
            font-weight: normal;
        }
        
        #memory-modal-title { 
            margin-bottom: 20px; 
            color: var(--text-color-primary);
        }

        /* 新增：批量删除工具栏 */
        .batch-toolbar {
            display: none;
            position: sticky;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-color-secondary);
            border-top: 1px solid var(--input-border);
            padding: 12px 15px;
            z-index: 5;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .batch-toolbar.show {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .batch-info {
            color: var(--text-color-primary);
            font-size: 14px;
        }
        
        .batch-delete-btn {
            background-color: var(--danger-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-default);
            cursor: pointer;
            font-weight: bold;
        }
        
        .batch-cancel-btn {
            background-color: var(--input-bg);
            color: var(--text-color-primary);
            border: 1px solid var(--input-border);
            padding: 8px 16px;
            border-radius: var(--radius-default);
            cursor: pointer;
            margin-right: 10px;
        }
        
        /* 新增：临时记忆对话框样式 */
        .round-container {
            margin-bottom: 20px;
            border: 1px solid var(--input-border);
            border-radius: var(--radius-default);
            padding: 15px;
            background-color: var(--input-bg);
        }
        
        /* 确保临时记忆对话框中的文本可滚动 */
.round-message {
    padding: 8px 12px;
    border-radius: 8px;
    background-color: var(--bg-color-secondary);
    border: 1px solid var(--input-border);
    color: var(--text-color-primary);
    max-height: 150px;
    overflow-y: auto !important;
    white-space: pre-wrap;
    word-break: break-word;
}

        /* 添加删除按钮样式 */
.round-header {
    font-weight: bold;
    margin-bottom: 10px;
    color: var(--text-color-primary);
    font-size: 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.round-delete-btn {
    background-color: var(--danger-color);
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    font-size: 18px;
    line-height: 1;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0;
    transition: transform 0.1s ease;
}

.round-delete-btn:hover {
    transform: scale(1.1);
}
        
        .round-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .round-message {
            padding: 8px 12px;
            border-radius: 8px;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--input-border);
            color: var(--text-color-primary);
        }
        
        .round-message.user {
            align-self: flex-end;
            background-color: #95ec69;
            color: #1c1c1e;
            max-width: 80%;
        }
        
        .round-message.ai {
            align-self: flex-start;
            background-color: var(--bg-color-secondary);
            max-width: 80%;
        }

        /* 新增：设置页头像设置区域 */
        .avatar-settings {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--input-border);
        }
        
        .avatar-preview-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .avatar-preview-label {
            margin-bottom: 10px;
            color: var(--text-color-primary);
            font-weight: bold;
        }
        
        .avatar-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* 新增：AI消息逐句显示效果 */
        .typing-indicator {
            display: flex;
            padding: 10px 14px;
            border-radius: var(--bubble-radius);
            background-color: var(--bg-color-secondary);
            margin-bottom: 5px;
        }
        
        .typing-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: var(--text-color-secondary);
            margin: 0 1px;
            animation: typing 1.5s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) { animation-delay: -0.3s; }
        .typing-dot:nth-child(2) { animation-delay: -0.15s; }
        .typing-dot:nth-child(3) { animation-delay: 0s; }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-3px); }
        }

        /* 新增：选择/取消全选按钮 */
        .select-all-btn {
            background-color: var(--warning-color);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
                  
        /* 清理按钮 - 简洁ins风 */
.clear-buttons {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 15px;
}

.clear-btn {
    display: flex;
    align-items: center;
    padding: 14px 16px;
    border-radius: 10px;
    border: 1px solid var(--input-border);
    font-size: 15px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    background: var(--bg-color-secondary);
    color: var(--text-color-primary);
}

.clear-btn:active {
    transform: scale(0.98);
}

.clear-short-btn {
    border-left: 4px solid #D39C70; 
}

.clear-long-btn {
    border-left: 4px solid #8A7FAC; 
}

.clear-icon {
    font-size: 18px;
    margin-right: 12px;
} 

.clear-short-btn .clear-icon {
    color: #D39C70; /* 图标也用陶土橙 */
}

.clear-long-btn .clear-icon {
    color: #8A7FAC; /* 图标也用灰紫色 */
}

/* 主题切换开关 - 容器 */
.theme-switch-container {
    display: flex;
    justify-content: center;
    margin: 15px 0;
}

/* 轨道（背景条） */
.theme-switch-track {
    position: relative;
    width: 68px;
    height: 34px;
    background: linear-gradient(90deg, #ffd700 0%, #007aff 100%);
    border-radius: 34px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    overflow: hidden;
}

/* 深色模式下的轨道 */
.dark-mode .theme-switch-track {
    background: #4a4a4a;
}

/* 圆形滑块 */
.theme-switch-thumb {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 30px;
    height: 30px;
    background: white;
    border-radius: 50%;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
    z-index: 2;
}

/* 深色模式下滑块位置（滑动到右侧） */
.dark-mode .theme-switch-thumb {
    left: calc(100% - 32px);
    background: #f5f5f7;
}

/* 两侧图标 */
.theme-icon-left,
.theme-icon-right {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-size: 14px;
    color: white;
    z-index: 1;
    transition: all 0.3s ease;
}

.theme-icon-left {
    left: 9px;
}

.theme-icon-right {
    right: 9px;
}

/* 深色模式下图标颜色 */
.dark-mode .theme-icon-left {
    color: #888;
}

.dark-mode .theme-icon-right {
    color: #ffd700;
}
/* 为主题模式标题添加样式 */
#settings-page .content > div:has(h4:contains("主题模式")) h4 {
    margin: 0 0 15px 0;
    text-align: center;
    color: var(--text-color-primary);
}

/* ----------------------- 修复记忆弹窗头部固定 & 搜索框吸顶 ----------------------- */
        
/* 1. 针对记忆弹窗：禁止整个卡片滚动，改为 Flex 布局 */
#memory-modal .modal-content {
    overflow: hidden !important;
    display: flex;
    flex-direction: column;
}

/* 2. 内容容器：头部(搜索+标签)固定，只让内部的列表滚动 */
#memory-content-container {
    flex-grow: 1;
    overflow: hidden; /* 禁止外层滚动，这是吸顶的关键 */
    display: flex;
    flex-direction: column;
    margin-bottom: 10px;
    padding-right: 0;
}

/* 3. 专门的列表滚动区域 - 只有这里会滚动 */
#memory-list-scroll-area {
    flex-grow: 1;
    overflow-y: auto; /* 开启垂直滚动 */
    padding-right: 5px; /* 防止滚动条挡住文字 */
    scrollbar-width: thin;
}

/* 隐藏 memory-list 的滚动条但保持功能 (可选) */
#memory-list-scroll-area::-webkit-scrollbar {
    width: 4px;
}
#memory-list-scroll-area::-webkit-scrollbar-thumb {
    background-color: rgba(0,0,0,0.1);
    border-radius: 2px;
}

/* ----------------------- 隐藏记忆弹窗中文本框的滚动条 ----------------------- */
        
        /* 针对 Chrome/Safari/Edge */
        #memory-content-container textarea::-webkit-scrollbar {
            display: none;
        }

        /* 针对 Firefox */
        #memory-content-container textarea {
            scrollbar-width: none; 
            -ms-overflow-style: none;
        }

/* 仅聊天界面滑动效果 */
#chat-window {
    position: absolute;
    top: 0px;
    bottom: 0;
    left: 0;
    right: 0;
    overflow: hidden;
}

/* 进入聊天界面时的动画 - 从右向左滑动 */
.slide-in-right {
    animation: slideInRight 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

/* 退出聊天界面时的动画 - 从左向右滑动 */
.slide-out-left {
    animation: slideOutLeft 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

/* 确保消息容器在动画开始时就是可见的 */
#chat-window.slide-in-right .messages-container {
    opacity: 1;
    transition: opacity 0.1s;
}

/* 修改动画，确保内容同时出现 */
@keyframes slideInRight {
    from {
        transform: translateX(100%);
    }
    to {
        transform: translateX(0);
    }
}

@keyframes slideOutLeft {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%); /* 向右滑出 */
        opacity: 0.9;
    }
}

/* 强制所有头像圆角 - Safari兼容 */
.avatar,
.chat-message.ai .avatar,
.contact-avatar {
    -webkit-border-radius: 8px !important;
    -moz-border-radius: 8px !important;
    border-radius: 4px !important;
    overflow: hidden !important;
}

/* 头像内的图片 */
.avatar img,
.chat-message.ai .avatar img,
.contact-avatar img {
    -webkit-border-radius: 8px !important;
    -moz-border-radius: 8px !important;
    border-radius: 8px !important;
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
}

/* 对于头像文字（非图片）也确保圆角 */
.contact-avatar:not(:has(img)) {
    -webkit-border-radius: 8px !important;
    -moz-border-radius: 8px !important;
    border-radius: 8px !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
}

/* ----------------------- AI消息操作菜单 ----------------------- */
.context-menu {
    position: fixed;
    background: transparent; /* 改为透明背景 */
    border: none; /* 去掉边框 */
    border-radius: 0; /* 去掉圆角 */
    box-shadow: none; /* 去掉阴影 */
    z-index: 9999;
    min-width: 40px; /* 缩小宽度 */
    overflow: visible; /* 允许内容超出 */
    backdrop-filter: none; /* 去掉模糊效果 */
    -webkit-backdrop-filter: none;
    animation: menuFadeIn 0.2s ease;
    padding: 0; /* 去掉内边距 */
    margin-left: -8px !important;
}

@keyframes menuFadeIn {
    from {
        opacity: 0;
        transform: translateY(-5px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.menu-item {
    padding: 0; /* 去掉内边距 */
    color: var(--text-color-primary); /* 使用文字颜色 */
    font-size: 24px; /* 稍微调大字体 */
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    white-space: nowrap;
    border-bottom: none;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40px;
    width: 40px;
    background: transparent; /* 透明背景 */
    border-radius: 0; /* 去掉圆角 */

     /* 新增：强制保持正方形 */
    aspect-ratio: 1 / 1; /* 宽高比1:1 */
    
    /* 针对不支持aspect-ratio的浏览器 */
    min-height: 40px;
    min-width: 40px;
}

/* 手机：更大的图标 */
@media screen and (max-width: 768px) {
    .context-menu {
        min-width: 60px !important;
    }
    .menu-item {
        font-size: 40px !important;
        height: 60px !important;
        width: 60px !important;

        aspect-ratio: 1 / 1 !important;
        min-height: 60px !important;
        min-width: 60px !important;
    }
}

.menu-item:hover {
    background-color: transparent;
    color: #95ec69; /* 鼠标悬停时用用户气泡颜色 */
}

.dark-mode .menu-item:hover {
    color: #07C160; /* 深色模式用深绿色 */
}

.menu-item:active {
    background-color: transparent; /* 去掉蓝色背景 */
    color: #95ec69; /* 点击时变成用户气泡的颜色 */
}

.dark-mode .menu-item:active {
    color: #07C160; /* 深色模式用深绿色 */
}
.context-menu::before {
    display: none; /* 隐藏小三角箭头 */
}

/* 温度滑块样式 - 简洁版 */
.temp-slider-container {
    padding: 12px 0;
}

.temp-slider-track {
    position: relative;
    width: 100%;
    height: 3px;
    background: rgba(0, 0, 0, 0.1);
    border-radius: 1.5px;
    cursor: pointer;
}

.dark-mode .temp-slider-track {
    background: rgba(255, 255, 255, 0.1);
}

.temp-slider-thumb {
    position: absolute;
    top: 50%;
    left: 35%;
    transform: translate(-50%, -50%);
    width: 18px;
    height: 18px;
    background: rgba(123, 158, 109, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 50%;
    box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.1),
        0 0 0 1px rgba(255, 255, 255, 0.3) inset;
    cursor: pointer;
    z-index: 2;
    transition: all 0.2s ease;
}

.temp-slider-thumb:hover {
    transform: translate(-50%, -50%) scale(1.1);
}

.temp-slider-thumb:active {
    cursor: grabbing;
    transform: translate(-50%, -50%) scale(0.95);
    background: rgba(136, 171, 218, 0.9);
}

.dark-mode .temp-slider-thumb {
    background: rgba(138, 174, 127, 0.8);
    box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
}


/* 左侧按钮容器 */
.left-header-buttons {
    display: flex;
    align-items: center;
    gap: 1px;
     margin-left: 0;
}

/* 给齿轮单独的样式 */
.app-icon {
    cursor: pointer;
    font-size: 18px;
    color: var(--text-color-primary);
    padding: 8px;
    border-radius: 8px;
    transition: transform 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
}

/* 保留齿轮的缩放效果 */
.app-icon:hover {
    transform: scale(1.1);
}
.app-icon:hover {
    transform: scale(1.1); /* 改为缩放效果 */  
}

/* 刷新按钮样式 */
.refresh-btn {
    font-size: 18px;
    color: var(--text-color-primary); /* 改为和齿轮一样的颜色 */
    cursor: pointer;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    border-radius: 8px;
    min-width: 40px;
    min-height: 40px;
}

.refresh-btn:hover {
    /* 悬停时不转 */
}

.refresh-btn:active {
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* 新增：渐停动画 */
@keyframes spinToStop {
    0% { transform: rotate(var(--start-angle)); }
    100% { transform: rotate(var(--end-angle)); }
}

.refresh-btn.refreshing i {
    animation: spin 0.5s linear infinite;
}

/* 预设弹窗项样式 */
.preset-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.preset-item:active {
    transform: translateY(0);
}

/* 深预设和正则详情列表统一字体大小 */
.tavern-item {
    font-size: 14px; /* 统一字体大小 */
}

.tavern-item > div:first-child {
    font-size: 14px; /* 功能名称字体 */
}

.tavern-item .round-badge,
.memory-round-badge {
    font-size: 11px; /* 轮数标记字体 */
}

/* 深预设详情弹窗标题 */
#preset-detail-title,
#regex-detail-title {
    font-size: 16px !important; /* 标题字体 */
}

/* 正则详情弹窗标题 */
#deep-preset-modal h4,
#regex-modal h4 {
    font-size: 16px !important;
}

/* 列表项内容字体统一 */
#deep-preset-details .tavern-item,
#regex-detail-list .tavern-item {
    font-size: 14px !important;
}

#deep-preset-details .tavern-item > div,
#regex-detail-list .tavern-item > div {
    font-size: 14px !important;
}

/* 确保预设管理弹窗也有动画 */
#preset-modal .modal-content {
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

#preset-modal.active .modal-content {
    transform: scale(1);
    opacity: 1;
}

#preset-modal {
    transition: opacity 0.3s ease;
}

/* 模型选择弹窗样式 */
.model-item:active {
    background-color: var(--accent-color) !important;
    color: white !important;
}

.model-item:active div {
    color: white !important;
}

/* 滚动条美化 */
#model-list-container::-webkit-scrollbar {
    width: 6px;
}

#model-list-container::-webkit-scrollbar-thumb {
    background-color: var(--input-border);
    border-radius: 3px;
}

/* 自定义滚动条隐藏 */
#model-list-modal > div {
    overflow: hidden; /* 隐藏外部滚动条 */
}

/* 弹性滚动容器 */
#model-items-container {
    -webkit-overflow-scrolling: touch; /* iOS弹性滚动 */
    overscroll-behavior: contain; /* 防止滚动传播 */
    height: calc(70vh - 150px); /* 固定高度 */
    overflow-y: scroll; /* 启用滚动但隐藏滚动条 */
    scrollbar-width: none; /* Firefox隐藏滚动条 */
    -ms-overflow-style: none; /* IE隐藏滚动条 */
}

/* Chrome/Safari隐藏滚动条 */
#model-items-container::-webkit-scrollbar {
    display: none;
}

/* 强制隐藏所有滚动条 */
#model-list-modal ::-webkit-scrollbar {
    display: none !important;
    width: 0 !important;
    height: 0 !important;
    background: transparent !important;
}

#model-list-modal ::-webkit-scrollbar-track {
    display: none !important;
    background: transparent !important;
}

#model-list-modal ::-webkit-scrollbar-thumb {
    display: none !important;
    background: transparent !important;
}

#model-list-modal ::-webkit-scrollbar-corner {
    display: none !important;
    background: transparent !important;
}

/* Firefox隐藏滚动条 */
#model-list-modal {
    scrollbar-width: none !important;
}

/* 模型列表容器特殊处理 */
#model-items-container {
    -webkit-overflow-scrolling: touch !important;
    scrollbar-width: none !important;
    -ms-overflow-style: none !important;
}

#model-items-container::-webkit-scrollbar {
    display: none !important;
    width: 0 !important;
    height: 0 !important;
}

/* 强制隐藏模型弹窗的所有滚动条 */
#model-list-modal *::-webkit-scrollbar {
    display: none !important;
    width: 0 !important;
    height: 0 !important;
}

#model-items-container {
    -webkit-overflow-scrolling: touch !important;
    scrollbar-width: none !important;
    -ms-overflow-style: none !important;
}

/* 预设操作按钮样式 */
.preset-edit-btn, .preset-delete-btn {
    width: 30px;
    height: 30px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s;
}

.preset-edit-btn {
    background: var(--accent-color);
    color: white;
}

.preset-delete-btn {
    background: var(--danger-color);
    color: white;
    font-size: 18px;
    font-weight: bold;
}

.preset-edit-btn:hover, .preset-delete-btn:hover {
    transform: scale(1.1);
}

/* 编辑预设弹窗动画 */
#edit-preset-modal {
    animation: modalFadeIn 0.3s ease;
}

/* 弹窗动画 */
@keyframes modalFadeIn {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes modalFadeOut {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(20px);
    }
}

/* 现有的模态框动画增强 */
.overlay.active .modal-content {
    transform: scale(1);
    opacity: 1;
}

.modal-content {
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

/* 动态创建的弹窗也统一动画 */
#edit-preset-modal,
#model-list-modal,
#model-list-edit-modal {
    animation: modalFadeIn 0.3s ease;
}
/* 手机专用弹窗样式 */
@media screen and (max-width: 768px) {
    /* 所有弹窗内容 */
    .modal-content,
    #preset-modal .modal-content,
    #new-contact-modal .modal-content,
    #memory-modal .modal-content {
        width: 90% !important;
        max-width: 300px !important;
        max-height: 70vh !important;
        padding: 20px !important;
        margin: 10px !important;
    }
    
    /* 编辑预设弹窗 */
    #edit-preset-modal > div {
        width: 90% !important;
        max-width: 300px !important;
        padding: 20px !important;
    }
    
    /* 模型选择弹窗 */
    #model-list-modal > div,
    #model-list-edit-modal > div {
        width: 90% !important;
        max-width: 320px !important;
    }
    
    /* 弹窗内部标题 */
    .modal-content h4 {
        font-size: 18px !important;
        margin-bottom: 15px !important;
    }
    
    /* 弹窗内部输入框 */
    .modal-content input,
    .modal-content textarea {
        padding: 10px !important;
        font-size: 16px !important;
    }
    
    /* 弹窗按钮 */
    .modal-footer button {
        padding: 12px 16px !important;
        font-size: 16px !important;
    }
}
   </style>
</head>
<body>

    <div class="phone-frame" id="phone-frame">
        <div class="phone-screen" id="phone-screen">
                        <div class="status-bar">
                <!-- 需求4: 时间/信号/电量都去掉 -->
            </div>
            
            <div id="contacts-page" class="page" style="display: flex;">
               <div class="page-header" style="justify-content: space-between;">
    <div style="display: flex; align-items: center;">
        <div class="app-icon clickable" onclick="showPage('settings-page')" title="设置" style="margin-left: -15px; margin-right: -15px;">
    <i class="fas fa-cog"></i>
</div>
<div class="refresh-btn clickable" onclick="refreshAllData();" title="刷新所有数据">
            <i class="fa-solid fa-rotate"></i>
        </div>
        <div class="refresh-btn clickable" onclick="emergencyFix();" title="紧急修复" style="color: var(--danger-color);">
            <i class="fa-solid fa-wrench"></i>
        </div>
    </div>
    <h3 class="small-title" style="position: static; transform: none; left: auto; width: auto;">聊天室</h3>
    <div style="display: flex; align-items: center;">
        <div class="manage-button clickable" onclick="toggleManageMode()">管理</div>
        <div class="action-button plus-btn clickable" onclick="prepareRoleModal(null)"><i class="fa-solid fa-plus"></i></div>
    </div>
</div>
                <div id="contacts-list" class="contacts-list">
</div>
                <!-- 批量删除工具栏 -->
                <div id="batch-toolbar" class="batch-toolbar">
                    <div>
                        <button class="batch-cancel-btn clickable" onclick="cancelBatchDelete()">取消</button>
                        <button class="select-all-btn clickable" onclick="toggleSelectAll()">全选</button>
                    </div>
                    <div class="batch-info" id="selected-count">已选择 0 项</div>
                    <button class="batch-delete-btn clickable" onclick="deleteSelectedContacts()">删除</button>
                </div>
            </div>

            <div id="settings-page" class="page">
                <div class="page-header">
                    <div class="back-button" onclick="showPage('contacts-page')"><i class="fa-solid fa-angle-left"></i></div>
                    <h3>设置</h3>
                </div>
                <div class="content">
                    
<div style="display: flex; justify-content: space-between; gap: 10px; margin-bottom: 20px;">
    
    <div style="flex: 1; display: flex; align-items: center; justify-content: space-between; padding: 15px; background-color: var(--input-bg); border-radius: var(--radius-default); border: 1px solid var(--input-border);">
        <h4 style="font-size: 16px;">主题</h4>
        <div class="theme-switch-container" style="margin: 0;">
            <div class="theme-switch-track clickable" onclick="toggleThemeAuto()">
                <div class="theme-switch-thumb"></div>
                <i class="fas fa-sun theme-icon-left"></i>
                <i class="fas fa-moon theme-icon-right"></i>
            </div>
        </div>
    </div>

    <div style="flex: 1; display: flex; align-items: center; justify-content: space-between; padding: 15px; background-color: var(--input-bg); border-radius: var(--radius-default); border: 1px solid var(--input-border);">
        <h4 style="font-size: 16px;">保活</h4>
        <div class="theme-switch-container" style="margin: 0;">
            <div class="theme-switch-track clickable" onclick="toggleKeepAlive()" id="keep-alive-switch" style="background: var(--input-border);">
                <div class="theme-switch-thumb" style="left: 2px;"></div>
                <i class="fas fa-lock theme-icon-left" style="color: #888; font-size: 10px; left: 8px;"></i>
                <i class="fas fa-infinity theme-icon-right" style="color: #ffd700; font-size: 10px; right: 8px;"></i>
            </div>
        </div>
    </div>
</div>

<audio id="silent-audio" loop playsinline preload="auto" style="display:none;">
    <source src="https://raw.githubusercontent.com/anars/blank-audio/master/10-seconds-of-silence.mp3" type="audio/mpeg">
</audio>
<div class="settings-group">
    <h4>API 配置</h4>
    
    <!-- 预设选择 -->
    <label>配置名称:</label>
    <input type="text" id="api-preset-display" readonly 
           style="width: 100%; padding: 12px; margin-bottom: 10px; border-radius: var(--radius-default); 
                  background: var(--input-bg); color: var(--text-color-primary); 
                  border: 1px solid var(--input-border); cursor: pointer; 
                  font-size: 16px; box-sizing: border-box;"
           value="新建配置"
           onclick="openPresetManager()">
    
    <!-- 【新增】当前预设的模型选择（默认隐藏） -->
    <div id="current-preset-model-container" style="display: none; margin-bottom: 10px;">
        <label for="current-preset-model">当前模型:</label>
        <input type="text" id="current-preset-model" readonly
               style="width: 100%; padding: 12px; margin-top: 5px; border: 1px solid var(--input-border); 
                      border-radius: var(--radius-default); background-color: var(--input-bg); 
                      color: var(--text-color-primary); cursor: pointer; 
                      font-size: 16px; box-sizing: border-box;"
               onclick="openCurrentPresetModelSelector()"
               placeholder="点击选择模型">
    </div>
    
    <!-- 当没有预设时隐藏的区域 -->
    <div id="api-fields-container" style="display: none;">
        <!-- API URL -->
        <label for="api-url">API URL:</label>
        <input type="text" id="api-url" placeholder="输入 API URL">
        
        <!-- API Key -->
        <label for="api-key">API Key:</label>
        <input type="password" id="api-key" placeholder="输入您的 API Key">

        <!-- 【修改】模型选择（用于新建配置） -->
        <label for="ai-model" style="margin-top: 15px;">AI 模型:</label>
        <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="ai-model" readonly 
                   style="width: 100%; padding: 12px; margin-top: 5px; border: 1px solid var(--input-border); 
                          border-radius: var(--radius-default); background-color: var(--input-bg); 
                          color: var(--text-color-primary); cursor: pointer; 
                          font-size: 16px; box-sizing: border-box;"
                   onclick="openModelSelector()" 
                   placeholder="点击选择模型">
        </div>
        
        <!-- 保存为预设按钮 -->
        <button id="save-preset-btn" onclick="saveAsPreset()" 
                style="width: 100%; padding: 12px; margin-top: 15px; 
                       border-radius: var(--radius-default); background: var(--accent-color); 
                       color: white; border: none; cursor: pointer;">
            保存为预设
        </button>
    </div>
</div>
    
    <div class="settings-group">
    <h4>模型参数</h4>

    <!-- 流式输出开关 -->
    <div style="margin-bottom: 20px;">
    <div style="display: flex; align-items: center; margin-bottom: 8px;">
        <label style="font-weight: bold; font-size: 14px; color: var(--text-color-primary); margin-right: 10px;">流式输出</label>
        <div class="theme-switch-track clickable" 
             style="width: 40px; height: 20px; background: var(--input-border); margin-top: 9px;" 
             onclick="toggleStream()" 
             id="stream-switch">
            <div class="theme-switch-thumb" style="width: 18px; height: 18px; top: 1px; left: 1px;"></div>
        </div>
     </div>
    </div>

    <label style="margin-top: 10px; display: block;">温度 (Temperature): 
        <span id="temperature-value" style="font-weight: bold; color: var(--accent-color);">0.7</span>
    </label>
    <div class="temp-slider-container" style="margin: 12px 0 8px;">
        <div class="temp-slider-track" id="temp-track">
            <div class="temp-slider-thumb" id="temp-slider-thumb"></div>
        </div>
    </div>
    <input type="hidden" id="temperature" value="0.7">

    <div style="height: 15px;"></div> <label style="display: block;">最大回复长度 (Max Tokens): 
        <span id="maxTokens-value" style="font-weight: bold; color: var(--accent-color);">2048</span>
    </label>
    <div class="temp-slider-container" style="margin: 12px 0 8px;">
        <div class="temp-slider-track" id="maxTokens-track">
            <div class="temp-slider-thumb" id="maxTokens-thumb"></div>
        </div>
    </div>
    <input type="hidden" id="maxTokens-input" value="2048">
    
    <p style="font-size: 11px; color: var(--text-color-secondary); margin-top: 10px;">
        提示：温度影响创造力，Token 影响回复长度。
    </p>
</div>

<!-- 新增：其他API配置（共享主API配置） -->
<div class="settings-group">
    <h4>💡 其他API配置</h4>
    <p style="font-size: 12px; color: var(--text-color-secondary); margin-bottom: 15px;">
        用于后台补全长期记忆等功能，不影响主聊天
    </p>
    
    <!-- 长期记忆API配置 -->
    <h4 style="font-size: 15px; margin-top: 20px; margin-bottom: 10px; color: var(--text-color-primary);">📝 长期记忆API配置</h4>
    
    <!-- 预设选择（复用主API的配置列表） -->
    <label>配置名称:</label>
    <input type="text" id="backfill-preset-display" readonly 
           style="width: 100%; padding: 12px; margin-bottom: 10px; border-radius: var(--radius-default); 
                  background: var(--input-bg); color: var(--text-color-primary); 
                  border: 1px solid var(--input-border); cursor: pointer; 
                  font-size: 16px; box-sizing: border-box;"
           value="新建配置"
           onclick="openBackfillPresetManager()">
    
    <!-- 当前预设的模型选择 -->
    <div id="backfill-current-preset-model-container" style="display: none; margin-bottom: 10px;">
        <label for="backfill-current-preset-model">当前模型:</label>
        <input type="text" id="backfill-current-preset-model" readonly
               style="width: 100%; padding: 12px; margin-top: 5px; border: 1px solid var(--input-border); 
                      border-radius: var(--radius-default); background-color: var(--input-bg); 
                      color: var(--text-color-primary); cursor: pointer; 
                      font-size: 16px; box-sizing: border-box;"
               onclick="openBackfillCurrentPresetModelSelector()"
               placeholder="点击选择模型">
    </div>
</div>

    <!-- 新增：预设与正则管理模块 -->
<div class="settings-group">
    <h4>预设与正则管理</h4>
    
    <!-- 预设管理 -->
    <div style="margin-bottom: 10px;">
        <div style="display: flex; align-items: center; margin-bottom: 8px;">
            <label style="font-weight: bold; font-size: 14px; color: var(--text-color-primary); margin-right: 10px;">预设 (Deep Preset)</label>
            <div class="theme-switch-track clickable" style="width: 40px; height: 20px; background: var(--input-border); margin-top: 10px;" onclick="toggleDeepPreset()" id="deep-preset-switch">
                <div class="theme-switch-thumb" style="width: 18px; height: 18px; top: 1px; left: 1px;"></div>
            </div>
        </div>
        
        <input type="text" id="deep-preset-display" readonly 
               style="width: 100%; padding: 10px 12px; border-radius: var(--radius-default); 
                      background: var(--input-bg); color: var(--text-color-primary); 
                      border: 1px solid var(--input-border); cursor: pointer; 
                      font-size: 14px; box-sizing: border-box; -webkit-text-size-adjust: 100%;"
               value="未选择预设"
               onclick="openDeepPresetManager()">
    </div>
    
    <!-- 正则管理 -->
    <div>
        <div style="display: flex; align-items: center; margin-bottom: 8px;">
            <label style="font-weight: bold; font-size: 14px; color: var(--text-color-primary); margin-right: 10px;">正则 (Regex)</label>
            <div class="theme-switch-track clickable" style="width: 40px; height: 20px; background: var(--input-border); margin-top: 10px" onclick="toggleRegex()" id="regex-switch">
                <div class="theme-switch-thumb" style="width: 18px; height: 18px; top: 1px; left: 1px;"></div>
            </div>
        </div>
        
        <input type="text" id="regex-display" readonly 
               style="width: 100%; padding: 10px 12px; border-radius: var(--radius-default); 
                      background: var(--input-bg); color: var(--text-color-primary); 
                      border: 1px solid var(--input-border); cursor: pointer; 
                      font-size: 14px; box-sizing: border-box; -webkit-text-size-adjust: 100%;"
               value="未选择正则"
               onclick="openRegexManager()">
    </div>
</div>
       
<div class="settings-group">
    <h4>记忆配置</h4>
    
    <label for="context-limit">携带历史轮数 (临时记忆):</label>
    <p style="font-size: 12px; color: var(--text-color-secondary); margin-top: 2px; margin-bottom: 8px;">发送给AI的最近对话轮数（1轮=我问+AI答）。</p >
    <input type="number" id="context-limit" value="10" placeholder="默认 10">
    
    <label for="diary-interval">自动写日记频率 (轮数):</label>
    <p style="font-size: 12px; color: var(--text-color-secondary); margin-top: 2px; margin-bottom: 8px;">每隔多少轮对话，让AI总结一次长期记忆。</p >
    <input type="number" id="diary-interval" value="10" placeholder="默认 10">
</div>
                    <!-- 新增：头像设置区域 -->
                    <div class="settings-group avatar-settings">
                        <h4>AI 头像设置</h4>
                        <div class="avatar-preview-container">
                            <div class="avatar-preview-label">当前头像预览</div>
                            <div id="current-ai-avatar-preview" class="contact-avatar" style="width: 80px; height: 80px; font-size: 36px;"></div>
                            <input type="file" id="ai-avatar-file" accept="image/*" style="display: none;">
                            <input type="hidden" id="ai-avatar-base64">
                                                                                                                                                                                                                        <div class="avatar-actions" style="display: flex; gap: 10px;">
                                <button class="file-upload-btn clickable" onclick="document.getElementById('ai-avatar-file').click()" style="padding: 8px 15px; font-size: 14px; height: 36px; border: none; background: var(--accent-color); color: white; border-radius: 8px; white-space: nowrap;">上传新头像</button>
                                <button class="clickable" onclick="resetAvatar()" style="padding: 8px 15px; font-size: 14px; height: 36px; background-color: var(--input-bg); color: var(--text-color-primary); border: 1px solid var(--input-border); border-radius: 8px; white-space: nowrap;">重置</button>
                            </div>
                        </div>
                    </div>
                    
<div class="settings-group">
    <h4 style="margin-bottom: 5px;">通知服务</h4>
    <div style="margin-bottom: 20px">
    <div style="display: flex; align-items: center; margin-bottom: 8px;">
        <label style="font-weight: bold; font-size: 14px; color: var(--text-color-primary); margin-right: 10px;">通知显示内容</label>
        
        <div class="theme-switch-track clickable" 
             style="width: 40px; height: 20px; background: var(--accent-color); margin-top: 9px;" 
             onclick="toggleNotificationContent()" 
             id="notification-content-switch">
             
            <div class="theme-switch-thumb" style="width: 18px; height: 18px; top: 1px; left: 1px; transform: translateX(20px);"></div>
        </div>
     </div>
     <p style="font-size: 12px; color: #666; margin-top: -5px;">
         关闭后通知仅显示“收到新消息”，保护隐私。
     </p>
</div>
    <div style="display: flex; justify-content: center;">
        <button id="push-auth-btn" onclick="requestPushPermission()" 
                style="flex: 1; padding: 12px; background: var(--accent-color); color: white; 
                       border: none; border-radius: 10px; font-size: 15px; font-weight: 500; 
                       cursor: pointer; transition: all 0.2s;">
            允许接收通知
        </button>
    </div>
    
</div>

                                        <!-- 数据管理 -->
<div class="settings-group">
    <h4>数据管理</h4>
    <div style="margin-bottom: 12px; padding: 10px; background: var(--input-bg); border-radius: 8px;">
        <div style="display: flex; justify-content: space-between; font-size: 14px;">
            <span style="color: var(--text-color-primary);">已占用缓存:</span>
            <span id="cache-size" style="font-weight: bold; color: var(--accent-color);">计算中...</span>
        </div>
        <div style="height: 4px; background: var(--input-border); border-radius: 2px; margin-top: 8px; overflow: hidden;">
            <div id="cache-progress" style="height: 100%; background: var(--accent-color); width: 0%; transition: width 0.3s;"></div>
        </div>
    </div>

    <div style="display: flex; gap: 10px;">
        <button onclick="exportData()" style="flex:1; padding: 10px; background: var(--accent-color); color: white; border: none; border-radius: 10px;">导出数据</button>
        <button onclick="importData()" style="flex:1; padding: 10px; background: var(--input-bg); color: var(--text-color-primary); border: 1px solid var(--input-border); border-radius: 10px;">导入数据</button>
    </div>
</div>

<!-- 保存配置按钮 -->
<button onclick="saveSettings()" class="options-save-btn clickable">保存配置</button>
 
<div id="deep-preset-modal" class="overlay" style="z-index: 9999;">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;">
        <h4 style="margin-top: 0; margin-bottom: 15px; color: var(--text-color-primary);">预设库 (World Info)</h4>
        
        <div style="font-size:12px; color:var(--text-color-secondary); margin-bottom:10px;">点击预设名称进行编辑/启用:</div>
        
        <div style="max-height: 50vh; overflow-y: auto; margin-bottom: 20px; background:var(--bg-color-primary); border-radius:8px; padding:5px;" id="deep-preset-list">
        </div>
        
        <div style="display: flex; gap: 12px; justify-content: center;">
            <button onclick="importDeepPresetFile()" style="padding: 10px 20px; border-radius: 8px; background: var(--accent-color); color: white; border: none; cursor: pointer;">导入新预设</button>
            <button onclick="hideModal('deep-preset-modal')" style="padding: 10px 20px; border-radius: 8px; background: var(--input-bg); color: var(--text-color-primary); border: 1px solid var(--input-border); cursor: pointer;">关闭</button>
        </div>
    </div>
</div>

<div id="regex-modal" class="overlay" style="z-index: 9999;">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;">
        <h4 style="margin-top: 0; margin-bottom: 15px; color: var(--text-color-primary);">正则库 (Regex)</h4>
        
        <div style="font-size:12px; color:var(--text-color-secondary); margin-bottom:10px;">点击文件查看详细脚本:</div>
        
        <div style="max-height: 50vh; overflow-y: auto; margin-bottom: 20px; background:var(--bg-color-primary); border-radius:8px; padding:5px;" id="regex-file-list">
</div>
            
        <div style="display: flex; gap: 12px; justify-content: center;">
            <button onclick="importRegexFile()" style="padding: 10px 20px; border-radius: 8px; background: var(--accent-color); color: white; border: none; cursor: pointer;">导入正则</button>
            <button onclick="hideModal('regex-modal')" style="padding: 10px 20px; border-radius: 8px; background: var(--input-bg); color: var(--text-color-primary); border: 1px solid var(--input-border); cursor: pointer;">关闭</button>
        </div>
    </div>
</div>
              
<div id="regex-detail-modal" class="overlay" style="z-index: 10000;">
    <div class="modal-content" style="width: 90%; max-width: 350px; max-height: 80vh; display:flex; flex-direction:column; background: var(--bg-color-secondary) !important;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; height: 40px;">
            <div class="back-button clickable" onclick="hideModal('regex-detail-modal')" style="margin-right: 15px; display: flex; align-items: center;">
                <i class="fa-solid fa-angle-left"></i>
            </div>
            <h4 id="regex-detail-title" style="margin:0; flex-grow:1; text-align:center; color: var(--text-color-primary); font-size: 15px !important; line-height: 40px; transform: translateY(6px);">脚本详情</h4>
            <div style="width: 40px;"></div>
        </div>
        <div style="flex:1; overflow-y: auto; margin-bottom: 15px; background:var(--input-bg); border-radius:8px; padding:10px;" id="regex-detail-list"></div>
    </div>
</div>
                    
                </div>
            </div>
            
            <!-- 修改chat-window的结构 -->
<div id="chat-window" class="page">
    <div class="page-header">
        <div class="back-button" onclick="exitChatWindow()"><i class="fa-solid fa-angle-left"></i></div>
        <h3 id="chat-role-name"></h3> 
        <div class="action-button clickable" onclick="showPage('options-page')">···</div>
    </div>
    
    <!-- 新增：消息容器包装器 -->
    <div class="messages-wrapper">
        <div id="chat-messages" class="messages-container">
    <div id="loading-more" style="display:none; text-align:center; padding:10px; color:var(--text-color-secondary);">加载中...</div>
</div>
    </div>

    <div class="chat-input-area">
        <textarea id="chat-textarea" rows="1"></textarea>
    </div>
</div>
            
<!-- AI消息操作菜单 -->
<div id="ai-context-menu" class="context-menu" style="display: none;">
    <div class="menu-item clickable" onclick="regenerateFromBubble()">⟳</div>
</div>

                        <div id="options-page" class="page">
                <div class="page-header">
                    <div class="back-button" onclick="showPage('chat-window')"><i class="fa-solid fa-angle-left"></i></div>
                    <h3 id="options-role-name"></h3> 
                </div>
                <div class="content">
                    <div class="settings-group">
                       
                    <div class="options-item clickable" onclick="showMemoryModal('prompt')">
                            <span>角色 Prompt</span>
                            <span class="indicator">修改 ❯</span>
                        </div>
                        
                        <div class="options-item clickable" onclick="showMemoryModal('short')">
                            <span>临时记忆</span>
                            <span class="indicator">查看/编辑 ❯</span>
                        </div>
                        
                        <div class="options-item clickable" onclick="showMemoryModal('long')">
                            <span>长期记忆</span>
                            <span class="indicator">查看/编辑 ❯</span>
                        </div>
                    </div>
                    
                    <!-- 新增：清理记忆区域 -->
                    <div class="settings-group">
                        <h4 style="color: var(--warning-color); display: flex; align-items: center;">
    <i class="fas fa-eraser" style="margin-right: 10px;"></i>
    清理记忆
</h4>
                        <p style="color: var(--text-color-secondary); margin-top: 0; font-size: 14px;">这些操作不可撤销，请谨慎使用</p>
                        
                        <div class="clear-buttons">
                        <button class="clear-btn clear-short-btn clickable" onclick="clearShortTermMemory()">
                            <span class="clear-icon"><i class="fas fa-broom"></i></span>
                            <span>清空临时记忆</span>
                        </button>
                        
                        <button class="clear-btn clear-long-btn clickable" onclick="clearLongTermMemory()">
                            <span class="clear-icon"><i class="fas fa-trash-alt"></i></span>
                            <span>清空长期记忆</span>
                        </button>
                    </div>
                    </div>
                </div>
            </div>
            
            <div id="new-contact-modal" class="overlay">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;">
        <h4 id="modal-role-title">新建角色</h4>
        
        <div class="modal-scroll-area">
            <label for="modal-role-name">角色名:</label>
            <input type="text" id="modal-role-name" placeholder="例如: 心理导师">
            
            <label for="modal-role-prompt">角色设定 Prompt:</label>
            <textarea id="modal-role-prompt" rows="8" placeholder="填写对应的角色名和相关prompt"></textarea>
            
            <input type="hidden" id="modal-role-id">
        </div>
        
        <div class="modal-footer">
            <button class="cancel-btn clickable" onclick="hideModal('new-contact-modal')">取消</button>
            <button class="save-btn clickable" onclick="saveRoleFromModal()">保存</button>
        </div>
    </div>
</div>
            
           <div id="memory-modal" class="overlay">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;"> 
                    <div style="display: flex; align-items: center; margin-bottom: 15px;">
                        <div class="back-button clickable" onclick="goBackInMemoryModal()" style="margin-right: 15px;">
    <i class="fa-solid fa-angle-left"></i>
</div>
                        <h4 id="memory-modal-title" style="margin: 0; flex-grow: 1;"></h4>
                    </div>
                    
                    <div id="memory-content-container"></div>
                    
                    <div class="modal-footer">
                        <button id="memory-save-btn" class="save-btn clickable" onclick="saveContextModalData()">保存修改</button>
                        <button class="cancel-btn clickable" onclick="hideModal('memory-modal')">关闭</button>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
     // Web Push 配置
        const VAPID_PUBLIC_KEY = 'BKXLKgheQ0pGxeVUifzMecruF3o7OkniEkNSbBUM9sKIeUKn2M8NGG5h3YUV2YrHxzAoHS9-ILmz2MlrSoHt4NU'; // 替换为您生成的公钥
        const WORKER_URL = 'https://my-push-worker.ginkgo-yinxing.workers.dev';

	// 初始化分词器，指定中文环境 
	const segmenter = new Intl.Segmenter('zh-Hans', { granularity: 'word' });

	// 简单的停用词表（可以根据需要增加）
	const stopWords = new Set(['的', '了', '是', '我', '你', '他', '在', '不', '有', '个', '也', '就']);

    function extractKeywords(text) {
        // 1. 使用浏览器原生能力进行分词 
        const segments = segmenter.segment(text);
        const keywords = [];

        for (const segment of segments) {
            // 只保留“词语”类型，且长度大于1，且不是废词 
            if (segment.isWordLike && segment.segment.length > 1 && !stopWords.has(segment.segment)) {
                keywords.push(segment.segment);
            }
        }
        return keywords;
    }

        function calculateMemoryScore(queryKeywords, memoryKeywords) {
        let score = 0;
        queryKeywords.forEach(qKey => {
            if (memoryKeywords.includes(qKey)) {
                // 匹配到的词越长，分数越高（加权评分）
                score += qKey.length; 
            }
        });
        return score;
    }

        // 核心数据
        let APP_DATA = JSON.parse(localStorage.getItem('AI_PHONE_APP_DATA')) || {
    contacts: [
        { 
            id: 1, 
            name: '心理导师', 
            prompt: '你是一位专业的心理导师，以温暖、同情和专业的态度回复用户的问题。', 
            history: [], 
            longMemories: [], // 改为数组
            shortTermMemory: [],
            summaryCount: 0,
            summaryThreshold: 30
        },
        { 
            id: 2, 
            name: '英语陪练', 
            prompt: '你是一位只说英语的口语陪练，每句话都必须是英语。', 
            history: [], 
            longMemories: [], // 改为数组
            shortTermMemory: [],
            summaryCount: 0,
            summaryThreshold: 30
        }
    ],
            settings: {
            apiUrl: 'https://api.siliconflow.cn/v1/chat/completions',
            apiKey: '',
            aiModel: 'qwen-72b-chat',
            temperature: 0.7,
            aiAvatarBase64: 'AI',
            contextLimit: 20,
            diaryInterval: 20,
            stream: false  
        },
            currentTheme: 'light',
            currentChatId: null,
            activeModalContext: null,
            presets: [], 
            currentPresetId: null, // 当前预设ID
            // 新增：深预设和正则数据
            deepPresets: [],        // 深预设数组
            regexPatterns: [],      // 正则表达式数组
            currentDeepPresetId: null,  // 当前选中的深预设ID
            currentRegexId: null,       // 当前选中的正则ID
            deepPresetEnabled: false,   // 深预设是否启用
            regexEnabled: false         // 正则是否启用
        };  // <-- 确保这里的分号

            let currentContact = null;
            let isManageMode = false; // 管理模式状态
            let batchMode = false; // 批量删除模式
            let selectedContacts = new Set(); // 选择的联系人ID集合
            let isTyping = false; // AI是否正在输入
            let currentAIRequest = null; // 新增：存储当前AI请求
            let currentController = null; // 新增：用于取消请求的控制器
            let currentStartIndex = 0;
            const PAGE_SIZE = 10; 
            let isLoadingMore = false; 
        
        // ----------------------- 数据存储和加载 -----------------------
        function saveData() {
            localStorage.setItem('AI_PHONE_APP_DATA', JSON.stringify(APP_DATA));
        }

        function loadSettings() {
    // 1. 加载基础设置
    document.getElementById('api-url').value = APP_DATA.settings.apiUrl || '';
    document.getElementById('api-key').value = APP_DATA.settings.apiKey || '';
    document.getElementById('ai-model').value = APP_DATA.settings.aiModel || '';
    document.getElementById('temperature').value = APP_DATA.settings.temperature || 0.7;
    document.getElementById('maxTokens-input').value = APP_DATA.settings.maxTokens || 2048;
    document.getElementById('context-limit').value = APP_DATA.settings.contextLimit || 20;
    document.getElementById('diary-interval').value = APP_DATA.settings.diaryInterval || 10;
    
    window.isNotificationContentEnabled = APP_DATA.settings.notificationShowContent !== false;
    loadAvatarPreview(APP_DATA.settings.aiAvatarBase64, 'current-ai-avatar-preview');
    document.getElementById('ai-avatar-base64').value = APP_DATA.settings.aiAvatarBase64 || '';

    // 2. 加载当前预设名称
    if (APP_DATA.currentPresetId) {
        const preset = APP_DATA.presets ? APP_DATA.presets.find(p => p.id == APP_DATA.currentPresetId) : null;
        if (preset) {
            document.getElementById('api-preset-display').value = preset.name;
            const saveBtn = document.getElementById('save-preset-btn');
            const apiContainer = document.getElementById('api-fields-container');
            if (saveBtn) saveBtn.style.display = 'none';
            if (apiContainer) apiContainer.style.display = 'none';
        }
    }

    // 3. 核心修复：强制加载正则和预设数据
    // 使用 setTimeout 确保页面元素完全就绪后再渲染，防止“消失”
    setTimeout(() => {
        try {
            ensureTavernData(); // 确保数据结构完整
            loadDeepPresetAndRegexSettings(); // 更新开关状态
            updateRegexUI(); // 强制刷新正则列表
            updateDeepPresetUI(); // 强制刷新预设列表
        } catch (e) {
            console.error("初始化酒馆组件失败:", e);
        }
    }, 100);

    updateSwitchState('stream-switch', APP_DATA.settings.stream || false);
}
        
        // 新增：初始化预设系统
function initPresetSystem() {
    const apiFieldsContainer = document.getElementById('api-fields-container');
    const modelContainer = document.getElementById('current-preset-model-container');
    
    // 确保预设数组存在
    if (!APP_DATA.presets) {
        APP_DATA.presets = [];
    }
    
    console.log('初始化配置系统，配置数量:', APP_DATA.presets.length);
    
    if (APP_DATA.presets.length === 0) {
        // 没有配置，显示新建配置状态
        document.getElementById('api-preset-display').value = '新建配置';
        document.getElementById('save-preset-btn').style.display = 'block';
        APP_DATA.currentPresetId = null;
        
        // 【新增】隐藏当前预设模型选择框
        if (modelContainer) {
            modelContainer.style.display = 'none';
        }
        
        // 显示 API 输入字段（因为是新建配置状态）
        if (apiFieldsContainer) {
            apiFieldsContainer.style.display = 'block';
        }
    } else {
        // 如果有配置，加载第一个或当前配置
        if (APP_DATA.currentPresetId) {
            loadPreset(APP_DATA.currentPresetId);
        } else {
            loadPreset(APP_DATA.presets[0].id);
        }
    }
}


// 显示预设管理弹窗（简单版）
function showPresetModal() {
    refreshPresetList(); // 刷新列表
    showModal('preset-modal'); // 显示弹窗
}

// 新增：在弹窗中编辑预设
function editPresetInModal(presetId, event) {
    event.stopPropagation();
    
    const preset = APP_DATA.presets.find(p => p.id == presetId);
    if (!preset) return;
    
    const newName = prompt('修改配置名称:', preset.name);
    if (newName && newName.trim()) {
        preset.name = newName.trim();
        saveData();
        showPresetModal(); // 刷新弹窗
    }
}

// 新增：在弹窗中删除配置
function deletePresetInModal(presetId, event) {
    event.stopPropagation();
    
    if (!confirm('确定要删除这个配置吗？')) return;
    
    // 从数组中删除
    APP_DATA.presets = APP_DATA.presets.filter(p => p.id != presetId);
    
    // 如果删的是当前配置
    if (APP_DATA.currentPresetId == presetId) {
        // 如果还有配置，切换到第一个
        if (APP_DATA.presets.length > 0) {
            loadPreset(APP_DATA.presets[0].id);
        } else {
            // 没有配置了，回到新建状态
            document.getElementById('api-preset-display').value = '新建配置';
            document.getElementById('api-url').value = '';
            document.getElementById('api-key').value = '';
            document.getElementById('ai-model').value = '';
            document.getElementById('save-preset-btn').style.display = 'block';
            APP_DATA.currentPresetId = null;
        }
    }
    
    saveData();
    showPresetModal(); // 刷新弹窗
}

function loadPreset(presetId) {
    const preset = APP_DATA.presets.find(p => p.id == presetId);
    const apiFieldsContainer = document.getElementById('api-fields-container');
    const modelContainer = document.getElementById('current-preset-model-container');
    
    if (!preset) {
        console.log('未找到配置:', presetId);
        return;
    }

    console.log('加载配置:', preset.name);
    
    APP_DATA.currentPresetId = presetId;
    document.getElementById('api-preset-display').value = preset.name;
    
    // 【新增】记录最后使用时间
    preset.lastUsedTime = Date.now();
    
    // 【新增】显示当前配置的模型选择框
    if (modelContainer) {
        modelContainer.style.display = 'block';
        document.getElementById('current-preset-model').value = preset.defaultModel || '';
    }
    
    // 【新增】隐藏新建配置区域（如果有配置）
    if (apiFieldsContainer) {
        apiFieldsContainer.style.display = 'none';
    }
    document.getElementById('save-preset-btn').style.display = 'none';
    
    // 同步到settings
    APP_DATA.settings.apiUrl = preset.apiUrl || '';
    APP_DATA.settings.apiKey = preset.apiKey || '';
    APP_DATA.settings.aiModel = preset.defaultModel || '';
    
    // 保存当前状态
    saveData();
}

// 新增：创建新配置（从弹窗）
function createNewPreset() {
    hideModal('preset-modal');
    selectPreset('new');
}

/// 保存为配置（简单版）
function saveAsPreset() {
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const model = document.getElementById('ai-model').value.trim();
    
    if (!apiUrl || !apiKey) {
        alert('请先填写API URL和API Key');
        return;
    }

    const presetName = prompt('请输入配置名称:', '我的配置');
    if (!presetName || !presetName.trim()) return;
    
        // 创建新配置
    const newPreset = {
        id: Date.now(),
        name: presetName.trim(),
        apiUrl: apiUrl,
        apiKey: apiKey,
        defaultModel: model,
        lastUsedTime: Date.now()  
    };
    
    console.log('正在保存配置:', newPreset); // 调试用
    
    // 添加到配置数组
    if (!APP_DATA.presets) {
        APP_DATA.presets = [];
    }
    APP_DATA.presets.push(newPreset);
    APP_DATA.currentPresetId = newPreset.id;
    
    // 同步到settings
    APP_DATA.settings.apiUrl = apiUrl;
    APP_DATA.settings.apiKey = apiKey;
    APP_DATA.settings.aiModel = model;
    
    // 保存到本地存储
    localStorage.setItem('AI_PHONE_APP_DATA', JSON.stringify(APP_DATA));
    
    // 更新显示
    document.getElementById('api-preset-display').value = newPreset.name;
    document.getElementById('save-preset-btn').style.display = 'none';
    
    // 隐藏API输入字段
    const apiFieldsContainer = document.getElementById('api-fields-container');
    if (apiFieldsContainer) {
        apiFieldsContainer.style.display = 'none';
    }
    
    alert('配置保存成功！');
    
    // 刷新配置列表（如果弹窗打开着）
    refreshPresetList();
}

async function fetchModels() {
    // 获取API信息
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    
    // 验证
    if (!apiUrl || !apiKey) {
        alert('请先填写API URL和API Key');
        return;
    }
    
    // 显示加载中
    const modelInput = document.getElementById('ai-model');
    const originalValue = modelInput.value;
    modelInput.value = '正在获取模型列表...';
    modelInput.disabled = true;
    
    try {
        // 构建模型列表URL（兼容不同API提供商）
        let modelsUrl = '';
        if (apiUrl.includes('siliconflow')) {
            modelsUrl = apiUrl.replace('/chat/completions', '/models');
        } else if (apiUrl.includes('openai')) {
            modelsUrl = 'https://api.openai.com/v1/models';
        } else {
            // 通用格式：尝试移除路径末尾部分
            modelsUrl = apiUrl.replace(/\/chat\/completions$/, '/models');
        }
        
        console.log('请求模型列表URL:', modelsUrl);
        
        // 发送请求
        const response = await fetch(modelsUrl, {
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`请求失败: ${response.status}`);
        }
        
        const data = await response.json();
        
        // 提取模型列表（兼容不同格式）
        let models = [];
        if (Array.isArray(data)) {
            models = data; // 直接是数组
        } else if (data.data && Array.isArray(data.data)) {
            models = data.data; // {data: [...]}
        } else if (data.models && Array.isArray(data.models)) {
            models = data.models; // {models: [...]}
        }
        
        if (models.length === 0) {
            alert('未获取到模型列表，请手动输入模型名称');
            modelInput.value = originalValue;
            return;
        }
        
        // 显示模型选择弹窗
        showModelSelectDialog(models);
        
    } catch (error) {
        console.error('获取模型失败:', error);
        alert('获取模型失败: ' + error.message + '\n请手动输入模型名称');
    } finally {
        modelInput.disabled = false;
        if (modelInput.value === '正在获取模型列表...') {
            modelInput.value = originalValue;
        }
    }
}


       
function saveSettings() {
    // 【重要修改】如果当前在"新建配置"状态，不要更新任何配置
    if (APP_DATA.currentPresetId) {
        const preset = APP_DATA.presets.find(p => p.id == APP_DATA.currentPresetId);
        if (preset) {
            preset.apiUrl = document.getElementById('api-url').value;
            preset.apiKey = document.getElementById('api-key').value;
            preset.defaultModel = document.getElementById('ai-model').value;
        }
    }
    
    // 保存到APP_DATA.settings
    APP_DATA.settings.apiUrl = document.getElementById('api-url').value;
    APP_DATA.settings.apiKey = document.getElementById('api-key').value;
    APP_DATA.settings.aiModel = document.getElementById('ai-model').value;
    APP_DATA.settings.temperature = parseFloat(document.getElementById('temperature').value) || 0.7;
    APP_DATA.settings.maxTokens = parseInt(document.getElementById('maxTokens-input').value) || 2048;
    // 新增：保存记忆设置
    APP_DATA.settings.contextLimit = parseInt(document.getElementById('context-limit').value) || 20;
    APP_DATA.settings.diaryInterval = parseInt(document.getElementById('diary-interval').value) || 10;
    // 【重要】OneSignal Key 不在这里保存，它有专门的保存函数

    const avatarBase64 = document.getElementById('ai-avatar-base64').value;
    APP_DATA.settings.aiAvatarBase64 = avatarBase64 || 'AI';
    
    saveData();
    alert('设置已保存！');
    renderContacts(); 
}
        
// 显示弹窗并加载已保存的 Key
function showPushKeyModal() {
    // 确保从 APP_DATA 读取
    const savedKey = APP_DATA.settings.oneSignalKey || '';
    document.getElementById('onesignal-key-input').value = savedKey;
    showModal('push-key-modal');
}

function savePushKey() {
    const keyVal = document.getElementById('onesignal-key-input').value.trim();
    if (!keyVal) return;
    
    // 强制更新到 settings 对象中，防止被 saveSettings 覆盖
    APP_DATA.settings.oneSignalKey = keyVal;
    
    saveData(); // 保存到本地存储 [cite: 496]
    hideModal('push-key-modal');
    alert('通知 API 配置已成功同步！');
}

/* ================= 修复版：酒馆功能核心引擎 (预设与正则) ================= */

// 0. 数据结构初始化与迁移 (确保APP_DATA中有我们需要的数据)
function ensureTavernData() {
    // 初始化预设数组
    if (!APP_DATA.deepPresets) APP_DATA.deepPresets = [];
    
    // 初始化正则文件集合 (这就是我们用来实现"先看文件名"的新结构)
    if (!APP_DATA.regexCollections) APP_DATA.regexCollections = [];
    
    // 迁移旧数据：如果用户之前有散乱的正则，把它们打包进一个"默认文件"
    if (APP_DATA.regexPatterns && APP_DATA.regexPatterns.length > 0) {
        APP_DATA.regexCollections.push({
            id: 'legacy_' + Date.now(),
            name: '旧版导入数据',
            scripts: [...APP_DATA.regexPatterns],
            enabled: true
        });
        APP_DATA.regexPatterns = []; // 清空旧结构，以后只用 Collections
        saveData();
    }
}

// 1. 预设 Prompt 注入逻辑
function applyDeepPresetToPrompt() {
    if (!APP_DATA.deepPresetEnabled || !APP_DATA.currentDeepPresetId) return "";
    const preset = APP_DATA.deepPresets.find(p => p.id === APP_DATA.currentDeepPresetId);
    if (!preset || !preset.prompts) return "";

    let injectedText = "\n【世界书/预设规则】\n";
    preset.prompts.forEach(p => {
        if (p.enabled !== false && p.content) {
            injectedText += `${p.content}\n`;
        }
    });
    return injectedText;
}

// 2. 正则处理逻辑 (修复版：遍历所有启用的文件)
function applyRegexToText(text) {
    if (!APP_DATA.regexEnabled || !APP_DATA.regexCollections) return text;
    let processedText = text;
    
    // 遍历每一个正则文件
    APP_DATA.regexCollections.forEach(collection => {
        // 如果文件被禁用了，跳过
        if (collection.enabled === false) return;
        
        // 遍历文件里的脚本
        if (collection.scripts) {
            collection.scripts.forEach(script => {
                if (script.disabled) return; 
                // 仅处理输出(placement包含2或未定义)
                if (script.placement && !script.placement.includes(2)) return;

                try {
                    let pattern = script.regex; 
                    let flags = 'g';
                    // 处理 /abc/g 这种格式
                    if (pattern.startsWith('/') && pattern.lastIndexOf('/') > 0) {
                        const lastSlash = pattern.lastIndexOf('/');
                        const flagStr = pattern.substring(lastSlash + 1);
                        if(flagStr) flags = flagStr;
                        pattern = pattern.substring(1, lastSlash);
                    }
                    
                    const regex = new RegExp(pattern, flags);
                    processedText = processedText.replace(regex, script.replace || "");
                } catch (e) {
                    console.warn("正则执行错误:", script.name, e);
                }
            });
        }
    });
    return processedText;
}

/* ================= 导入系统 (兼容性增强) ================= */

// 3. 导入预设
function importDeepPresetFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.style.display = 'none';
    document.body.appendChild(input); 
    
    input.onchange = e => {
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const json = JSON.parse(ev.target.result);
                let presetName = json.name || (input.files[0] ? input.files[0].name.replace('.json', '') : "导入预设");

                let extractedPrompts = [];
                // 兼容 SillyTavern / 这里的格式
                if (Array.isArray(json.prompts)) {
                    extractedPrompts = json.prompts;
                } else {
                    // 尝试提取常见字段
                    const fields = [
                        { key: 'main_prompt', name: 'Main Prompt' },
                        { key: 'jailbreak_prompt', name: 'Jailbreak' },
                        { key: 'nsfw_prompt', name: 'NSFW' },
                        { key: 'story_string', name: 'Story String' },
                        { key: 'system_prompt', name: 'System Prompt' }
                    ];
                    fields.forEach(field => {
                        if (json[field.key]) extractedPrompts.push({ name: field.name, content: json[field.key], enabled: true });
                    });
                }

                if (extractedPrompts.length === 0) {
                     extractedPrompts.push({ name: "通用设置", content: "无内容", enabled: true });
                }

                const newPreset = {
                    id: Date.now().toString(), 
                    name: presetName,
                    prompts: extractedPrompts
                };

                if (!APP_DATA.deepPresets) APP_DATA.deepPresets = [];
                APP_DATA.deepPresets.push(newPreset);
                APP_DATA.currentDeepPresetId = newPreset.id; // 自动选中
                
                saveData();
                updateDeepPresetUI(); // 刷新列表
                alert(`✅ 成功导入预设: ${presetName}`);
                
            } catch (err) { 
                alert('预设解析失败: ' + err.message); 
            } finally {
                document.body.removeChild(input);
            }
        };
        reader.readAsText(e.target.files[0]);
    };
    input.click();
}

// 4. 导入正则 (修复Undefined问题)
function importRegexFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.style.display = 'none';
    document.body.appendChild(input);

    input.onchange = e => {
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const json = JSON.parse(ev.target.result);
                const fileName = input.files[0] ? input.files[0].name.replace('.json', '') : "导入的正则";
                let scripts = [];

                // 核心：处理 undefined 的关键，增加多重判断
                const normalizeScript = (item, idx) => {
                    // 尝试获取名字，如果都没有，就叫“正则脚本+序号”
                    const name = item.scriptName || item.name || item.key || item.comment || `正则脚本 ${idx + 1}`;
                    // 尝试获取正则内容
                    const regexStr = item.findRegex || item.regex || item.pattern || item.source;
                    // 尝试获取替换内容
                    const replaceStr = (item.replaceString !== undefined) ? item.replaceString : (item.replace !== undefined ? item.replace : "");
                    
                    if (regexStr) {
                        return {
                            id: Date.now() + Math.random().toString(36).substr(2, 5),
                            name: name,
                            regex: regexStr,
                            replace: replaceStr,
                            disabled: item.disabled === true,
                            placement: item.placement // 保留位置信息
                        };
                    }
                    return null;
                };

                // 判断 JSON 结构：是数组还是对象？
                let rawList = [];
                if (Array.isArray(json)) {
                    rawList = json;
                } else if (json.scripts && Array.isArray(json.scripts)) {
                    rawList = json.scripts;
                } else if (json.regex_scripts && Array.isArray(json.regex_scripts)) {
                    rawList = json.regex_scripts;
                }

                if (rawList.length > 0) {
                    rawList.forEach((item, idx) => {
                        const s = normalizeScript(item, idx);
                        if (s) scripts.push(s);
                    });
                } else {
                    // 尝试作为单个对象处理
                    const s = normalizeScript(json, 0);
                    if (s) scripts.push(s);
                }

                if (scripts.length > 0) {
                    // 创建一个新的“正则文件集合”
                    const newCollection = {
                        id: Date.now().toString(),
                        name: fileName,
                        scripts: scripts,
                        enabled: true
                    };
                    
                    ensureTavernData();
                    APP_DATA.regexCollections.push(newCollection);
                    saveData();
                    updateRegexUI(); // 刷新 UI
                    alert(`✅ 成功导入文件 "${fileName}"，包含 ${scripts.length} 条脚本！`);
                } else {
                    alert("导入失败：文件中未找到有效的正则格式。\n请确认是酒馆(SillyTavern)或常见的正则JSON格式。");
                }

            } catch (err) {
                console.error(err);
                alert('文件解析错误: ' + err.message);
            } finally {
                document.body.removeChild(input);
            }
        };
        reader.readAsText(e.target.files[0]);
    };
    input.click();
}

/* ================= 界面渲染 (UI) ================= */

// 打开预设管理（一级：文件列表）
function openDeepPresetManager() {
    ensureTavernData();
    updateDeepPresetUI();
    showModal('deep-preset-modal');
}

// 全局变量：记录当前正在编辑的预设ID (放在所有函数外面，或者 script 标签最开头)
let editingPresetId = null; 

// ==========================================
// 函数 1：渲染预设列表 (完全仿照正则列表的排版)
// ==========================================
function updateDeepPresetUI() {
    const container = document.getElementById('deep-preset-list');
    const displayInput = document.getElementById('deep-preset-display');
    
    // 1. 更新主界面显示的文字
    if (displayInput) {
        const active = APP_DATA.deepPresets.find(p => String(p.id) === String(APP_DATA.currentDeepPresetId));
        displayInput.value = active ? active.name : "未选择预设";
    }

    if (!container) return;
    container.innerHTML = ''; 

    // 2. 如果没数据，显示空提示
    if (!APP_DATA.deepPresets || APP_DATA.deepPresets.length === 0) {
        container.innerHTML = '<div style="text-align:center; padding:20px; color:#888">暂无预设</div>';
        return;
    }

    // 3. 循环生成列表项 (结构与正则列表完全一致)
    APP_DATA.deepPresets.forEach(preset => {
        const div = document.createElement('div');
        div.className = 'tavern-item'; // 使用相同的样式类
        
        // 判断是否是当前选中的预设
        const isActive = (String(preset.id) === String(APP_DATA.currentDeepPresetId));
        
        // --- A. 左侧：点击进入编辑 (仿照正则) ---
        const infoDiv = document.createElement('div');
        infoDiv.style.flex = '1';
        infoDiv.style.cursor = 'pointer';
        // 选中时文字变色，不选中时普通颜色
        if (isActive) infoDiv.style.color = 'var(--accent-color)';
        
        infoDiv.innerHTML = `
            <div style="font-weight:bold; font-size:14px;">${preset.name}</div>
            <div style="font-size:11px; color:#888">包含 ${preset.prompts ? preset.prompts.length : 0} 条内容</div>
        `;
        
        // ★★★ 点击名字：仅选中预设，不打开详情 ★★★
        infoDiv.onclick = function(e) {
            e.stopPropagation();
            
            // 判断是否已经选中
            const isCurrentlySelected = (String(APP_DATA.currentDeepPresetId) === String(preset.id));
            
            if (isCurrentlySelected) {
                // 如果已选中，则取消选中
                APP_DATA.currentDeepPresetId = null;
                APP_DATA.deepPresetEnabled = false; // 关闭总开关
            } else {
                // 如果未选中，则选中这个预设
                APP_DATA.currentDeepPresetId = String(preset.id);
                APP_DATA.deepPresetEnabled = true; // 开启总开关
            }
            
            saveData();
            
            // 更新总开关UI
            const switchBtn = document.getElementById('deep-preset-switch');
            if (switchBtn) {
                const thumb = switchBtn.querySelector('.theme-switch-thumb');
                if (APP_DATA.deepPresetEnabled) {
                    thumb.style.left = '20px';
                    switchBtn.style.background = 'var(--accent-color)';
                } else {
                    thumb.style.left = '1px';
                    switchBtn.style.background = 'var(--input-border)';
                }
            }
            
            // 刷新列表显示（显示新的选中颜色）
            updateDeepPresetUI();
        };
        div.appendChild(infoDiv);

        // --- B. 右侧：编辑按钮 + 删除按钮 ---
        const controlsDiv = document.createElement('div');
        controlsDiv.style.display = 'flex';
        controlsDiv.style.alignItems = 'center';
        controlsDiv.style.gap = '6px';
        controlsDiv.style.justifyContent = 'flex-end';

        // 编辑按钮 (绿色笔)
        const editBtn = document.createElement('div');
        editBtn.innerHTML = '<i class="fas fa-edit"></i>';
        editBtn.style.color = 'var(--accent-color)';
        editBtn.style.cursor = 'pointer';
        editBtn.style.fontSize = '14px';
        editBtn.style.padding = '8px';
        
        editBtn.onclick = function(e) {
            e.stopPropagation();
            openDeepPresetDetail(preset.id);
        };
        controlsDiv.appendChild(editBtn);

        // 删除按钮 (红色垃圾桶)
        const deleteBtn = document.createElement('div');
        deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
        deleteBtn.style.color = 'var(--danger-color)';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.fontSize = '14px';
        deleteBtn.style.padding = '8px';
        
        deleteBtn.onclick = function(e) {
            e.stopPropagation();
            if (confirm(`确定要删除预设 "${preset.name}" 吗？`)) {
                APP_DATA.deepPresets = APP_DATA.deepPresets.filter(p => String(p.id) !== String(preset.id));
                // 如果删掉的是当前正在用的，重置状态
                if (String(APP_DATA.currentDeepPresetId) === String(preset.id)) {
                    APP_DATA.currentDeepPresetId = null;
                }
                saveData();
                updateDeepPresetUI();
            }
        };
        controlsDiv.appendChild(deleteBtn);

        div.appendChild(controlsDiv);
        container.appendChild(div);
    });
}

// ==========================================
// 函数 2：打开预设详情窗口 (修复版 - 更清晰的数据检查)
// ==========================================
function openDeepPresetDetail(presetId) {
    console.log('🔍 [调试] 打开预设详情，收到ID:', presetId);
    
    // 1. 基础检查
    editingPresetId = String(presetId);
    
    if (!APP_DATA.deepPresets || !Array.isArray(APP_DATA.deepPresets)) {
        alert('❌ 预设数据异常！请刷新页面重试。');
        return;
    }
    
    // 2. 查找预设
    let preset = APP_DATA.deepPresets.find(p => String(p.id) === String(presetId));
    
    if (!preset) {
        alert('❌ 找不到该预设！ID: ' + presetId);
        console.error('可用的预设ID:', APP_DATA.deepPresets.map(p => p.id));
        return;
    }
    
    console.log('✅ 找到预设:', preset.name, '内容项数量:', preset.prompts ? preset.prompts.length : 0);
    
    // 3. 更新标题
    const titleEl = document.getElementById('preset-detail-title');
    if (!titleEl) {
        alert('❌ 弹窗HTML结构错误！找不到标题元素');
        return;
    }
    titleEl.textContent = preset.name;
    
    // 4. 渲染内容
    const container = document.getElementById('deep-preset-details');
    if (!container) {
        alert('❌ 找不到内容容器！');
        return;
    }
    
    container.innerHTML = ''; // 清空
    
    // 5. 检查数据并渲染
    if (!preset.prompts || !Array.isArray(preset.prompts) || preset.prompts.length === 0) {
        console.warn('⚠️ 预设没有内容数据');
        container.innerHTML = `
            <div style="text-align:center; padding:40px 20px; color:var(--text-color-secondary); line-height:1.8;">
                <div style="font-size:48px; margin-bottom:15px;">📭</div>
                <div style="font-size:16px; font-weight:bold; margin-bottom:8px;">该预设暂无内容</div>
                <div style="font-size:13px; opacity:0.7;">可能原因：</div>
                <div style="font-size:13px; opacity:0.7;">1. 导入的文件格式不正确</div>
                <div style="font-size:13px; opacity:0.7;">2. 预设文件内容为空</div>
                <div style="font-size:13px; opacity:0.7; margin-top:10px;">
                    <strong>解决方案：</strong><br>
                    请删除此预设，重新导入正确的酒馆预设文件
                </div>
            </div>
        `;
    } else {
        // 正常渲染（新UI：取消预览，右侧显示详情按钮和开关）
        console.log('📝 开始渲染', preset.prompts.length, '个内容项');
        
        preset.prompts.forEach((prompt, idx) => {
            const div = document.createElement('div');
            div.className = 'tavern-item';
            div.style.cssText = 'display:flex; align-items:center; justify-content:space-between; padding:10px 12px;';
            
            // 左侧：功能名称（不显示内容预览）
            const nameDiv = document.createElement('div');
            nameDiv.style.cssText = 'flex:1; overflow:hidden;';
            nameDiv.innerHTML = `<div style="font-weight:bold; font-size:14px; color:var(--text-color-primary);">${prompt.name || '未命名内容 ' + (idx + 1)}</div>`;
            
            // 右侧：详情按钮 + 开关
            const controlsDiv = document.createElement('div');
            controlsDiv.style.cssText = 'display:flex; align-items:center; gap:8px; flex-shrink:0;';
            
            // 详情按钮
            const detailBtn = document.createElement('div');
            detailBtn.innerHTML = '<i class="fa-solid fa-circle-info"></i>';
            detailBtn.style.cssText = `
                padding: 0;
                width: 30px;
                height: 30px;
                background: transparent;
                color: var(--accent-color);
                border: none;
                cursor: pointer;
                font-size: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                transform: translateY(0px);
            `;
            detailBtn.title = '查看/编辑详情';
            detailBtn.onclick = (e) => {
                e.stopPropagation();
                showPresetPromptDetail(presetId, idx);
            };
            
            // 开关
            const switchLabel = document.createElement('label');
            switchLabel.className = 'switch';
            switchLabel.style.marginTop = '0px';
            switchLabel.innerHTML = `
                <input type="checkbox" ${prompt.enabled !== false ? 'checked' : ''} 
                       onchange="togglePresetPrompt('${preset.id}', ${idx}, this.checked)">
                <span class="slider"></span>
            `;
            
            controlsDiv.appendChild(detailBtn);
            controlsDiv.appendChild(switchLabel);
            
            div.appendChild(nameDiv);
            div.appendChild(controlsDiv);
            container.appendChild(div);
        });
        
        console.log('✅ 成功渲染', preset.prompts.length, '个内容项');
    }
    
    // 6. 更新按钮状态
    const useBtn = document.getElementById('use-preset-btn');
    if (useBtn) {
        const isActive = String(APP_DATA.currentDeepPresetId) === String(presetId);
        
        if (isActive) {
            useBtn.textContent = "✓ 当前正在使用";
            useBtn.style.background = "#95C296";
            useBtn.style.cursor = "not-allowed";
            useBtn.disabled = true;
        } else {
            useBtn.textContent = "使用此预设";
            useBtn.style.background = "var(--accent-color)";
            useBtn.style.cursor = "pointer";
            useBtn.disabled = false;
        }
    }
    
    // 7. 显示弹窗
    showModal('deep-preset-detail-modal');
    console.log('✅ 预设详情弹窗已打开');
}



// 新增:显示预设内容详情编辑弹窗
function showPresetPromptDetail(presetId, promptIdx) {
    const preset = APP_DATA.deepPresets.find(p => String(p.id) === String(presetId));
    if (!preset || !preset.prompts[promptIdx]) return;
    
    const prompt = preset.prompts[promptIdx];
    
    // 创建详情编辑弹窗
    const detailModal = document.createElement('div');
    detailModal.id = 'preset-prompt-detail-modal';
    detailModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.6); z-index: 10001;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    detailModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                    width: 90%; max-width: 350px; max-height: 75vh;
                    display: flex; flex-direction: column; padding: 20px;">
            
            <div style="display: flex; align-items: center; margin-bottom: 20px;">
                <div class="back-button clickable" onclick="closePresetPromptDetail()" 
                     style="margin-right: 15px;">
                    <i class="fa-solid fa-angle-left"></i>
                </div>
                <h4 style="margin: 0; flex: 1; text-align: center; color: var(--text-color-primary);">
                    ${prompt.name || '未命名内容'}
                </h4>
                <div style="width: 40px;"></div>
            </div>
            
            <div style="flex: 1; overflow-y: auto; margin-bottom: 20px;">
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; 
                                  font-size: 14px; color: var(--text-color-primary);">
                        功能名称
                    </label>
                    <input type="text" id="edit-prompt-name" 
                           style="width: 100%; padding: 10px 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  font-size: 14px; box-sizing: border-box;"
                           value="${prompt.name || ''}">
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; 
                                  font-size: 14px; color: var(--text-color-primary);">
                        内容
                    </label>
                    <textarea id="edit-prompt-content" 
                              style="width: 100%; padding: 10px 12px; border-radius: 8px; 
                                     border: 1px solid var(--input-border); 
                                     background: var(--input-bg); color: var(--text-color-primary);
                                     font-size: 13px; box-sizing: border-box;
                                     min-height: 200px; max-height: 300px; resize: vertical;"
                              placeholder="输入预设内容...">${prompt.content || ''}</textarea>
                </div>
                
            </div>
            
            <div style="display: flex; gap: 10px;">
                <button onclick="closePresetPromptDetail()" 
                        style="flex: 1; padding: 12px; border-radius: 8px; 
                               background: var(--input-bg); color: var(--text-color-primary);
                               border: 1px solid var(--input-border); cursor: pointer;
                               font-size: 15px;">
                    取消
                </button>
                <button onclick="savePresetPromptEdit('${presetId}', ${promptIdx})" 
                        style="flex: 1; padding: 12px; border-radius: 8px; 
                               background: var(--accent-color); color: white;
                               border: none; cursor: pointer; font-size: 15px;">
                    保存
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(detailModal);
    
    // 点击外部关闭
    detailModal.addEventListener('click', function(e) {
        if (e.target === detailModal) {
            closePresetPromptDetail();
        }
    });
}

// 保存预设内容编辑
function savePresetPromptEdit(presetId, promptIdx) {
    const preset = APP_DATA.deepPresets.find(p => String(p.id) === String(presetId));
    if (!preset || !preset.prompts[promptIdx]) return;
    
    const nameInput = document.getElementById('edit-prompt-name');
    const contentInput = document.getElementById('edit-prompt-content');
    
    const newName = nameInput.value.trim();
    const newContent = contentInput.value;
    
    if (!newName) {
        alert('功能名称不能为空');
        return;
    }
    
    // 更新数据
    preset.prompts[promptIdx].name = newName;
    preset.prompts[promptIdx].content = newContent;
    
    saveData();
    
    // 关闭详情弹窗
    closePresetPromptDetail();
    
    // 刷新预设详情列表
    openDeepPresetDetail(presetId);
    
    alert('✅ 修改已保存！');
}

// 关闭预设内容详情弹窗
function closePresetPromptDetail() {
    const modal = document.getElementById('preset-prompt-detail-modal');
    if (modal && modal.parentNode) {
        modal.remove();
    }
}

// 启用某个预设
function activateDeepPreset() {
    if (editingPresetId) {
        APP_DATA.currentDeepPresetId = String(editingPresetId);
        APP_DATA.deepPresetEnabled = true; // 自动开启总开关
        saveData();
        
        // 更新开关UI
        const btn = document.getElementById('deep-preset-switch').querySelector('.theme-switch-thumb');
        if(btn) btn.style.left = '20px';
        
        updateDeepPresetUI();
        hideModal('deep-preset-detail-modal');
    }
}

function togglePresetPrompt(presetId, idx, checked) {
    const preset = APP_DATA.deepPresets.find(p => p.id === presetId);
    if (preset && preset.prompts[idx]) {
        preset.prompts[idx].enabled = checked;
        saveData();
    }
}

function deleteCurrentDeepPreset() {
    if (!editingPresetId) return;
    if (!confirm("确定要删除这个预设吗？")) return;
    
    APP_DATA.deepPresets = APP_DATA.deepPresets.filter(p => p.id !== editingPresetId);
    if (APP_DATA.currentDeepPresetId === editingPresetId) APP_DATA.currentDeepPresetId = null;
    
    saveData();
    hideModal('deep-preset-detail-modal');
    updateDeepPresetUI();
}

// --- 正则部分 ---

// 打开正则管理（一级：文件列表）
function openRegexManager() {
    ensureTavernData();
    updateRegexUI();
    showModal('regex-modal');
}

/* ================= 正则功能完整修复补丁 ================= */

// 1. 切换开关函数 (原版缺失这个，导致点了没反应)
function toggleRegexCollection(id, status) {
    if (!APP_DATA.regexCollections) return;
    
    const item = APP_DATA.regexCollections.find(c => c.id == id);
    if (item) {
        item.enabled = status; // 修改开启状态
        if (typeof saveData === 'function') saveData(); // 保存
        updateRegexUI(); // 立即刷新界面颜色
    }
}

// 2. 界面文字显示函数 (修复一直显示"未选择"的问题)
function updateRegexDisplay() {
    const display = document.getElementById('regex-display');
    if (!display) return;
    
    if (!APP_DATA.regexCollections || !Array.isArray(APP_DATA.regexCollections)) {
        display.value = '未选择正则';
        return;
    }

    // 统计所有被启用的文件 (enabled不为false即视为启用)
    const enabledItems = APP_DATA.regexCollections.filter(c => c.enabled !== false);
    
    if (enabledItems.length === 0) {
        display.value = '未选择正则'; 
    } else if (enabledItems.length === 1) {
        display.value = enabledItems[0].name;
    } else {
        display.value = `${enabledItems[0].name} 等 ${enabledItems.length} 个`;
    }
}

// 3. 列表生成函数 (修复颜色不变化的问题)
function updateRegexUI() {
    updateRegexDisplay(); // 先更新顶部的文字

    const list = document.getElementById('regex-file-list');
    if (!list) return;
    
    list.innerHTML = '';
    
    if (!APP_DATA.regexCollections || !APP_DATA.regexCollections.length) {
        list.innerHTML = '<div style="text-align:center;padding:20px;color:#888">暂无文件</div>';
        return;
    }
    
    APP_DATA.regexCollections.forEach(c => {
        const div = document.createElement('div');
        div.className = 'tavern-item';
        
        // 判断启用状态：默认为开启(true)，除非明确被设为false
        const isEnabled = (c.enabled !== false); 
        
        // 【变色逻辑】开启变绿，关闭变黑
        const nameColor = isEnabled ? 'var(--accent-color)' : 'var(--text-color-primary)';
        
        // 左侧：文件名和脚本数量（点击切换选中状态）
        const infoDiv = document.createElement('div');
        infoDiv.style.flex = '1';
        infoDiv.style.cursor = 'pointer';
        infoDiv.innerHTML = `
            <div style="font-weight:bold; color: ${nameColor}; transition: color 0.3s;">
                ${c.name}
            </div>
            <div style="font-size:11px; color: var(--text-color-secondary, #888);">
                ${c.scripts ? c.scripts.length : 0} 条脚本
            </div>
        `;
        
        // ★★★ 点击名字：切换选中状态（支持多选）★★★
        infoDiv.onclick = function(e) {
            e.stopPropagation();
            
            // 判断当前是否选中
            const isCurrentlySelected = (c.enabled !== false);
            
            // 切换状态（多选模式，不影响其他项）
            if (isCurrentlySelected) {
                c.enabled = false; // 取消选中
            } else {
                c.enabled = true; // 选中
            }
            
            saveData();
            updateRegexUI(); // 刷新列表显示
        };
        div.appendChild(infoDiv);
        
        // 右侧：控制区（编辑按钮 + 删除按钮）
        const controlsDiv = document.createElement('div');
        controlsDiv.style.display = 'flex';
        controlsDiv.style.alignItems = 'center';
        controlsDiv.style.gap = '6px';
        controlsDiv.style.justifyContent = 'flex-end';
        
        // 编辑按钮 (绿色笔)
        const editBtn = document.createElement('div');
        editBtn.innerHTML = '<i class="fas fa-edit"></i>';
        editBtn.style.color = 'var(--accent-color)';
        editBtn.style.cursor = 'pointer';
        editBtn.style.fontSize = '14px';
        editBtn.style.padding = '8px';
        
        editBtn.onclick = function(e) {
            e.stopPropagation();
            if(typeof openRegexDetail === 'function') openRegexDetail(c.id);
        };
        controlsDiv.appendChild(editBtn);
        
        // 删除按钮
        const deleteBtn = document.createElement('div');
        deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
        deleteBtn.style.color = 'var(--danger-color)';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.fontSize = '14px';
        deleteBtn.style.padding = '8px';
        deleteBtn.title = '删除正则文件';
        deleteBtn.onclick = function(e) {
            e.stopPropagation();
            deleteRegexCollection(c.id);
        };
        controlsDiv.appendChild(deleteBtn);
        
        div.appendChild(controlsDiv);
        list.appendChild(div);
    });
}


function toggleRegexFile(fileId, checked) {
    const file = APP_DATA.regexCollections.find(f => f.id === fileId);
    if (file) {
        file.enabled = checked;
        saveData();
        // 更新主界面统计
        updateRegexUI();
    }
}

// 打开正则详情（二级：脚本列表）
let editingRegexFileId = null;
function openRegexDetail(fileId) {
    editingRegexFileId = fileId;
    const file = APP_DATA.regexCollections.find(f => f.id === fileId);
    if (!file) return;

    document.getElementById('regex-detail-title').textContent = file.name;
    const container = document.getElementById('regex-detail-list');
    container.innerHTML = '';

    if (file.scripts) {
        file.scripts.forEach((script, idx) => {
            const div = document.createElement('div');
            div.className = 'tavern-item';
            div.style.cssText = 'display:flex; align-items:center; justify-content:space-between; padding:10px 12px;';
            
            // 左侧：功能名称（不显示内容预览）
            const nameDiv = document.createElement('div');
            nameDiv.style.cssText = 'flex:1; overflow:hidden;';
            nameDiv.innerHTML = `<div style="font-weight:bold; font-size:14px; color:var(--text-color-primary);">${script.name}</div>`;
            
            // 右侧：详情按钮 + 开关
            const controlsDiv = document.createElement('div');
            controlsDiv.style.cssText = 'display:flex; align-items:center; gap:8px; flex-shrink:0;';
            
            // 详情按钮
            const detailBtn = document.createElement('div');
            detailBtn.innerHTML = '<i class="fa-solid fa-circle-info"></i>';
            detailBtn.style.cssText = `
                padding: 0;
                width: 30px;
                height: 30px;
                background: transparent;
                color: var(--accent-color);
                border: none;
                cursor: pointer;
                font-size: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                transform: translateY(1px);  // 正数往下，负数往上

            `;
            detailBtn.title = '查看/编辑详情';
            detailBtn.onclick = (e) => {
                e.stopPropagation();
                showRegexScriptDetail(fileId, idx);
            };
            
            // 开关
            const switchLabel = document.createElement('label');
            switchLabel.className = 'switch';
            switchLabel.style.marginTop = '1px';  // 或 marginBottom

            switchLabel.innerHTML = `
                <input type="checkbox" ${!script.disabled ? 'checked' : ''} 
                       onchange="toggleRegexScript('${file.id}', ${idx}, this.checked)">
                <span class="slider"></span>
            `;
            
            controlsDiv.appendChild(detailBtn);
            controlsDiv.appendChild(switchLabel);
            
            div.appendChild(nameDiv);
            div.appendChild(controlsDiv);
            container.appendChild(div);
        });
    }
    showModal('regex-detail-modal');
}

function toggleRegexScript(fileId, idx, checked) {
    const file = APP_DATA.regexCollections.find(f => f.id === fileId);
    if (file && file.scripts[idx]) {
        file.scripts[idx].disabled = !checked; // 注意这里是 disabled
        saveData();
    }
}

// 新增：显示正则脚本详情编辑弹窗
function showRegexScriptDetail(fileId, scriptIdx) {
    const file = APP_DATA.regexCollections.find(f => f.id === fileId);
    if (!file || !file.scripts[scriptIdx]) return;
    
    const script = file.scripts[scriptIdx];
    
    // 创建详情编辑弹窗
    const detailModal = document.createElement('div');
    detailModal.id = 'regex-script-detail-modal';
    detailModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.6); z-index: 10001;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    detailModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                    width: 90%; max-width: 350px; max-height: 75vh;
                    display: flex; flex-direction: column; padding: 20px;">
            
            <!-- 标题栏 -->
            <div style="display: flex; align-items: center; margin-bottom: 20px;">
                <div class="back-button clickable" onclick="closeRegexScriptDetail()" 
                     style="margin-right: 15px;">
                    <i class="fa-solid fa-angle-left"></i>
                </div>
                <h4 style="margin: 0; flex: 1; text-align: center; color: var(--text-color-primary);">
                    ${script.name}
                </h4>
                <div style="width: 40px;"></div>
            </div>
            
            <!-- 内容区域（可滚动） -->
            <div style="flex: 1; overflow-y: auto; margin-bottom: 20px;">
                
                <!-- 功能名称 -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; 
                                  font-size: 14px; color: var(--text-color-primary);">
                        功能名称
                    </label>
                    <input type="text" id="edit-script-name" 
                           style="width: 100%; padding: 10px 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  font-size: 14px; box-sizing: border-box;"
                           value="${script.name || ''}">
                </div>
                
                <!-- 正则表达式 -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; 
                                  font-size: 14px; color: var(--text-color-primary);">
                        正则表达式 (Regex)
                    </label>
                    <textarea id="edit-script-regex" 
                              style="width: 100%; padding: 10px 12px; border-radius: 8px; 
                                     border: 1px solid var(--input-border); 
                                     background: var(--input-bg); color: var(--text-color-primary);
                                     font-size: 13px; font-family: monospace; box-sizing: border-box;
                                     min-height: 80px; max-height: 150px; resize: vertical;"
                              placeholder="例如: /pattern/g">${script.regex || ''}</textarea>
                </div>
                
                <!-- 替换内容 -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; 
                                  font-size: 14px; color: var(--text-color-primary);">
                        替换内容 (Replace)
                    </label>
                    <textarea id="edit-script-replace" 
                              style="width: 100%; padding: 10px 12px; border-radius: 8px; 
                                     border: 1px solid var(--input-border); 
                                     background: var(--input-bg); color: var(--text-color-primary);
                                     font-size: 13px; box-sizing: border-box;
                                     min-height: 80px; max-height: 150px; resize: vertical;"
                              placeholder="替换为的内容...">${script.replace || ''}</textarea>
                </div>
                
            </div>
            
            <!-- 底部按钮 -->
            <div style="display: flex; gap: 10px;">
                <button onclick="closeRegexScriptDetail()" 
                        style="flex: 1; padding: 12px; border-radius: 8px; 
                               background: var(--input-bg); color: var(--text-color-primary);
                               border: 1px solid var(--input-border); cursor: pointer;
                               font-size: 15px;">
                    取消
                </button>
                <button onclick="saveRegexScriptEdit('${fileId}', ${scriptIdx})" 
                        style="flex: 1; padding: 12px; border-radius: 8px; 
                               background: var(--accent-color); color: white;
                               border: none; cursor: pointer; font-size: 15px;">
                    保存
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(detailModal);
    
    // 点击外部关闭
    detailModal.addEventListener('click', function(e) {
        if (e.target === detailModal) {
            closeRegexScriptDetail();
        }
    });
}

// 保存正则脚本编辑
function saveRegexScriptEdit(fileId, scriptIdx) {
    const file = APP_DATA.regexCollections.find(f => f.id === fileId);
    if (!file || !file.scripts[scriptIdx]) return;
    
    const nameInput = document.getElementById('edit-script-name');
    const regexInput = document.getElementById('edit-script-regex');
    const replaceInput = document.getElementById('edit-script-replace');
    
    const newName = nameInput.value.trim();
    const newRegex = regexInput.value.trim();
    const newReplace = replaceInput.value;
    
    if (!newName) {
        alert('功能名称不能为空');
        return;
    }
    
    if (!newRegex) {
        alert('正则表达式不能为空');
        return;
    }
    
    // 更新数据
    file.scripts[scriptIdx].name = newName;
    file.scripts[scriptIdx].regex = newRegex;
    file.scripts[scriptIdx].replace = newReplace;
    
    saveData();
    
    // 关闭详情弹窗
    closeRegexScriptDetail();
    
    // 刷新正则详情列表
    openRegexDetail(fileId);
    
    alert('✅ 修改已保存！');
}

// 关闭正则脚本详情弹窗
function closeRegexScriptDetail() {
    const modal = document.getElementById('regex-script-detail-modal');
    if (modal && modal.parentNode) {
        modal.remove();
    }
}

function deleteCurrentRegexFile() {
    if (!editingRegexFileId) return;
    if (!confirm("确定要删除这个正则文件吗？")) return;
    
    APP_DATA.regexCollections = APP_DATA.regexCollections.filter(f => f.id !== editingRegexFileId);
    
    saveData();
    hideModal('regex-detail-modal');
    updateRegexUI();
}

// 新增：从列表直接删除正则文件
function deleteRegexCollection(fileId) {
    const file = APP_DATA.regexCollections.find(f => f.id === fileId);
    if (!file) return;
    
    if (!confirm(`确定要删除正则文件「${file.name}」吗？\n\n此操作无法撤销！`)) {
        return;
    }
    
    // 从数组中删除
    APP_DATA.regexCollections = APP_DATA.regexCollections.filter(f => f.id !== fileId);
    
    saveData();
    updateRegexUI(); // 刷新列表
    
    alert('正则文件已删除！');
}

// 简单的开关切换UI辅助函数
function toggleDeepPreset() {
    APP_DATA.deepPresetEnabled = !APP_DATA.deepPresetEnabled;
    saveData();
    const btn = document.getElementById('deep-preset-switch').querySelector('.theme-switch-thumb');
    if(APP_DATA.deepPresetEnabled) btn.style.left = '20px'; else btn.style.left = '1px';
}

function toggleRegex() {
    APP_DATA.regexEnabled = !APP_DATA.regexEnabled;
    saveData();
    const btn = document.getElementById('regex-switch').querySelector('.theme-switch-thumb');
    if(APP_DATA.regexEnabled) btn.style.left = '20px'; else btn.style.left = '1px';
}

function loadDeepPresetAndRegexSettings() {
    // 确保数据存在
    ensureTavernData();
    
    const pBtn = document.getElementById('deep-preset-switch')?.querySelector('.theme-switch-thumb');
    const rBtn = document.getElementById('regex-switch')?.querySelector('.theme-switch-thumb');
    if(pBtn) pBtn.style.left = APP_DATA.deepPresetEnabled ? '20px' : '1px';
    if(rBtn) rBtn.style.left = APP_DATA.regexEnabled ? '20px' : '1px';
    
    // 初始化UI显示
    const presetDisplay = document.getElementById('deep-preset-display');
    const activePreset = APP_DATA.deepPresets.find(p => p.id === APP_DATA.currentDeepPresetId);
    if (presetDisplay) presetDisplay.value = activePreset ? activePreset.name : "未选择预设";
    
    updateRegexUI(); 
}

        // ----------------------- 页面切换 -----------------------
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.style.display = 'none';
            });
            document.getElementById(pageId).style.display = 'flex';
            
            if (pageId === 'settings-page') {
                loadSettings();
                updateCacheSize();
            } else if (pageId === 'options-page') {
                document.getElementById('options-role-name').textContent = currentContact ? currentContact.name + ' 选项' : '选项';
          } else if (pageId === 'chat-window') {
    // 智能更新：根据标记或数据变化决定是否重新渲染
    if (currentContact) {
        // 检查是否需要刷新（比如从记忆编辑页面返回）
        if (window.needRefreshChat) {
            renderMessages(currentContact.history);
            window.needRefreshChat = false; // 重置标记
        } else {
            // 检查消息数量是否一致
            const container = document.getElementById('chat-messages');
            if (container) {
                const displayedCount = container.querySelectorAll('.chat-message').length;
                const actualCount = currentContact.history.length;
                
                // 如果数量不一致（比如清理了记忆），重新渲染
                if (displayedCount !== actualCount) {
                    renderMessages(currentContact.history);
                }
            }
        }
        
        scrollToBottomInstant();
    }
} else if (pageId === 'contacts-page') {
                // 退出聊天窗口时退出管理模式
                isManageMode = false;
                batchMode = false;
                selectedContacts.clear();
                document.getElementById('batch-toolbar').classList.remove('show');
                renderContacts();
            }
        }

        function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    
    modal.style.display = 'flex';
    
    // 强制重绘以确保动画生效
    modal.offsetWidth;
    
    modal.classList.add('active');
}

       function hideModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    
    // 移除active类开始淡出动画
    modal.classList.remove('active');
    
    // 等待动画完成后隐藏
    setTimeout(() => {
        modal.style.display = 'none';
    }, 300);
}

        function toggleTheme(mode) {
            if (mode === 'dark') {
                document.documentElement.classList.add('dark-mode');
            } else {
                document.documentElement.classList.remove('dark-mode');
            }
            APP_DATA.currentTheme = mode;
            saveData();
        }

        // ----------------------- 聊天室 (联系人) 管理 -----------------------
        
        // 切换管理模式
        function toggleManageMode() {
            isManageMode = !isManageMode;
            batchMode = isManageMode;
            
            if (!batchMode) {
                selectedContacts.clear();
                document.getElementById('batch-toolbar').classList.remove('show');
            } else {
                document.getElementById('batch-toolbar').classList.add('show');
                updateSelectedCount();
            }
            
            renderContacts();
        }
        
        function cancelBatchDelete() {
            batchMode = false;
            isManageMode = false;
            selectedContacts.clear();
            document.getElementById('batch-toolbar').classList.remove('show');
            renderContacts();
        }
        
        function toggleSelectAll() {
            if (selectedContacts.size === APP_DATA.contacts.length) {
                // 如果已经全选，则取消全选
                selectedContacts.clear();
            } else {
                // 否则全选
                APP_DATA.contacts.forEach(contact => {
                    selectedContacts.add(contact.id);
                });
            }
            renderContacts();
            updateSelectedCount();
        }
        
        function updateSelectedCount() {
            document.getElementById('selected-count').textContent = `已选择 ${selectedContacts.size} 项`;
        }
        
        function toggleContactSelection(id) {
            if (selectedContacts.has(id)) {
                selectedContacts.delete(id);
            } else {
                selectedContacts.add(id);
            }
            renderContacts();
            updateSelectedCount();
        }
        
        function deleteSelectedContacts() {
            if (selectedContacts.size === 0) {
                alert('请先选择要删除的聊天室');
                return;
            }
            
            if (confirm(`确定要删除选中的 ${selectedContacts.size} 个聊天室吗？`)) {
                APP_DATA.contacts = APP_DATA.contacts.filter(c => !selectedContacts.has(c.id));
                saveData();
                selectedContacts.clear();
                batchMode = false;
                isManageMode = false;
                document.getElementById('batch-toolbar').classList.remove('show');
                renderContacts();
            }
        }

        function renderContacts() {
            const list = document.getElementById('contacts-list');
            list.innerHTML = '';
            
            if (APP_DATA.contacts.length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-color-secondary);">暂无聊天室</div>';
                return;
            }
                // 按最后聊天时间排序（最新的在最上面）
                const sortedContacts = [...APP_DATA.contacts].sort((a, b) => {
                    const timeA = a.lastChatTime || 0;
                    const timeB = b.lastChatTime || 0;
                    return timeB - timeA;
                });

            sortedContacts.forEach(contact => {
                const item = document.createElement('div');
                item.className = 'contact-item clickable'; 
                
                // 批量选择框或删除按钮
                if (batchMode) {
                    const checkboxWrapper = document.createElement('div');
                    checkboxWrapper.className = `contact-checkbox ${batchMode ? 'show' : ''}`;
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = selectedContacts.has(contact.id);
                    checkbox.onclick = (e) => {
                        e.stopPropagation();
                        toggleContactSelection(contact.id);
                    };
                    checkboxWrapper.appendChild(checkbox);
                    item.appendChild(checkboxWrapper);
                } 
                    else if (isManageMode) {
    const actionWrapper = document.createElement('div');
    actionWrapper.className = `delete-btn-wrapper ${isManageMode ? 'show' : ''}`;
    actionWrapper.style.display = 'flex';
    actionWrapper.style.gap = '10px';
    actionWrapper.style.alignItems = 'center';
    
    // 修改按钮
    const editBtn = document.createElement('div');
    editBtn.className = 'edit-icon';
    editBtn.innerHTML = '✎';
    editBtn.style.cssText = 'width:22px;height:22px;border-radius:50%;background-color:#88ABDA;color:white;display:flex;justify-content:center;align-items:center;font-size:14px;cursor:pointer;';
    editBtn.onclick = (e) => {
        e.stopPropagation();
        const newName = prompt('修改角色名：', contact.name);
        if (newName && newName.trim()) {
            contact.name = newName.trim();
            saveData();
            renderContacts();
            alert('修改成功！');
        }
    };
    
    // 删除按钮
    const deleteBtn = document.createElement('div');
    deleteBtn.className = 'delete-icon';
    deleteBtn.textContent = '-';
    deleteBtn.onclick = (e) => {
        e.stopPropagation();
        deleteContact(contact.id);
    };
    
    actionWrapper.appendChild(editBtn);
    actionWrapper.appendChild(deleteBtn);
    item.appendChild(actionWrapper);
}
                
                // 头像
                const avatar = document.createElement('div');
                avatar.className = 'contact-avatar';
                // 使用 AI 设置的头像或默认首字
                if(APP_DATA.settings.aiAvatarBase64 && APP_DATA.settings.aiAvatarBase64 !== 'AI' && APP_DATA.settings.aiAvatarBase64.startsWith('data:image')) {
                     const img = document.createElement('img');
                     img.src = APP_DATA.settings.aiAvatarBase64;
                     avatar.appendChild(img);
                } else {
                     avatar.textContent = contact.name.charAt(0);
                }
                item.appendChild(avatar);

                                                                // 名字
                let nameElement;
                
                if (isManageMode) {
                    // 管理模式：显示输入框
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = contact.name;
                    nameInput.style.cssText = `
                        border: 1px solid var(--accent-color);
                        border-radius: 6px;
                        padding: 4px 8px;
                        background: var(--bg-color-secondary);
                        color: var(--text-color-primary);
                        font-size: inherit;
                        width: 120px;
                        user-select: text !important;
                        -webkit-user-select: text !important;
                        caret-color: #07C160;
                    `;
                    nameInput.onclick = (e) => {
                        e.stopPropagation();
                        nameInput.select();
                    };
                    nameInput.onblur = () => {
                        const newName = nameInput.value.trim();
                        if (newName && newName !== contact.name) {
                            contact.name = newName;
                            saveData();
                            renderContacts();
                        }
                    };
                    nameInput.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            nameInput.blur();
                        }
                        e.stopPropagation();
                    };
                    nameElement = nameInput;
                } else {
                    // 正常模式：显示普通文本
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = contact.name;
                    nameElement = nameSpan;
                }
                     // 添加到item前先移除点击动画类
                item.classList.remove('clickable');
                item.appendChild(nameElement);
                
                              // 点击事件
item.onclick = () => {
    if (batchMode) {
        toggleContactSelection(contact.id);
    } else {
        openChatWindow(contact.id);
    }
};


                list.appendChild(item);
            });
        }
        
        function deleteContact(id) {
            if(confirm('确定要删除这个聊天室吗？')) {
                APP_DATA.contacts = APP_DATA.contacts.filter(c => c.id !== id);
                saveData();
                renderContacts();
            }
        }
        
        function prepareRoleModal(contact = null) {
            document.getElementById('modal-role-id').value = contact ? contact.id : '';
            document.getElementById('modal-role-name').value = contact ? contact.name : '';
            document.getElementById('modal-role-prompt').value = contact ? contact.prompt : '';
            document.getElementById('modal-role-title').textContent = contact ? '编辑角色' : '新建角色';
            
            showModal('new-contact-modal');
        }

        function saveRoleFromModal() {
            const id = document.getElementById('modal-role-id').value;
            const name = document.getElementById('modal-role-name').value.trim();
            const prompt = document.getElementById('modal-role-prompt').value.trim();
            
            if (!name || !prompt) {
                alert('角色名和 Prompt 不能为空！');
                return;
            }
            
            if (id) {
                const contact = APP_DATA.contacts.find(c => c.id == id);
                if (contact) {
                    contact.name = name;
                    contact.prompt = prompt;
                }
            } else {
                const newId = APP_DATA.contacts.length > 0 ? Math.max(...APP_DATA.contacts.map(c => c.id)) + 1 : 1;
                APP_DATA.contacts.push({
                    id: newId,
                    name: name,
                    prompt: prompt,
                    history: [],
                    longMemory: '无'
                });
            }
            saveData();
            renderContacts();
            hideModal('new-contact-modal');
        }
        
        // ----------------------- 聊天逻辑 -----------------------
      function openChatWindow(contactId) {
    // 重置分页
      currentStartIndex = 0;
    const contactsPage = document.getElementById('contacts-page');
    const chatWindow = document.getElementById('chat-window');
    
    // 设置聊天信息
    APP_DATA.currentChatId = contactId;
    currentContact = APP_DATA.contacts.find(c => c.id === contactId);
    document.getElementById('chat-role-name').textContent = currentContact.name;
    
    // 先隐藏聊天室
    contactsPage.style.display = 'none';
    
    // 立即显示聊天窗口
    chatWindow.style.display = 'flex';
    chatWindow.classList.add('slide-in-right');
    
    // 【关键修改】在动画开始前就渲染消息
   renderMessages(currentContact.history.slice(-20));
  
   scrollToBottomInstant();
}
        
       function exitChatWindow() {
    const contactsPage = document.getElementById('contacts-page');
    const chatWindow = document.getElementById('chat-window');
    
 
    currentAIRequest = null;
    isTyping = false;
    
    // 3. 动画效果
    chatWindow.classList.add('slide-out-left');
    contactsPage.style.display = 'flex';
    
    setTimeout(() => {
        chatWindow.style.display = 'none';
        chatWindow.classList.remove('slide-out-left');
        
        // 4. 退出管理模式
        isManageMode = false;
        batchMode = false;
        selectedContacts.clear();
        document.getElementById('batch-toolbar').classList.remove('show');
        renderContacts();
    }, 300);
}

       /* --- 4. 修复：加载历史时彻底禁止动画，只在最后瞬间置底 --- */
function renderMessages(history, startFromEnd = true) {
    const container = document.getElementById('chat-messages');
    if (startFromEnd) {
        currentStartIndex = Math.max(0, history.length - PAGE_SIZE);
    }
    
    const messagesToShow = history.slice(currentStartIndex);
    const loadingElement = document.getElementById('loading-more');
    container.innerHTML = '';
    if (loadingElement) {
        container.appendChild(loadingElement);
    }
    
    let segmentGroup = [];
    messagesToShow.forEach((msg, index) => {
        if (msg.role === 'ai' && msg.isSegment && msg.segmentIndex !== undefined) {
            if (msg.segmentIndex === 0) {
                if (segmentGroup.length > 0) {
                    displaySegmentGroup(segmentGroup, container);
                }
                segmentGroup = [msg];
            } else {
                segmentGroup.push(msg);
            }
        } else {
            if (segmentGroup.length > 0) {
                displaySegmentGroup(segmentGroup, container);
                segmentGroup = [];
            }
            // 【关键】：这里传入 true，加载历史时不要做动画！
            appendMessageToDOM(msg.content, msg.role, false, true);
        }
    });
    
    if (segmentGroup.length > 0) {
        displaySegmentGroup(segmentGroup, container);
    }
    
    // 最后一步：0秒瞬间置底
    scrollToBottomInstant();
}

function loadMoreMessages() {
    if (!currentContact || isLoadingMore) return;
    
    // 已经是最前面了
    if (currentStartIndex <= 0) return;
    
    isLoadingMore = true;
    
    // 显示加载提示
    const loadingElement = document.getElementById('loading-more');
    if (loadingElement) {
        loadingElement.style.display = 'block';
    }
    
    // 往前取10条
    currentStartIndex = Math.max(0, currentStartIndex - PAGE_SIZE);
    
    // 重新渲染
    setTimeout(() => {
        renderMessages(currentContact.history, false);
        isLoadingMore = false;
        if (loadingElement) {
            loadingElement.style.display = 'none';
        }
    }, 300);
}


// 全局变量，防止快速连续调用时动画冲突
window.chatScrollAnimationId = null;

/* --- 最终优化版：Cubic Ease-Out 丝滑阻尼滚动 --- */
function scrollToBottom() {
    const container = document.getElementById('chat-messages');
    if (!container) return;

    // 1. 获取起点和终点
    const start = container.scrollTop;
    // 目标位置：总高度 - 视口高度 = 最底部
    const target = container.scrollHeight - container.clientHeight;
    const distance = target - start;
    
    // 【调整时长】350ms 能让"减速"过程更明显，更有质感
    const duration = 350; 

    // 优化：如果距离很小（比如已经在底了），直接到位，不浪费性能
    if (Math.abs(distance) < 5) {
        container.scrollTop = target;
        return;
    }

    // 2. 如果上一次动画还没跑完，立刻取消，防止画面抖动
    if (window.chatScrollAnimationId) {
        cancelAnimationFrame(window.chatScrollAnimationId);
    }

    let startTime = null;

    // 3. 定义丝滑动画过程
    function animation(currentTime) {
        if (!startTime) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        let progress = timeElapsed / duration;

        if (progress > 1) progress = 1;

        // 【核心魔法】Cubic Ease-Out 曲线
        // 这种算法会让滚动“一开始很快，快结束时慢慢停下”
        // 相比匀速 (progress)，这个更有“手机原生感”
        const ease = 1 - Math.pow(1 - progress, 3);

        // 应用位置
        container.scrollTop = start + (distance * ease);

        if (timeElapsed < duration) {
            // 继续下一帧
            window.chatScrollAnimationId = requestAnimationFrame(animation);
        } else {
            // 动画结束，确保严丝合缝
            container.scrollTop = target;
            window.chatScrollAnimationId = null;
        }
    }

    // 启动动画
    window.chatScrollAnimationId = requestAnimationFrame(animation);
}

/* --- 1. 修复：0秒瞬间置底（进场专用，加了双重保险） --- */
function scrollToBottomInstant() {
    const container = document.getElementById('chat-messages');
    if (!container) return;
    
    // 第一下：立刻执行
    container.scrollTop = container.scrollHeight;

    // 第二下：防止图片加载撑开高度，10毫秒后再按一次
    setTimeout(() => {
        container.scrollTop = container.scrollHeight;
    }, 10);
}
function showAIContextMenu(bubbleElement) {
    // 检查是否是正在输入的气泡
    const isTypingBubble = bubbleElement.classList.contains('typing-indicator');
    if (isTypingBubble) {
        // 【修改】这里只是显示菜单，不立即执行
        // 菜单的点击事件会处理重新生成
    }

    const menu = document.getElementById('ai-context-menu');
    if (!menu) return;
    
    // 关闭其他可能打开的菜单
    closeAIMenu();
    
        // 记录点击的气泡元素
    menu.dataset.bubbleElement = 'clicked';
    
    // 保存到全局变量，这样regenerateAIReply函数能知道
    window.lastClickedBubble = bubbleElement;
    
    // 获取气泡位置
    const rect = bubbleElement.getBoundingClientRect();
    
   // 计算菜单位置（在气泡右上角，与气泡垂直居中）
    // 判断是手机还是电脑
let iconHeight = 40; // 电脑默认
if (window.innerWidth <= 768) {
    iconHeight = 60; // 手机更大
}
let menuTop = rect.top + (rect.height / 2) - (iconHeight / 2);
    let menuLeft = rect.right + 0;  // 在气泡右侧像素
    
    // 获取窗口尺寸和菜单尺寸
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const menuWidth = 40;
    const menuHeight = 40;
    
    // 调整位置，确保不超出窗口
if (menuLeft + menuWidth > windowWidth - 10) {
    // 如果右侧超出，贴在屏幕右侧边缘
    menuLeft = windowWidth - menuWidth - 10;
}
if (menuLeft < 10) {
    menuLeft = 10;
}
    if (menuTop + menuHeight > windowHeight - 10) {
        // 如果底部超出，显示在气泡上方
        menuTop = rect.top - menuHeight - 8;
    }
    
    // 显示菜单
    menu.style.top = menuTop + 'px';
    menu.style.left = menuLeft + 'px';
    menu.style.display = 'block';
    
    // 点击其他地方关闭菜单
    setTimeout(() => {
        document.addEventListener('click', function closeMenuHandler(e) {
            if (!menu.contains(e.target)) {
                closeAIMenu();
                document.removeEventListener('click', closeMenuHandler);
            }
        });
    }, 10);
}
// 关闭菜单（点击外部）
function closeAIMenuOnClickOutside(event) {
    const menu = document.getElementById('ai-context-menu');
    if (!menu) return;
    
    // 如果点击的不是菜单本身
    if (!menu.contains(event.target)) {
        menu.style.display = 'none';
        document.removeEventListener('click', closeAIMenuOnClickOutside);
    }
}

// 关闭菜单
function closeAIMenu() {
    const menu = document.getElementById('ai-context-menu');
    if (menu) {
        menu.style.display = 'none';
        document.removeEventListener('click', closeAIMenuOnClickOutside);
    }
}

/* --- 3. 修复：调用时传入 true，禁止滚动 --- */
function displaySegmentGroup(segmentGroup, container) {
    if (segmentGroup.length === 0) return;
    // 按segmentIndex排序
    segmentGroup.sort((a, b) => a.segmentIndex - b.segmentIndex);
    // 显示每个分割消息
    segmentGroup.forEach((msg, index) => {
        // 【关键】：这里传入 true，表示不要滚动
        const {msgDiv, bubble} = appendMessageToDOM(msg.content, msg.role, false, true);
        
        if (index > 0) {
            bubble.style.marginTop = '5px';
        }
    });
}        
       /* --- 2. 修复：添加 skipScroll 参数 --- */
function appendMessageToDOM(text, role, isTypingEffect = false, skipScroll = false) {
    const container = document.getElementById('chat-messages');
    const msgDiv = document.createElement('div');
    msgDiv.className = `chat-message ${role}`;
    
    if (role === 'ai') {
        const avatarDiv = document.createElement('div');
        avatarDiv.className = 'avatar';
        
        // 头像逻辑
        if (APP_DATA.settings.aiAvatarBase64 && APP_DATA.settings.aiAvatarBase64.startsWith('data:image')) {
            const img = document.createElement('img');
            img.src = APP_DATA.settings.aiAvatarBase64;
            img.style.width = '100%'; 
            img.style.height = '100%'; 
            img.style.objectFit = 'cover';
            avatarDiv.appendChild(img);
        } else {
            avatarDiv.textContent = currentContact ? currentContact.name.charAt(0) : 'AI';
            avatarDiv.style.backgroundColor = 'var(--accent-color)';
            avatarDiv.style.color = 'white';
            avatarDiv.style.display = 'flex';
            avatarDiv.style.justifyContent = 'center';
            avatarDiv.style.alignItems = 'center';
        }
        msgDiv.appendChild(avatarDiv);
    }

    const bubble = document.createElement('div');
    bubble.className = 'bubble';
    if (isTypingEffect && role === 'ai') {
        bubble.classList.add('typing-indicator');
        bubble.innerHTML = `
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
        `;
    } else {
        bubble.textContent = text;
    }
    
    // 点击事件
    if (role === 'ai') {
        bubble.style.cursor = 'pointer';
        bubble.onclick = function(e) {
            e.stopPropagation();
            e.preventDefault();
            if (isTypingEffect) {
                setTimeout(() => {
                    if (this.parentNode) showAIContextMenu(this);
                }, 100);
            } else {
                showAIContextMenu(this);
            }
        };
    }
    
    msgDiv.appendChild(bubble);
    container.appendChild(msgDiv);
    
    // 【核心修改】：只有当 skipScroll 为 false 时，才执行丝滑滚动
    if (!skipScroll) {
        scrollToBottom();
    }
    
    return {msgDiv, bubble};
}
        
    // 在不同气泡中逐句显示（智能分割）
async function typeMessageInMultipleBubbles(fullText, firstBubble, firstMsgDiv) {
    console.log("原始AI回复:", fullText);
    
    // ========== 预处理 ==========
    // 1. 合并连续标点
    fullText = fullText.replace(/([!?！？])\1+/g, '$1');
    // 2. 清理正斜线等干扰字符
    fullText = fullText.replace(/[\/／∕⧸⁄]/g, '');

    // 优先：换行符分割
    if (fullText.includes('\n')) {
        const lines = fullText.split('\n').filter(line => line.trim().length > 0);
        if (lines.length > 1) {
            console.log("按换行符分割:", lines.length, "行");
            return await displaySentences(lines, fullText, firstBubble, firstMsgDiv);
        }
    }

    // 情况1：如果已经有反斜线，直接按反斜线分割
     if (fullText.includes('\\')) {
        console.log("按反斜线分割");
        const sentences = splitByBackslash(fullText);
        if (sentences.length > 1) {
            return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
        }
    }
    
    // 情况2：如果有中文标点，按中文标点分割
    const chinesePunctuation = /[。！？；]/;
    if (chinesePunctuation.test(fullText)) {
        console.log("检测到中文标点，按标点分割");
        const sentences = splitByChinesePunctuation(fullText);
        return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
    }
    
    // 情况3：如果有英文标点，按英文标点分割
    const englishPunctuation = /[.!?;]/;
    if (englishPunctuation.test(fullText)) {
        console.log("检测到英文标点，按标点分割");
        const sentences = splitByEnglishPunctuation(fullText);
        return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
    }
    
    // 情况4：如果有逗号或分号，按逗号/分号分割
    const commaSemicolon = /[,，]/;
    if (commaSemicolon.test(fullText)) {
        console.log("检测到逗号，按逗号分割");
        const sentences = splitByComma(fullText);
        return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
    }
    
    // 情况5：按长度分割（长文本拆分成短句）
    if (fullText.length > 30) {
        console.log("长文本，按长度分割");
        const sentences = splitByLength(fullText);
        return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
    }
    
    // 情况6：直接显示（兜底）
    console.log("短文本，直接显示");
    // 【新增】最后兜底去除所有反斜线，保证干净
    const cleanText = fullText.replace(/\\/g, ''); 
    firstBubble.textContent = cleanText;
    
    return { fullReply: cleanText, sentences: [cleanText] };
}


// 【修改】按中文标点分割，防止切断中文省略号
function splitByChinesePunctuation(text) {
    const sentences = [];
    let currentSentence = '';
    
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        currentSentence += char;
        
        // 如果是中文标点
        if (/[。！？；]/.test(char)) {
            sentences.push(currentSentence);
            currentSentence = '';
        }
        // 特殊处理中文省略号（通常是 '…' 或 '……'）
        // 如果是 '…'，我们通常不把它当作句子结束符来强制换气泡，除非你希望省略号后换行
        // 这里保持原逻辑：只在 。！？； 处分割，忽略 …
    }
    
    if (currentSentence.trim()) {
        sentences.push(currentSentence.trim());
    }
    
    return sentences;
}

function splitByBackslash(text) {
    if (!text) return [];
    // 常见的逻辑是按 \ 符号分割，并过滤掉空字符串
    return text.split('\\').map(item => item.trim()).filter(item => item !== "");
}

// 【修改】按英文标点分割，但智能识别省略号
function splitByEnglishPunctuation(text) {
    const sentences = [];
    let currentSentence = '';
    
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        currentSentence += char;
        
        // 检查是否是英文标点
        if (/[.!?;]/.test(char)) {
            // 特殊处理：如果是点号 '.'
            if (char === '.') {
                // 向后看：如果后面还有一个点，说明是省略号的一部分，暂不分割
                if (i + 1 < text.length && text[i+1] === '.') {
                    continue;
                }
                // 向前看：如果前面是一个点，说明可能是省略号的结尾（...），也不分割，等后面再看
                // 但这里为了简化，我们只做“向后看”就足够防止单个点被切分
            }

            // 只有不是省略号的一部分时，才结束当前句子
            sentences.push(currentSentence);
            currentSentence = '';
        }
    }
    
    // 添加最后剩余的部分
    if (currentSentence.trim()) {
        sentences.push(currentSentence.trim());
    }
    
    return sentences;
}

function splitByNewline(text) {
    return text.split('\n').map(s => s.trim()).filter(s => s.length > 0);
}

function splitByComma(text) {
    // 按逗号分割，但避免分割太短的句子
    const sentences = [];
    const parts = text.split(/[,，]/).map(s => s.trim()).filter(s => s.length > 0);
    
    // 如果逗号分割后句子太短，合并相邻的短句
    let combined = '';
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        
        if (combined.length + part.length < 20) {
            // 合并短句
            combined += (combined ? '，' : '') + part;
        } else {
            // 保存当前合并的句子
            if (combined) {
                sentences.push(combined);
            }
            // 开始新的合并
            combined = part;
        }
    }
    
    // 添加最后一个合并的句子
    if (combined) {
        sentences.push(combined);
    }
    
    return sentences;
}

function splitByLength(text) {
    // 按长度分割长文本（每20-40字为一个句子）
    const sentences = [];
    const maxLength = 40;
    const minLength = 20;
    
    let currentSentence = '';
    const words = text.split('');
    
    for (let i = 0; i < words.length; i++) {
        currentSentence += words[i];
        
        // 如果当前句子达到最大长度，或者遇到自然断点
        if (currentSentence.length >= maxLength || 
            (currentSentence.length >= minLength && /[。！？.!?，,]/.test(words[i]))) {
            sentences.push(currentSentence.trim());
            currentSentence = '';
        }
    }
    
    // 添加最后一句
    if (currentSentence.trim()) {
        sentences.push(currentSentence.trim());
    }
    
    return sentences;
}

/* --- 开始：替换 displaySentences --- */
async function displaySentences(sentences, originalText, firstBubble, firstMsgDiv) {
    // 1. 【核心修改】强力清洗：遍历每个切分后的句子，彻底删除反斜线
    sentences = sentences.map(s => s.replace(/\\/g, '').trim()).filter(s => s.length > 0);

    // 如果清洗后没东西了（比如原文全是反斜线）
    if (sentences.length === 0) {
        const cleanText = originalText.replace(/\\/g, '');
        firstBubble.textContent = cleanText;
        return { fullReply: cleanText, sentences: [] };
    }
    
    // 如果只有一句
    if (sentences.length === 1) {
        firstBubble.textContent = sentences[0];
        scrollToBottom();
        return { fullReply: sentences[0], sentences: [sentences[0]] };
    }

    // 多个句子：逐句显示
    let fullReply = '';
    for (let i = 0; i < sentences.length; i++) {
        const sentence = sentences[i];
        fullReply += (i > 0 ? ' ' : '') + sentence;
        
        if (i === 0) {
            // 第一句修改现有气泡
            firstBubble.textContent = sentence;
            await sendPushNotification(sentence);
            addClickToBubble(firstBubble);
        } else {
            // 后面的句子创建新气泡
            const newBubble = createNewBubble(sentence, firstMsgDiv);
            addClickToBubble(newBubble);
            await sendPushNotification(sentence);
        }

        // 立即置底，防止跳动
        scrollToBottom();
        
        // 随机延迟（打字感）
        const delay = 1000 + Math.random() * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    // 结束确认置底
    scrollToBottom();
    return { fullReply, sentences };
}

// 【新增】给气泡添加点击事件的辅助函数
function addClickToBubble(bubble) {
    if (!bubble) return;
    
    bubble.style.cursor = 'pointer';
    bubble.onclick = function(e) {
        e.stopPropagation();
        e.preventDefault();
        showAIContextMenu(this);
    };
}

// 【修改】createNewBubble 函数，返回新气泡
function createNewBubble(text, referenceMsgDiv) {
    const newMsg = document.createElement('div');
    newMsg.className = 'chat-message ai';
    
    // 复制头像部分
    const avatarClone = referenceMsgDiv.querySelector('.avatar').cloneNode(true);
    newMsg.appendChild(avatarClone);
    
    // 创建新的气泡
    const newBubble = document.createElement('div');
    newBubble.className = 'bubble';
    newBubble.textContent = text;
    newMsg.appendChild(newBubble);
    
    // 添加到消息容器
    const container = document.getElementById('chat-messages');
    container.appendChild(newMsg);
    
    return newBubble; // 【重要】返回气泡元素
}

/* --- 修复版：0.2秒丝滑缓动上移（打字专用） --- */
// 定义一个全局变量，用来防止动画冲突
let chatScrollAnimationId = null;

function scrollToBottom() {
    const container = document.getElementById('chat-messages');
    if (!container) return;

    // 1. 获取起点和终点
    const start = container.scrollTop;
    const target = container.scrollHeight - container.clientHeight;
    const distance = target - start;
    const duration = 200; // 0.2秒，你需要的时间

    // 如果距离很小（比如已经在底了），直接到位，不浪费性能
    if (Math.abs(distance) < 5) {
        container.scrollTop = target;
        return;
    }

    // 2. 如果上一次动画还没跑完，立刻取消，防止画面抖动
    if (chatScrollAnimationId) {
        cancelAnimationFrame(chatScrollAnimationId);
    }

    let startTime = null;

    // 3. 定义丝滑动画过程
    function animation(currentTime) {
        if (!startTime) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        let progress = timeElapsed / duration;

        if (progress > 1) progress = 1;

        // 【核心魔法】Cubic Ease-Out 曲线
        // 这种算法会让滚动“一开始很快，快结束时慢慢停下”，非常丝滑
        const ease = 1 - Math.pow(1 - progress, 3);

        // 应用位置
        container.scrollTop = start + (distance * ease);

        if (timeElapsed < duration) {
            // 继续下一帧
            chatScrollAnimationId = requestAnimationFrame(animation);
        } else {
            // 动画结束，确保严丝合缝
            container.scrollTop = target;
            chatScrollAnimationId = null;
        }
    }

    // 启动动画
    chatScrollAnimationId = requestAnimationFrame(animation);
}

async function sendMessage() {
    const input = document.getElementById('message-input');
    const message = input.value.trim();
    if (!message) return;

    // 1. 显示用户消息
    addMessage(message, true);
    input.value = '';
    
    // 2. 显示正在输入动画
    const typingIndicator = showTypingIndicator();
    
    // 3. 准备请求参数
    const modelSelect = document.getElementById('model-select');
    const selectedModel = modelSelect.value;
    const contextHistory = getContextHistory();

    try {
        const response = await fetch('https://api.siliconflow.cn/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${API_KEY}` // 确保你有定义 API_KEY
            },
            body: JSON.stringify({
                model: selectedModel,
                messages: [
                    { role: "system", content: systemPrompt }, // 确保你有定义 systemPrompt
                    ...contextHistory,
                    { role: "user", content: message }
                ],
                stream: isStreamEnabled, // 使用你的流式开关变量
                max_tokens: 512,
                temperature: 0.7
            })
        });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);

        // 移除输入动画
        if (typingIndicator) typingIndicator.remove();

        let fullAIResponse = ""; // 用于收集完整的 AI 回复

        if (isStreamEnabled) {
            // === 情况 A：流式输出 ===
            const reader = response.body.getReader();
            const decoder = new TextDecoder("utf-8");
            let aiMessageDiv = addMessage('', false); // 先创建一个空的气泡
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonStr = line.slice(6);
                        if (jsonStr === '[DONE]') continue;
                        try {
                            const data = JSON.parse(jsonStr);
                            const content = data.choices[0].delta.content || '';
                            
                            // 拼接文字并实时显示在屏幕上
                            fullAIResponse += content; 
                            aiMessageDiv.innerHTML = marked.parse(fullAIResponse); // 假设你有 marked 库
                            scrollToBottom(); 
                            
                            // ⚠️ 注意：这里绝对不要调用 sendPushNotification
                        } catch (e) {
                            // 忽略解析错误
                        }
                    }
                }
            }
            // 循环彻底结束后，才发通知
        } else {
            // === 情况 B：非流式输出 ===
            const data = await response.json();
            fullAIResponse = data.choices[0].message.content;
            
            // 显示在屏幕上
            addMessage(fullAIResponse, false);
        }

        // ============================================
        // ★★★ 核心修复：只在这里发送唯一的一次通知 ★★★
        // ============================================
        // 只有当回复内容不为空时才发送
        if (fullAIResponse && fullAIResponse.trim() !== "") {
            console.log("AI 回复完毕，正在发送单次通知...");
            await sendPushNotification(fullAIResponse);
        }

    } catch (error) {
        if (typingIndicator) typingIndicator.remove();
        addMessage(`错误: ${error.message}`, false);
        console.error('详细错误:', error);
    }
}

// 新增：限制历史记录只保留最近N轮对话
function trimHistoryToLimit(contact, maxRounds) {
    if (!contact || !contact.history) return;
    
    // 计算用户消息数量（每条用户消息代表一轮）
    let userMsgCount = 0;
    let cutIndex = 0;
    
    // 从后往前数，找到第maxRounds轮的起始位置
    for (let i = contact.history.length - 1; i >= 0; i--) {
        if (contact.history[i].role === 'user') {
            userMsgCount++;
            if (userMsgCount > maxRounds) {
                cutIndex = i + 1; // 从这个位置之后开始保留
                break;
            }
        }
    }
    
    // 如果超过限制，截取历史记录
    if (cutIndex > 0) {
        const removedCount = cutIndex;
        contact.history = contact.history.slice(cutIndex);
        console.log(`已清理临时记忆，移除了前 ${removedCount} 条消息，保留最近 ${maxRounds} 轮对话`);
    }
}


async function mockAIResponse(userMessage, contact) {
    console.log("开始调用AI API...");
    
    // 新增：如果有之前的请求，取消它
    if (currentController) {
        currentController.abort();
        currentController = null;
    }
    
    // 新增：创建新的AbortController用于取消
    currentController = new AbortController();
    
    const settings = APP_DATA.settings;
    if (!settings.apiKey || !settings.apiUrl) {
        return "[系统提示]：请先在设置页填写 API Key 和 API URL！";
    }

    // 1. 提取当前用户说话的关键词
    const queryKeywords = extractKeywords(userMessage);
    console.log("当前对话关键词:", queryKeywords);

    // 2. 新的记忆检索逻辑（混合策略）
    let relevantMemories = [];
    
    if (contact.longMemories && contact.longMemories.length > 0) {
        // A. 提取“刻骨铭心”的记忆 (8分以上)，无论聊什么都带上
        const coreMemories = contact.longMemories.filter(m => (m.score || 0) >= 8);
        
        // B. 提取“相关”记忆 (关键词匹配)
        // 使用简单的字符串匹配，因为这比分词器更稳定
        const contextualMemories = contact.longMemories.filter(m => {
            if ((m.score || 0) >= 8) return false; // 避免重复
            if (!m.keywords) return false;
            
            // 检查记忆的关键词是否出现在了用户现在的这句话里
            // 或者记忆的内容是否包含用户说的话
            const keywords = Array.isArray(m.keywords) ? m.keywords : [m.keywords];
            return keywords.some(kw => userMessage.includes(kw)) || m.content.includes(userMessage);
        });
        
        // 合并结果：核心记忆 + 最多 5 条相关记忆
        relevantMemories = [...coreMemories, ...contextualMemories.slice(0, 5)];
    }

    // 格式化为文本给 AI 看
    let longTermMemoryText = "";
    if (relevantMemories.length > 0) {
        longTermMemoryText = relevantMemories.map(m => 
            `[${m.category || '记忆'}] ${m.content}`
        ).join('\n');
    } else {
        longTermMemoryText = "（暂无相关长期记忆）";
    }

    // 2. 获取临时记忆 (修改为：按轮数截取)
    const roundLimit = settings.contextLimit || 10; 
    let startIndex = 0;
    let userMsgCount = 0;
    
    for (let i = contact.history.length - 1; i >= 0; i--) {
        if (contact.history[i].role === 'user') {
            userMsgCount++;
            if (userMsgCount > roundLimit) {
                startIndex = i + 1;
                break;
            }
        }
    }
    
    const recentHistory = contact.history.slice(startIndex).map(m => 
        m.content
    ).join('\n');

    // 3. 构建 Prompt
    const messages = [
        {
            role: "system",
            content: `【绝对规则】你是${contact.name}，正在与用户进行角色扮演对话。用户扮演与你对话的对方。

            【关键警告】
            如果你在回复中使用正斜线（/），系统会自动删除它！
            这会导致你的回复变得混乱、不完整。
            所以绝对不要使用正斜线（/）！

            【正确的分隔方式】
            使用反斜线（\）来分隔不同的回复部分，像这样：
            （动作1）内容1\（动作2）内容2\（动作3）内容3

            【错误的分隔方式】
            （动作1）内容1/（动作2）内容2/（动作3）内容3  ← 这样会被系统删除斜线，变成：
            （动作1）内容1（动作2）内容2（动作3）内容3


            【严格人称规范】
            1. 用户消息中所有括号()内的内容，都是对你的客观描述或你执行的动作
            2. 例如："（你困了）" → 表示你现在困了
            3. 例如："（你联系了学弟）" → 表示你联系了学弟
            4. 例如："（描写你的外貌）" → 表示描写你自己的外貌
            5. 括号内永远是你（${contact.name}）的行为/状态，不是用户的

            【人称解析规则 - 最重要！】
            用户发送的消息需要这样理解：

            1. **括号内有"你"字** → 描述的是你（${contact.name}）的状态/动作
            - 用户说"（你摔倒了）" → 你摔倒了，你要回应自己摔倒的情况
            - 用户说"（你的腿传来剧痛）" → 你的腿在疼，你要表现出疼痛
            - 用户说"（你哭了）" → 你在哭，你要表现出哭泣的状态

            2. **括号内没有"你"字** → 描述的是用户自己的动作
            - 用户说"（轻笑）" → 用户在轻笑
            - 用户说"（走近）" → 用户走近了你
            - 用户说"（叹气）" → 用户叹气了

            3. **括号外的内容** → 用户对你说的话

            【你的回复要求】
            1. 第一人称：永远用"我"自称
            2. 对用户的称呼：用"你"称呼用户
            3. 格式：（动作描写）对话内容
            4. 使用反斜线\分隔不同的句子
            5. 每次回复3-4句

            【错误示例纠正】
            用户输入：（你联系了学弟）
            错误：你联系了学弟吗？（混淆人称）
            正确：（微笑着点头）嗯，我刚才联系了学弟，他很快就回复了

            用户输入：（你摔倒了）
            错误：你没事吧？（把用户当成了摔倒的人）
            正确：（揉着膝盖站起来）哎呀，不小心摔了一跤，不过没事

            用户输入：（描写你的衣服）
            错误：你的衣服很漂亮（说用户的衣服）
            正确：（整理了一下裙摆）我今天穿了浅蓝色的连衣裙，喜欢吗？
                        
            【你的设定】
            ${contact.tempPrompt ? `【当前状态/临时设定】\n${contact.tempPrompt}\n` : ''}

            【核心人设】
            ${contact.prompt}

            ${applyDeepPresetToPrompt()}  

            【你的私人日记（长期记忆）】
            这是你过去写下的日记，记录了你和用户的过往，请参考这些记忆来保持人设连贯：
            ${longTermMemoryText}

            【回复格式要求】
            1. 必须使用反斜线 \ 来分隔不同的回复部分
            2. 每个部分应该是一个完整的句子或表达
            3. 示例格式：（轻笑着摸摸你的头）你已经做得很棒了\（蹭蹭你的颈窝）好喜欢你…\（轻轻点头）都听你的！
            4. 在每个对话前必须使用适当的动作描述，如：（轻笑着摸摸你的头）你已经做得很棒了、（蹭蹭你的颈窝）好喜欢你…、（轻轻点头）都听你的！
            5. 绝对不要在一个部分中包含多个句子，每个句子都要用反斜线分隔
            6.每次只回复3-4句

            【示例】
            用户：你好
            正确回复：（轻笑着摸摸你的头）你已经做得很棒了\（蹭蹭你的颈窝）好喜欢你…\（轻轻点头）都听你的！
            错误回复：AI：（轻笑着摸摸你的头）你已经做得很棒了（带角色标识符）
            错误回复：（轻笑着摸摸你的头）你已经做得很棒了（蹭蹭你的颈窝）好喜欢你…（轻轻点头）都听你的！（没有用反斜线分隔）
            `
                    },
                    {        
                        role: "user",
                        content: `
            【最近的对话记录】
            ${recentHistory}

            【当前用户说】：${userMessage}

            请根据记忆和设定回复。`
        }
    ];

    try {
        console.log("发送API请求到:", settings.apiUrl);
        console.log("使用模型:", settings.aiModel);
        console.log("消息长度:", JSON.stringify(messages).length);
        
        const response = await fetch('https://api.ginkgo-yinxing.workers.dev/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${settings.apiKey}`,
                'X-Target-API': settings.apiUrl
            },
            body: JSON.stringify({
            model: settings.aiModel,
            messages: messages,
            temperature: settings.temperature || 0.7,
            max_tokens: settings.maxTokens || 2048, // 使用你滑块保存的变量
            stream: settings.stream || false
    }),
            signal: currentController.signal
        });

        console.log("API响应状态:", response.status, response.statusText);
        
       if (response.ok) {
            const rawText = await response.text(); 
            console.log("服务器返回的原始数据:", rawText);

            let result = "";

            // 检查服务器是否强行返回了带 "data:" 的流格式 [cite: 723, 724]
            if (rawText.includes('data:')) {
                const lines = rawText.split('\n');
                for (let line of lines) {
                    let cleanLine = line.trim();
                    if (cleanLine.startsWith('data:') && !cleanLine.includes('[DONE]')) {
                        try {
                            const json = JSON.parse(cleanLine.replace('data:', '').trim());
                            // 兼容流式(delta)和非流式(message)格式 [cite: 748, 749]
                            const content = json.choices?.[0]?.delta?.content || json.choices?.[0]?.message?.content || "";
                            result += content;
                        } catch (e) {
                            console.error("解析单行流数据失败", e);
                        }
                    }
                }
            } else {
                // 如果是正常的 JSON 格式 [cite: 748]
                try {
                    const data = JSON.parse(rawText);
                    if (data.choices && data.choices[0]?.message?.content) {
                        result = data.choices[0].message.content;
                    } else {
                        result = rawText;
                    }
                } catch (e) {
                    result = rawText;
                }
            }

            // 强力删除所有正斜线并应用正则 [cite: 755, 756]
            result = result.replace(/<think>[\s\S]*?<\/think>/gi, '').trim();

        	    result = result.replace(/\//g, '');
         	   result = applyRegexToText(result);

            if (currentContact) {
                saveData(); // [cite: 757]
            }
            
            return result || "AI 返回了空内容";
            
        } else {
            const errorText = await response.text();
            console.error("API错误响应:", errorText);
            
            let errorMsg = `[API错误]：${response.status}`;
            if (errorText) {
                try {
                    const errorData = JSON.parse(errorText);
                    if (errorData.error?.message) {
                        errorMsg = `[API错误]：${errorData.error.message}`;
                    }
                } catch (e) {
                    errorMsg = `[API错误]：${response.status} - ${errorText.substring(0, 100)}`;
                }
            }
            return errorMsg;
        }
    } catch (error) {
        console.error("网络请求错误:", error);
        
        let errorMsg = `[网络错误]：${error.message}`;
        
        // 更友好的错误提示
        if (error.name === 'AbortError') {
            errorMsg = "[请求已取消]";
        } else if (error.message.includes('Failed to fetch')) {
            errorMsg = "[网络连接失败]：请检查API URL是否正确，网络是否通畅";
        } else if (error.message.includes('timeout')) {
            errorMsg = "[请求超时]：API响应时间过长，请稍后重试";
        }
        
        return errorMsg;
    }
}
        
// --- ⬇️ 修改后：记录轮数 + 记忆生成逻辑 ⬇️ ---
async function simulateMemorySummary(contact) {
    console.log("🧠 尝试触发长期记忆生成逻辑...");
    
    // 1. 动态读取频率设置
    const interval = parseInt(APP_DATA.settings.diaryInterval) || 10; 
    const userMessagesCount = contact.history.filter(m => m.role === 'user').length;

    // 2. 触发检查
    if (userMessagesCount === 0 || userMessagesCount % interval !== 0) {
        return; 
    }

    console.log(`📝 达到第 ${userMessagesCount} 轮，开始以第一人称生成记忆...`);
    
    // 3. 准备素材
    const sliceCount = interval * 2 + 5;
    const recentChat = contact.history.slice(-sliceCount).map(m => 
        m.content
    ).join('\n');

    // 构建“已有记忆库”字符串，用于防重
    const allExistingMemories = contact.longMemories 
        ? contact.longMemories.map(m => m.content).join('\n')
        : "暂无记忆";

    const apiUrl = APP_DATA.settings.apiUrl;
    const apiKey = APP_DATA.settings.apiKey;
    const model = APP_DATA.settings.aiModel;

    // 4. 提示词构造
    const summaryMessages = [
        {
            role: "system",
            content: `【指令】你不再是冷冰冰的记录员，你是 **${contact.name}** 本人。
            你正在写属于自己的私密日记，记录关于“他/她”（和你对话的人）的事情。

            【第一人称视角规则 - 必须严格执行】
            1. **"我"** = ${contact.name}（你自己）。
            2. **"他" / "她"** = 和你对话的人。
            3. 如果你知道他的昵称（如"哥哥"、"阿祖"），必须用昵称称呼他。
            4. 🚫 **绝对禁止出现**："用户"、"对方"、"玩家" 这些词！
            5. 🚫 **绝对禁止出现**：用第三人称称呼你自己（比如不要写"${contact.name}喜欢他"，要写"我喜欢他"）。

            【去重规则 - 必须严格执行】
            请先阅读下方的【已有记忆库】。
            如果某个事实（例如"他叫哥哥"、"他喜欢吃辣"）**已经存在于库中，绝对不要再次记录！**
            只记录**全新的**、或者**发生变化**的信息。

            【格式要求】
            每条记忆占一行：分类|评分|关键词|内容
            
            【字段说明】
            1. 分类：[核心]、[偏好]、[进展]、[日常]
            2. 评分：1-10（8分以上为极重要事实）
            3. 关键词：3个，保留专有名词
            
            【正确示例】
            [核心]|10|称呼,关系|哥哥说我是他最重要的人，听到这话我心跳好快。
            [日常]|6|习惯|他今天好像不太开心，一直叹气，我很担心他。
            `
        },
        {
            role: "user",
            content: `
            【已有记忆库（禁止重复记录这些）】
            ${allExistingMemories}

            【最近的对话】
            ${recentChat}

            请以 **${contact.name}** 的第一人称视角，写下新的日记（如果没有新信息则什么都不用写）：`
        }
    ];

    try {
        const response = await fetch('https://api.ginkgo-yinxing.workers.dev/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`,
                'X-Target-API': apiUrl
            },
            body: JSON.stringify({
                model: model,
                messages: summaryMessages,
                temperature: 0.1, 
                max_tokens: 500
            })
        });

        if (response.ok) {
            const data = await response.json();
            let aiContent = "";
            
            if (data.choices && data.choices[0]?.message?.content) aiContent = data.choices[0].message.content;
            else if (data.result) aiContent = data.result;

            if (aiContent) {
                console.log("📥 AI 返回的日记:", aiContent);
                const lines = aiContent.split('\n');
                if (!contact.longMemories) contact.longMemories = [];
                
                const now = new Date();
                const dateStr = `${now.getMonth()+1}月${now.getDate()}日`;
                
                // 【新增】计算轮数范围，例如 "第11-20轮"
                const startRound = Math.max(1, userMessagesCount - interval + 1);
                const roundRangeStr = `第${startRound}-${userMessagesCount}轮`;

                let addedCount = 0;

                lines.forEach(line => {
                    const cleanLine = line.trim();
                    if (!cleanLine) return;
                    if (cleanLine.includes("提取") || cleanLine.startsWith("好的") || cleanLine.includes("日记")) return;

                    const parts = cleanLine.split('|');
                    if (parts.length >= 4) {
                        const content = parts[3].trim();
                        
                        // JS层二次去重
                        const isDuplicate = contact.longMemories.some(m => 
                            m.content === content || 
                            (content.length > 5 && m.content.includes(content)) ||
                            (m.content.length > 5 && content.includes(m.content))
                        );

                        if (!isDuplicate) {
                            contact.longMemories.push({
                                id: Date.now() + Math.random(),
                                date: dateStr,
                                roundRange: roundRangeStr, // 【这里保存了轮数！】
                                category: parts[0].trim().replace(/[\[\]]/g, ''),
                                score: parseInt(parts[1].trim()) || 5,
                                keywords: parts[2].split(/[,，]/).map(k=>k.trim()),
                                content: content, 
                                type: 'structured'
                            });
                            addedCount++;
                        }
                    }
                });

                if (addedCount > 0) {
                    saveData();
                    console.log(`✅ 成功写入 ${addedCount} 条新日记`);
                }
            }
        }
    } catch (e) {
        console.error("生成日记失败:", e);
    }
}


// --- ⬇️ 全新逻辑：带搜索、分类、Tag功能的记忆弹窗 ⬇️ ---

// 1. 全局变量：记录当前弹窗的状态
let memoryState = {
    searchTerm: '',
    activeCategory: '全部', 
    activeTag: null 
};

// --- ⬇️ 修改后：字体强制统一 + 样式修复 ⬇️ ---
function showMemoryModal(contextType) {
    if (!currentContact) return;
    APP_DATA.activeModalContext = contextType;
    
    // 初始化弹窗
    const modal = document.getElementById('memory-modal');
    const contentDiv = modal.querySelector('.modal-content');
    
    // 重置状态
    memoryState = { searchTerm: '', activeCategory: '全部', activeTag: null };

    // 标题
    let titleText = '记忆档案';
    if (contextType === 'prompt') titleText = '角色设定 (Prompt)';
    else if (contextType === 'short') titleText = '临时记忆';
    else if (contextType === 'long') titleText = '长期记忆档案';

    // 头部 HTML
    contentDiv.innerHTML = `
        <div class="memory-header-row">
            <div class="memory-back-btn clickable" onclick="goBackInMemoryModal()">
                <i class="fa-solid fa-angle-left"></i>
            </div>
            <h4 id="memory-modal-title">${titleText}</h4>
        </div>
        <div id="memory-content-container"></div>
        <div class="modal-footer">
            <button id="memory-save-btn" class="save-btn clickable" onclick="saveContextModalData()">保存修改</button>
            <button class="cancel-btn clickable" onclick="hideModal('memory-modal')">关闭</button>
        </div>
    `;

    const container = document.getElementById('memory-content-container');
    const saveBtn = document.getElementById('memory-save-btn');

    // --- 情况A：修改角色 Prompt ---
    if (contextType === 'prompt') {
        saveBtn.style.display = 'inline-block';
        
        // 滚动容器
        const scrollWrapper = document.createElement('div');
        scrollWrapper.style.cssText = "height: 100%; overflow-y: auto; padding-right: 5px;";
        
        // 🌟 辅助方法：统一字体大小
        const createPromptSection = (iconClass, labelText, value, id, placeholder, height) => {
            const wrapper = document.createElement('div');
            wrapper.style.marginBottom = '15px'; // 间距稍微调小一点
            
            // 标题栏
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            header.style.marginBottom = '5px';
            
            // 左侧：图标 + 文字
            const titleContainer = document.createElement('div');
            titleContainer.style.display = 'flex';
            titleContainer.style.alignItems = 'center';
            titleContainer.style.fontWeight = 'bold';
            
            // 🔥【关键】标题字体设置为 14px
            titleContainer.style.fontSize = '14px'; 
            titleContainer.style.color = 'var(--text-color-primary)';

            const icon = document.createElement('i');
            icon.className = iconClass; 
            icon.style.marginRight = '6px';
            icon.style.color = 'var(--text-color-secondary)'; 
            
            const text = document.createElement('span');
            text.textContent = labelText;

            titleContainer.appendChild(icon);
            titleContainer.appendChild(text);
            
            // 右侧：复制按钮
            const copyIcon = document.createElement('i');
            copyIcon.className = 'fa-regular fa-copy clickable';
            copyIcon.style.cursor = 'pointer';
            copyIcon.style.fontSize = '14px';
            copyIcon.style.padding = '5px';
            copyIcon.style.color = 'var(--text-color-secondary)';
            copyIcon.onclick = function() { copyText(this, id); };
            
            header.appendChild(titleContainer);
            header.appendChild(copyIcon);
            
            // 输入框
            const textarea = document.createElement('textarea');
            textarea.id = id;
            textarea.style.height = height; 
            textarea.style.width = '100%';
            
            // 🔥【关键】强制输入框字体也为 13px，与标题完全一致
            // 使用 !important 防止被其他样式覆盖
            textarea.style.cssText = `
                height: ${height};
                width: 100%;
                font-size: 13px !important; 
                line-height: 1.5 !important;
                padding: 8px !important;
                font-family: inherit;
            `;
            
            textarea.value = value || '';
            textarea.placeholder = placeholder;
            
            wrapper.appendChild(header);
            wrapper.appendChild(textarea);
            return wrapper;
        };

        // 1. 上方：临时设定
        scrollWrapper.appendChild(createPromptSection(
            'fa-solid fa-mask', 
            '临时设定', 
            currentContact.tempPrompt, 
            'temp-prompt-input', 
            '输入临时状态/职业...', 
            '80px'
        ));
        
        // 2. 下方：核心设定
        scrollWrapper.appendChild(createPromptSection(
            'fa-solid fa-brain', 
            '核心设定', 
            currentContact.prompt, 
            'core-prompt-input', 
            '输入核心性格/背景...', 
            '250px'
        ));

        container.appendChild(scrollWrapper);

    // --- 情况B：临时记忆 (保持不变) ---
    } else if (contextType === 'short') {
        saveBtn.style.display = 'inline-block';
        
        const headerDiv = document.createElement('div');
        const searchWrapper = document.createElement('div');
        searchWrapper.className = 'search-bar-wrapper';
        searchWrapper.innerHTML = `<i class="fa-solid fa-magnifying-glass"></i>`;
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.className = 'memory-search-box';
        searchInput.placeholder = '搜索聊天记录...';
        searchInput.oninput = (e) => {
            memoryState.searchTerm = e.target.value.trim();
            renderShortTermMemoryInModal();
        };
        searchWrapper.appendChild(searchInput);
        headerDiv.appendChild(searchWrapper);
        container.appendChild(headerDiv);

        const listContainer = document.createElement('div');
        listContainer.id = 'memory-list-scroll-area';
        container.appendChild(listContainer);

        renderShortTermMemoryInModal();

    // --- 情况C：长期记忆 (保持不变) ---
    } else if (contextType === 'long') {
        saveBtn.style.display = 'none'; 

        const headerDiv = document.createElement('div');
        const searchWrapper = document.createElement('div');
        searchWrapper.className = 'search-bar-wrapper';
        searchWrapper.innerHTML = `<i class="fa-solid fa-magnifying-glass"></i>`;
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.className = 'memory-search-box';
        searchInput.placeholder = '搜索记忆内容 / Tag...';
        searchInput.oninput = (e) => {
            memoryState.searchTerm = e.target.value.trim();
            renderMemoryList(); 
        };
        searchWrapper.appendChild(searchInput);
        headerDiv.appendChild(searchWrapper);

        const tabsDiv = document.createElement('div');
        tabsDiv.className = 'memory-tabs';
        const fixedCategories = ['全部', '核心', '偏好', '日常', '进展'];
        const existingCategories = currentContact.longMemories 
            ? [...new Set(currentContact.longMemories.map(m => m.category))]
            : [];
        const allCategories = [...new Set([...fixedCategories, ...existingCategories])];

        allCategories.forEach(cat => {
            const tab = document.createElement('div');
            tab.className = `memory-tab ${cat === '全部' ? 'active' : ''}`;
            tab.textContent = cat;
            tab.onclick = () => {
                document.querySelectorAll('.memory-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                memoryState.activeCategory = cat;
                renderMemoryList();
            };
            tabsDiv.appendChild(tab);
        });
        headerDiv.appendChild(tabsDiv);
        
        const tagFilterDiv = document.createElement('div');
        tagFilterDiv.id = 'memory-tag-filter-display';
        tagFilterDiv.style.cssText = 'display:none; margin-bottom:10px; font-size:13px; color:var(--accent-color);';
        headerDiv.appendChild(tagFilterDiv);

        container.appendChild(headerDiv);

        const listContainer = document.createElement('div');
        listContainer.id = 'memory-list-scroll-area';
        container.appendChild(listContainer);

        renderMemoryList();
    }
    
    showModal('memory-modal');
}

// 3. 核心辅助函数：渲染记忆列表 (带过滤功能)
function renderMemoryList() {
    const listDiv = document.getElementById('memory-list-scroll-area');
    const tagFilterDisplay = document.getElementById('memory-tag-filter-display');
    if (!listDiv) return;

    listDiv.innerHTML = ''; // 清空当前列表

    // 更新 Tag 过滤提示
    if (memoryState.activeTag) {
        tagFilterDisplay.style.display = 'block';
        tagFilterDisplay.innerHTML = `
            当前标签筛选：<b>#${memoryState.activeTag}</b> 
            <span style="cursor:pointer; margin-left:10px; color:var(--text-color-secondary)" onclick="clearTagFilter()">[清除]</span>
        `;
    } else {
        tagFilterDisplay.style.display = 'none';
    }

    if (!currentContact.longMemories || currentContact.longMemories.length === 0) {
        listDiv.innerHTML = '<div style="text-align:center; padding:30px; color:var(--text-color-secondary);">暂无档案</div>';
        return;
    }

    // --- 核心过滤逻辑 ---
    const filteredMemories = currentContact.longMemories.filter(m => {
        // 1. 分类过滤
        if (memoryState.activeCategory !== '全部' && m.category !== memoryState.activeCategory) {
            return false;
        }
        // 2. Tag 过滤
        if (memoryState.activeTag) {
            if (!m.keywords || !m.keywords.includes(memoryState.activeTag)) {
                return false;
            }
        }
        // 3. 搜索词过滤
        if (memoryState.searchTerm) {
            const term = memoryState.searchTerm.toLowerCase();
            const contentMatch = m.content.toLowerCase().includes(term);
            const tagMatch = m.keywords && m.keywords.some(k => k.toLowerCase().includes(term));
            if (!contentMatch && !tagMatch) return false;
        }
        return true;
    });

    // --- 渲染结果 ---
    // 倒序显示（reverse() 确保最新的在最上面）
    filteredMemories.reverse().forEach(memory => {
        const score = memory.score || 5;
        // 颜色条逻辑
        let color = '#8e8e93'; 
        if (score >= 8) color = '#ff4d4f'; 
        else if (score >= 6) color = '#52c41a'; 
        else if (score >= 4) color = '#1890ff';

        // 轮数 vs 日期 显示逻辑
        const timeDisplay = memory.roundRange 
            ? `<span class="memory-round-badge">${memory.roundRange}</span>` 
            : `<span class="memory-round-badge">${memory.date}</span>`;

        const item = document.createElement('div');
        item.style.cssText = `
            margin-bottom: 12px; 
            border-left: 4px solid ${color};
            border-radius: 4px;
            padding: 10px 15px; 
            background: var(--input-bg);
            position: relative;
        `;

        // 生成 Tags HTML (点击可过滤)
        let tagsHtml = '';
        if (Array.isArray(memory.keywords)) {
            tagsHtml = memory.keywords.map(k => 
                `<span class="memory-tag" onclick="filterByTag('${k}')">#${k}</span>`
            ).join(' ');
        }

        item.innerHTML = `
            <div style="display:flex; justify-content:space-between; margin-bottom:6px; font-size:12px; color:var(--text-color-secondary);">
                <div>
                    ${timeDisplay}
                    <span style="background:${color}20; color:${color}; padding:1px 4px; border-radius:3px; margin-right:5px;">${memory.category}</span>
                    <span>评分:${score}</span>
                </div>
                <span class="clickable" onclick="deleteMemory('${memory.id}')" style="color:var(--danger-color); font-weight:bold;">×</span>
            </div>
            <div style="font-size:15px; color:var(--text-color-primary); line-height:1.5; margin-bottom:6px;">
                ${memory.content}
            </div>
            <div style="font-size:12px; opacity:0.9;">
                ${tagsHtml}
            </div>
        `;
        listDiv.appendChild(item);
    });

    if (filteredMemories.length === 0) {
        listDiv.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-color-secondary);">没有找到匹配的档案</div>';
    }

    // 需求1: 强制停留在最顶部（显示最新的档案）
    listDiv.scrollTop = 0;
}

// 4. 辅助功能：点击Tag过滤
function filterByTag(tag) {
    memoryState.activeTag = tag;
    // 清空搜索框，避免冲突
    document.querySelector('.memory-search-box').value = '';
    memoryState.searchTerm = '';
    renderMemoryList();
}

// 5. 辅助功能：清除Tag过滤
function clearTagFilter() {
    memoryState.activeTag = null;
    renderMemoryList();
}

// --- ⬇️ 修改后：支持搜索过滤的临时记忆渲染 ⬇️ ---
function renderShortTermMemoryInModal() {
    // 自动获取容器，不再依赖参数传入
    const container = document.getElementById('memory-list-scroll-area');
    if (!container) return;
    
    container.innerHTML = ''; // 清空列表

    // 1. 整理数据为“轮次”
    const rounds = [];
    let currentRound = [];
    currentContact.history.forEach((message) => {
        if (message.role === 'user' && currentRound.length > 0) {
            rounds.push([...currentRound]);
            currentRound = [];
        }
        currentRound.push(message);
    });
    if (currentRound.length > 0) rounds.push([...currentRound]);
    window.tempMemoryRounds = rounds;

    // 2. 搜索过滤逻辑
    let displayRounds = rounds;
    if (memoryState.searchTerm) {
        const term = memoryState.searchTerm.toLowerCase();
        displayRounds = rounds.filter((round) => {
            // 如果这一轮里有任何一句话包含搜索词，就显示这一轮
            return round.some(msg => msg.content.toLowerCase().includes(term));
        });
    }

    if (displayRounds.length === 0) {
        container.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-color-secondary);">暂无对话</div>';
        return;
    }

    // 3. 渲染
    // 注意：这里我们通过 rounds 的原始索引来确保删除功能正常
    displayRounds.forEach((round) => {
        // 找到它在原始数组中的索引，以便删除时ID正确
        const originalIndex = rounds.indexOf(round);

        const roundContainer = document.createElement('div');
        roundContainer.className = 'round-container';
        
        const roundHeader = document.createElement('div');
        roundHeader.className = 'round-header';
        roundHeader.innerHTML = `第${originalIndex + 1}轮对话 <button class="round-delete-btn clickable" onclick="deleteRound(${originalIndex})">×</button>`;
        roundContainer.appendChild(roundHeader);
        
        const roundContent = document.createElement('div');
        roundContent.className = 'round-content';
        
        round.forEach((message) => {
            const messageDiv = document.createElement('div');
            messageDiv.className = `round-message ${message.role}`;
            messageDiv.contentEditable = true;
            messageDiv.dataset.role = message.role;
            // 标记高亮 (可选)
            if (memoryState.searchTerm) {
                // 简单的查找高亮逻辑，为了不破坏HTML结构，这里只做简单文本替换
                // 如果需要更复杂的高亮，可以加 span
            }
            messageDiv.textContent = message.content;
            roundContent.appendChild(messageDiv);
        });
        roundContainer.appendChild(roundContent);
        container.appendChild(roundContainer);
    });
    
    // 如果不是在搜索状态，自动滚到底部（查看最新）
    if (!memoryState.searchTerm) {
        setTimeout(() => { container.scrollTop = container.scrollHeight; }, 50);
    } else {
        container.scrollTop = 0; // 搜索时滚到顶部
    }
}
        
        function saveContextModalData() {
            const contextType = APP_DATA.activeModalContext;
            
           if (contextType === 'prompt') {
                const tempInput = document.getElementById('temp-prompt-input');
                const coreInput = document.getElementById('core-prompt-input');
                
                // 保存两个字段
                currentContact.tempPrompt = tempInput.value;
                currentContact.prompt = coreInput.value; // prompt 字段现在只存核心人设
                
                alert('角色设定已保存！\n(临时设定 + 核心人设)');
                saveData();
                hideModal('memory-modal');

          } else if (contextType === 'long') {
    // 获取所有修改后的记忆
    const textareas = document.querySelectorAll('#memory-content-container textarea');
    
    // 更新现有的记忆数组
    if (currentContact.longMemories && currentContact.longMemories.length > 0) {
        textareas.forEach((textarea, index) => {
            if (currentContact.longMemories[index]) {
                currentContact.longMemories[index].content = textarea.value;
            }
        });
    }
    
    alert('长期记忆已保存！');
    saveData();
    hideModal('memory-modal');
            } else if (contextType === 'short') {
                // 需求5: 保存修改后的临时记忆
                const roundContainers = document.querySelectorAll('.round-container');
                const newHistory = [];
                
                roundContainers.forEach((container, roundIndex) => {
                    const messages = container.querySelectorAll('.round-message');
                    messages.forEach(msgDiv => {
                        const role = msgDiv.dataset.role;
                        const content = msgDiv.textContent.trim();
                        if (content) {
                            newHistory.push({ role, content });
                        }
                    });
                });
                
                if (newHistory.length > 0) {
                currentContact.history = newHistory;
                // 设置标记，但不自动跳转
                window.needRefreshChat = true;
                alert('临时记忆已更新！');
                saveData();
                hideModal('memory-modal');
                // 不自动跳转，让用户手动返回
                } else {
                    alert('对话内容不能为空！');
                }
            }
        }
        
// 清空临时记忆
function clearShortTermMemory() {
    if (!currentContact) return;
    
    if (currentContact.history.length === 0) {
        alert('临时记忆已经是空的！');
        return;
    }
    
    if (confirm('确定要清空所有临时记忆吗？\n\n这将删除所有对话历史，无法恢复！')) {
            currentContact.history = [];
    
    // 立即更新聊天界面（如果正在聊天）
    if (document.getElementById('chat-window').style.display === 'flex') {
        renderMessages([]); // 传入空数组，清空显示
    }
        
        // 如果当前在聊天窗口，刷新显示
        if (document.getElementById('chat-window').style.display === 'flex') {
            renderMessages(currentContact.history);
        }
        
        saveData();
        alert('临时记忆已清空！');
        
        // 如果正在查看临时记忆弹窗，关闭它
        if (document.getElementById('memory-modal').style.display === 'flex' && 
            APP_DATA.activeModalContext === 'short') {
            hideModal('memory-modal');
        }
    }
}

// 清空长期记忆
function clearLongTermMemory() {
    if (!currentContact) return;
    
    if (confirm('确定要清空长期记忆吗？\n\n这将删除AI对这个角色的所有记忆，无法恢复！')) {
        // 清空两个地方
        currentContact.longMemory = '无';
        if (currentContact.longMemories) {
            currentContact.longMemories = [];
        }
        
        saveData();
        alert('长期记忆已清空！');
        
        if (document.getElementById('memory-modal').style.display === 'flex' && 
            APP_DATA.activeModalContext === 'long') {
            hideModal('memory-modal');
        }
    }
}


// 删除特定轮次的对话
function deleteRound(roundIndexToDelete) {
    if (!currentContact || !window.tempMemoryRounds) return;
    
    if (confirm('确定要删除这一轮对话吗？删除后无法恢复。')) {
        // 从临时存储的rounds中移除指定轮次
        window.tempMemoryRounds.splice(roundIndexToDelete, 1);
        
        // 重新构建历史记录
        const newHistory = [];
        window.tempMemoryRounds.forEach(round => {
            round.forEach(message => {
                newHistory.push(message);
            });
        });
        
        // 更新当前联系人的历史记录
        currentContact.history = newHistory;
        
        // 刷新临时记忆显示
        showMemoryModal('short');
        
        // 如果当前在聊天窗口，也刷新聊天显示
        if (document.getElementById('chat-window').style.display === 'flex') {
            renderMessages(currentContact.history);
        }
        
        // 保存数据
        saveData();
        alert('已删除该轮对话');
    }
}
        function loadAvatarPreview(data, elementId) {
            const previewElement = document.getElementById(elementId);
            if (!previewElement) return;
            previewElement.innerHTML = '';
            
            if (data && data.startsWith('data:image')) {
                const img = document.createElement('img');
                img.src = data;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                previewElement.appendChild(img);
            } else {
                previewElement.textContent = 'AI';
                previewElement.style.display = 'flex';
                previewElement.style.justifyContent = 'center';
                previewElement.style.alignItems = 'center';
                previewElement.style.backgroundColor = 'var(--accent-color)';
                previewElement.style.color = 'white';
                previewElement.style.fontSize = elementId === 'current-ai-avatar-preview' ? '36px' : '20px';
            }
        }

        document.getElementById('ai-avatar-file').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // 检查文件大小（限制为2MB）
            if (file.size > 2 * 1024 * 1024) {
                alert('头像图片大小不能超过2MB');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64Image = e.target.result;
                document.getElementById('ai-avatar-base64').value = base64Image;
                loadAvatarPreview(base64Image, 'current-ai-avatar-preview');
            };
            reader.readAsDataURL(file);
        });
// 数据迁移：将旧格式的历史转换为新格式
function migrateHistoryData() {
    let needsMigration = false;
    
    APP_DATA.contacts.forEach(contact => {
        const newHistory = [];
        let tempSegments = [];
        
        contact.history.forEach((msg, index) => {
            if (msg.role === 'ai') {
                // 检查是否包含反斜线分割
                if (msg.content.includes('\\') && !msg.isSegment) {
                    needsMigration = true;
                    // 分割消息
                    const sentences = splitByBackslash(msg.content);
                    sentences.forEach((sentence, segIndex) => {
                        newHistory.push({
                            role: 'ai',
                            content: sentence,
                            isSegment: true,
                            segmentIndex: segIndex
                        });
                    });
                } else {
                    newHistory.push(msg);
                }
            } else {
                newHistory.push(msg);
            }
        });
        
        contact.history = newHistory;
    });
    
    if (needsMigration) {
        saveData();
        console.log('历史数据已迁移为新格式');
    }
}



// 从点击的气泡重新生成
function regenerateFromBubble() {
    const menu = document.getElementById('ai-context-menu');
    const bubble = window.lastClickedBubble;
    
    // 关闭菜单
    if (menu) menu.style.display = 'none';
    
    if (!bubble || !currentContact) return;
    
    // 检查是否是正在输入的气泡
    const isTypingBubble = bubble.classList.contains('typing-indicator');
    
    if (isTypingBubble) {
        // 1. 立即停止当前请求
        isTyping = false;
        currentAIRequest = null; // 取消请求标记
        
        // 新增：取消正在进行的网络请求
        if (currentController) {
            currentController.abort();
            currentController = null;
        }
        
        // 2. 删除这个加载中的气泡
        const msgDiv = bubble.closest('.chat-message');
        if (msgDiv) {
            msgDiv.remove();
        }
        
        // 3. 重新生成（找到最后一条用户消息重新请求）
        regenerateAIReply();
    } else {
        // 普通气泡的重新生成逻辑
        regenerateAIReply();
    }
}


// 【新增】确保消息容器的底部有足够空间
function ensureMessageSpace() {
    const container = document.getElementById('chat-messages');
    if (!container) return;
    
    // 强制滚动到底部，给新消息留出空间
    container.scrollTop = container.scrollHeight;
    
    // 添加一点底部padding，确保新消息不会紧贴输入框
    setTimeout(() => {
        container.style.paddingBottom = '80px'; // 临时增加padding
        scrollToBottomInstant();
    }, 50);
}

// 【新增】滚动到特定元素
function scrollToElement(element) {
    const container = document.getElementById('chat-messages');
    if (!container || !element) return;
    
    // 计算元素在容器中的位置
    const elementRect = element.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    // 如果元素在容器底部以下，滚动到它
    if (elementRect.bottom > containerRect.bottom - 100) {
        const scrollTop = container.scrollTop + (elementRect.bottom - containerRect.bottom) + 120;
        container.scrollTop = scrollTop;
    }
}        document.addEventListener('DOMContentLoaded', () => {
            // 数据迁移：为已有的预设添加lastUsedTime字段
    if (APP_DATA.presets) {
        let needsMigration = false;
        APP_DATA.presets.forEach(preset => {
            if (!preset.lastUsedTime) {
                preset.lastUsedTime = Date.now(); // 设置为当前时间
                needsMigration = true;
            }
        });
        
        if (needsMigration) {
            saveData();
            console.log('预设数据已迁移，添加了最后使用时间字段');
        }
    }
            migrateHistoryData(); 
            renderContacts();
            toggleTheme(APP_DATA.currentTheme); 
            loadSettings();
            initPresetSystem();
            // 【新增】初始化通知开关状态
            const savedState = APP_DATA.settings.notificationShowContent !== false;
            window.isNotificationContentEnabled = savedState;
            updateNotificationSwitchUI(savedState);

         });
     
// 记忆弹窗返回按钮
    function goBackInMemoryModal() {
           document.getElementById('memory-modal').style.display = 'none';
           showPage('options-page');
}
    // 更新总结设置
function updateSummaryThreshold() {
    if (!currentContact) return;
    const input = document.getElementById('summary-threshold');
    const num = parseInt(input.value);
    if (num >= 5 && num <= 100) {
        currentContact.summaryThreshold = num;
        saveData();
        alert('已更新设置：每' + num + '轮对话总结一次');
    } else {
        alert('请输入5-100的数字');
    }
}



// 删除记忆
function deleteMemory(memoryId) {
    if (!confirm('删除这条记忆？')) return;
    const index = currentContact.longMemories.findIndex(m => m.id == memoryId);
    if (index > -1) {
        currentContact.longMemories.splice(index, 1);
        currentContact.longMemory = currentContact.longMemories.slice(-3).map(m=>m.content).join('\n');
        saveData();
        showMemoryModal('long'); // 重新加载页面
    }
}    
     // 自动切换主题（根据当前模式切换到相反模式）
function toggleThemeAuto() {
    const isDark = document.documentElement.classList.contains('dark-mode');
    const newMode = isDark ? 'light' : 'dark';
    toggleTheme(newMode);
    updateSwitchPosition(newMode);
}

// 更新滑块位置
function updateSwitchPosition(mode) {
    const thumb = document.querySelector('.theme-switch-thumb');
    if (thumb) {
        // 滑块位置会在CSS中通过 .dark-mode 类自动控制
        // 这里只是确保状态同步
        console.log('主题已切换到：', mode);
    }
}

// 初始化时根据当前主题设置滑块位置
document.addEventListener('DOMContentLoaded', function() {
    const isDark = document.documentElement.classList.contains('dark-mode');
    updateSwitchPosition(isDark ? 'dark' : 'light');
});
     
// 点击弹窗外部关闭所有弹窗
document.addEventListener('click', function(event) {
    const activeOverlays = document.querySelectorAll('.overlay[style*="display: flex"]');
    
    activeOverlays.forEach(overlay => {
        // 检查点击的是否是 overlay 背景（不是弹窗内容）
        if (event.target === overlay) {
            // 先移除激活状态（如果有淡出动画）
            overlay.classList.remove('active');
            
            // 延迟隐藏
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        }
    });
});

// 阻止点击弹窗内容时关闭弹窗
document.addEventListener('click', function(event) {
    if (event.target.closest('.modal-content')) {
        event.stopPropagation();
    }
});

function regenerateAIReply() {
    if (!currentContact) return;
    
    const menu = document.getElementById('ai-context-menu');
    if (menu) menu.style.display = 'none';
    
    const history = currentContact.history;
    
    // 1. 找到最后一条用户消息的位置
    let lastUserIndex = -1;
    let userMessage = '';
    
    for (let i = history.length - 1; i >= 0; i--) {
        if (history[i].role === 'user') {
            lastUserIndex = i;
            userMessage = history[i].content;
            break;
        }
    }
    
    if (lastUserIndex === -1) {
        console.log('没有找到用户消息');
        return;
    }
    
    console.log('找到用户消息位置:', lastUserIndex, '内容:', userMessage);
    console.log('删除前的history长度:', history.length);
    
    // 2. 删除这个用户消息之后的所有AI消息（整轮AI回复）
    const aiMessagesToDelete = [];
    
    // 先找出所有要删除的AI消息索引
    for (let i = lastUserIndex + 1; i < history.length; i++) {
        if (history[i].role === 'ai') {
            aiMessagesToDelete.push(i);
        }
    }
    
    console.log('要删除的AI消息数量:', aiMessagesToDelete.length, '索引:', aiMessagesToDelete);
    
    // 从后往前删除（避免索引变化问题）
    for (let i = aiMessagesToDelete.length - 1; i >= 0; i--) {
        const indexToDelete = aiMessagesToDelete[i];
        history.splice(indexToDelete, 1);
    }
    
    console.log('删除后的history长度:', history.length);
    
    // 3. 立即保存数据
    saveData();
    
    // 4. 重新渲染界面（现在只显示到用户消息，AI消息都被删除了）
    renderMessages(history);
    
    // 5. 清除输入框（确保不会显示用户消息）
    const textarea = document.getElementById('chat-textarea');
    if (textarea) {
        textarea.value = '';
        textarea.style.height = '36px';
    }
    
        // 6. 立即重新生成AI回复
    if (!currentContact || isTyping) return;
    
    console.log('开始重新生成AI回复，用户消息:', userMessage);
    
    isTyping = true;
    const {msgDiv, bubble} = appendMessageToDOM('', 'ai', true);
    
    mockAIResponse(userMessage, currentContact).then(aiReply => {
        console.log('AI回复收到:', aiReply);
        
        bubble.classList.remove('typing-indicator');
        bubble.innerHTML = '';
        
        typeMessageInMultipleBubbles(aiReply, bubble, msgDiv).then(({sentences, fullReply}) => {
            console.log('分割后的句子:', sentences);
            
            // 保存新生成的AI回复到历史记录
            if (sentences && sentences.length > 1) {
                sentences.forEach((sentence, index) => {
                    currentContact.history.push({ 
                        role: 'ai', 
                        content: sentence,
                        isSegment: true,
                        segmentIndex: index
                    });
                });
            } else {
                currentContact.history.push({ role: 'ai', content: fullReply });
                currentContact.lastChatTime = Date.now();

            }
            
            isTyping = false;
            simulateMemorySummary(currentContact);
            saveData();
            
            console.log('重新生成完成，最终history长度:', currentContact.history.length);
        });
    }).catch(error => {
        console.error('AI生成失败:', error);
        isTyping = false;
        bubble.textContent = '重新生成失败，请重试';
    });
}

// 温度滑块实时更新
document.getElementById('temperature').addEventListener('input', function() {
    document.getElementById('temperature-value').textContent = this.value;
});

// 加载时更新滑块显示
document.addEventListener('DOMContentLoaded', function() {
    const tempSlider = document.getElementById('temperature');
    const tempValue = document.getElementById('temperature-value');
    if (tempSlider && tempValue) {
        tempValue.textContent = tempSlider.value;
    }
});

function initParamSliders() {
    const tempTrack = document.getElementById('temp-track');
    const tempThumb = document.getElementById('temp-slider-thumb');
    const tempValue = document.getElementById('temperature-value');
    const tempInput = document.getElementById('temperature');

    const tokenTrack = document.getElementById('maxTokens-track');
    const tokenThumb = document.getElementById('maxTokens-thumb');
    const tokenValue = document.getElementById('maxTokens-value');
    const tokenInput = document.getElementById('maxTokens-input');

    function setupSlider(track, thumb, display, input, min, max, isFloat) {
        if (!track || !thumb) return;
        let isDragging = false;

        const update = (clientX) => {
            const rect = track.getBoundingClientRect();
            let percent = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            let value = min + (percent / 100) * (max - min);
            
            if (isFloat) {
                value = parseFloat(value.toFixed(1));
            } else {
                // 修改点：改为更平滑的 128 步进，避免大跨度跳回
                value = Math.round(value / 128) * 128;
                if (value > max) value = max;
                if (value < min) value = min;
            }
            
            const finalPercent = ((value - min) / (max - min)) * 100;
            thumb.style.left = finalPercent + '%';
            display.textContent = value;
            input.value = value;
        };

        const onMouseDown = (e) => { isDragging = true; update(e.clientX); };
        const onMouseMove = (e) => { if (isDragging) update(e.clientX); };
        const onMouseUp = () => { isDragging = false; };
        const onTouchStart = (e) => { isDragging = true; update(e.touches[0].clientX); e.preventDefault(); };
        const onTouchMove = (e) => { if (isDragging) update(e.touches[0].clientX); };

        track.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        thumb.addEventListener('touchstart', onTouchStart, {passive: false});
        document.addEventListener('touchmove', onTouchMove, {passive: false});
        document.addEventListener('touchend', onMouseUp);

        // 初始化位置：直接从现有数据读取
        const currentVal = isFloat ? (parseFloat(input.value) || 0.7) : (parseInt(input.value) || 2048);
        const initPercent = ((currentVal - min) / (max - min)) * 100;
        thumb.style.left = initPercent + '%';
        display.textContent = currentVal;
    }

    setupSlider(tempTrack, tempThumb, tempValue, tempInput, 0.1, 2.0, true);
    setupSlider(tokenTrack, tokenThumb, tokenValue, tokenInput, 256, 4096, false);
}

// 页面加载后立即启动
document.addEventListener('DOMContentLoaded', initParamSliders);

// 计算缓存大小并更新显示
function updateCacheSize() {
    try {
        // 计算总数据大小
        const dataStr = JSON.stringify(APP_DATA);
        const dataSize = new Blob([dataStr]).size; // 字节
        
        // 转换为人性化的显示单位
        let displaySize, displayUnit;
        if (dataSize < 1024) {
            displaySize = dataSize;
            displayUnit = 'B';
        } else if (dataSize < 1024 * 1024) {
            displaySize = (dataSize / 1024).toFixed(1);
            displayUnit = 'KB';
        } else {
            displaySize = (dataSize / (1024 * 1024)).toFixed(2);
            displayUnit = 'MB';
        }
        
        // 计算进度条（假设最大5MB）
        const maxSize = 5 * 1024 * 1024; // 5MB
        const percentage = Math.min(100, (dataSize / maxSize) * 100);
        
        // 更新显示
        const sizeElement = document.getElementById('cache-size');
        const progressElement = document.getElementById('cache-progress');
        
        if (sizeElement) {
            sizeElement.textContent = `${displaySize} ${displayUnit}`;
        }
        if (progressElement) {
            progressElement.style.width = `${percentage}%`;
            
            // 根据使用率改变颜色
            if (percentage > 90) {
                progressElement.style.background = 'var(--danger-color)';
            } else if (percentage > 70) {
                progressElement.style.background = 'var(--warning-color)';
            } else {
                progressElement.style.background = 'var(--accent-color)';
            }
        }
    } catch (error) {
        console.error('计算缓存大小失败:', error);
        const sizeElement = document.getElementById('cache-size');
        if (sizeElement) {
            sizeElement.textContent = '计算失败';
        }
    }
}

// 在数据变化时更新缓存显示
function saveData() {
    console.log('保存数据到本地存储:', APP_DATA); // 调试用
    localStorage.setItem('AI_PHONE_APP_DATA', JSON.stringify(APP_DATA));
}

// 页面加载时计算缓存大小
document.addEventListener('DOMContentLoaded', function() {
    // 延迟一点确保页面加载完成
    setTimeout(updateCacheSize, 500);
});

// 在导入/导出数据后也更新显示
function exportData() {
    const dataStr = JSON.stringify(APP_DATA, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
    
    const exportFileDefaultName = 'ai_chat_data.json';
    
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
    
    alert('数据已导出为 JSON 文件');
    updateCacheSize(); // 导出后更新显示
}

function importData() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const importedData = JSON.parse(e.target.result);
                APP_DATA = importedData;
                saveData();
                alert('数据导入成功！页面将刷新');
                location.reload();
            } catch (error) {
                alert('文件格式错误，请选择正确的JSON文件');
            }
        };
        reader.readAsText(file);
    };
    
    input.click();
}

// 点击空白处退出管理模式
document.addEventListener('click', function(event) {
    if (isManageMode) {
        // 检查点击的是否是管理相关元素
        const isManageButton = event.target.closest('.manage-button');
        const isContactItem = event.target.closest('.contact-item');
        const isBatchToolbar = event.target.closest('.batch-toolbar');
        
        // 如果点击的不是这些元素，退出所有管理模式
        if (!isManageButton && !isContactItem && !isBatchToolbar) {
            // 直接退出所有模式
            isManageMode = false;
            batchMode = false;
            selectedContacts.clear();
            document.getElementById('batch-toolbar').classList.remove('show');
            renderContacts(); // 重新渲染，退出编辑模式
        }
    }
});

// 紧急修复聊天功能
function quickFixChat() {
    const textarea = document.getElementById('chat-textarea');
    if (!textarea) return;
    
    // 移除所有现有的事件监听器
    const newTextarea = textarea.cloneNode(true);
    textarea.parentNode.replaceChild(newTextarea, textarea);
    
    // 重新绑定事件
    newTextarea.addEventListener('keydown', function(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    });
    
    newTextarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });
}


// 修复回车问题的终极方案
function initChatInput() {
    const textarea = document.getElementById('chat-textarea');
    if (!textarea) {
        setTimeout(initChatInput, 100);
        return;
    }
    
    // 移除所有旧事件
    const newTextarea = textarea.cloneNode(true);
    textarea.parentNode.replaceChild(newTextarea, textarea);
    
    // 绑定回车事件 - 最简单的实现
    newTextarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            // Shift+Enter = 换行
            if (e.shiftKey) {
                return; // 允许默认行为
            }
            
            // 纯Enter = 发送
            e.preventDefault();
            
            const text = this.value.trim();
            if (text && currentContact && !isTyping) {
                // 保存文本，清空输入框
                const messageText = text;
                this.value = '';
                this.style.height = '36px';
                
                // 延迟执行，确保输入框清空
                setTimeout(() => {
                    // 手动执行发送逻辑
                    appendMessageToDOM(messageText, 'user');
                    currentContact.history.push({ role: 'user', content: messageText });
                    currentContact.lastChatTime = Date.now();

                    // AI回复
                    isTyping = true;
                    const {msgDiv, bubble} = appendMessageToDOM('', 'ai', true);
                    
        mockAIResponse(messageText, currentContact).then(aiReply => {
            bubble.classList.remove('typing-indicator');

                        bubble.innerHTML = '';
                        
                        typeMessageInMultipleBubbles(aiReply, bubble, msgDiv).then(({sentences, fullReply}) => {
                            if (sentences && sentences.length > 1) {
                                sentences.forEach((sentence, index) => {
                                    currentContact.history.push({ 
                                        role: 'ai', 
                                        content: sentence,
                                        isSegment: true,
                                        segmentIndex: index
                                    });
                                });
                            } else {
                                currentContact.history.push({ role: 'ai', content: fullReply });
                                currentContact.lastChatTime = Date.now();

                            }
                            
                            isTyping = false;
                            simulateMemorySummary(currentContact);
                            saveData();
                        });
                    });
                }, 10);
            }
        }
    });
    
    // 自动调整高度
    newTextarea.addEventListener('input', function() {
        this.style.height = 'auto';
        const height = Math.min(this.scrollHeight, 100);
        this.style.height = height + 'px';
    });
}

// 页面加载后初始化
setTimeout(initChatInput, 500);

function refreshAllData() {
    const refreshBtn = document.querySelector('.refresh-btn');
    const icon = refreshBtn?.querySelector('i');
    
// 先保存当前数据
    saveData();
        
    // 延迟后刷新整个网页
    setTimeout(() => {
        location.reload();
    }, 300);

    if (icon) {
        // 1. 点击后转几圈
        let rotation = 0;
        let circles = 0;
        const maxCircles = 1; // 转3圈
        
        const spin = () => {
            rotation += 5; 
            icon.style.transform = `rotate(${rotation}deg)`;
            
            // 每360度算一圈
            if (rotation >= 360) {
                rotation = 0;
                circles++;
            }
            
            // 转够圈数就停
            if (circles < maxCircles) {
                requestAnimationFrame(spin);
            } else {
                icon.style.transform = 'rotate(0deg)';
                // 刷新完成后提示
                setTimeout(() => {
                    alert('已刷新');
                }, 100);
            }
        };
        
        // 开始转
        spin();
        
        // 2. 执行刷新逻辑
        const savedData = localStorage.getItem('AI_PHONE_APP_DATA');
        if (savedData) {
            try {
                APP_DATA = JSON.parse(savedData);
            } catch (error) {
                console.error('数据解析失败:', error);
            }
        }
        renderContacts();
    }
}

// 监听滚动加载
document.addEventListener('DOMContentLoaded', function() {
    const messagesContainer = document.getElementById('chat-messages');
    if (messagesContainer) {
        messagesContainer.addEventListener('scroll', function() {
            // 滚动到顶部附近时加载更多
            if (this.scrollTop < 100 && currentStartIndex > 0 && !isLoadingMore) {
                loadMoreMessages();
            }
        });
    }
});

// 监听所有滚动事件关闭菜单
window.addEventListener('scroll', closeAIMenu);
document.getElementById('chat-messages')?.addEventListener('scroll', closeAIMenu);

function doCreateNewPreset() {
    // 直接打开编辑预设界面（不创建预设对象）
    const newPresetId = 'new_' + Date.now(); // 临时ID
    editPreset(newPresetId); // 使用现有的编辑函数
    
    // 在编辑界面中设置空值
    setTimeout(() => {
        const nameInput = document.getElementById('edit-preset-name');
        const urlInput = document.getElementById('edit-api-url');
        const keyInput = document.getElementById('edit-api-key');
        const modelInput = document.getElementById('edit-default-model');
        
        if (nameInput) nameInput.value = '';
        if (urlInput) urlInput.value = '';
        if (keyInput) keyInput.value = '';
        if (modelInput) modelInput.value = '';
        
        // 聚焦到预设名输入框（可选，如果不需要自动聚焦可以去掉）
        // if (nameInput) nameInput.focus();
    }, 100);
}

function refreshPresetList() {
    const list = document.getElementById('preset-list');
    
    console.log('刷新预设列表，预设数量:', APP_DATA.presets ? APP_DATA.presets.length : 0);
    
    if (!APP_DATA.presets || APP_DATA.presets.length === 0) {
        list.innerHTML = `
            <div style="text-align: center; padding: 40px; color: var(--text-color-secondary);">
                <div style="font-size: 48px; margin-bottom: 20px;">📁</div>
                <div>无预设</div>
            </div>
        `;

    } else {
        // 【新增】按最后使用时间排序（最新的在前面）
        const sortedPresets = [...APP_DATA.presets].sort((a, b) => {
            // 获取最后使用时间，如果没有则用0
            const timeA = a.lastUsedTime || 0;
            const timeB = b.lastUsedTime || 0;
            
            // 倒序排序：时间大的（新的）在前面
            return timeB - timeA;
        });
        
        // 如果有预设，显示预设列表（按排序后的顺序）
        list.innerHTML = '';
        sortedPresets.forEach(preset => {  // ← 这里改为 sortedPresets
            const div = document.createElement('div');
            div.style.cssText = `
                padding: 12px 15px; margin-bottom: 8px; border-radius: 10px;
                background: var(--input-bg); border: 1px solid var(--input-border);
                position: relative;
                min-height: 60px; /* 固定最小高度 */
            `;
            
            // 主内容区域（点击选择）
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
                cursor: pointer;
                margin-right: 70px; /* 给按钮留空间 */
            `;
            
            contentDiv.innerHTML = `
                <div style="font-weight: bold; color: var(--text-color-primary); font-size: 17px;">
                    ${preset.name}
                </div>
                <div style="font-size: 14px; color: var(--accent-color); margin-top: 8px;">
                    ${preset.defaultModel || '无模型'}
                </div>
            `;
            
            contentDiv.onclick = function() {
    console.log('选择预设:', preset.name);
    
    // 检查是否是补全API模式
    const modal = document.getElementById('preset-modal');
    const isBackfillMode = modal.dataset.mode === 'backfill';
    
    if (isBackfillMode) {
        // 补全API模式：应用到补全API区域
        APP_DATA.currentBackfillPresetId = preset.id;
        document.getElementById('backfill-preset-display').value = preset.name;
        
        // 显示模型选择框
        const backfillModelContainer = document.getElementById('backfill-current-preset-model-container');
        if (backfillModelContainer) {
            backfillModelContainer.style.display = 'block';
            document.getElementById('backfill-current-preset-model').value = preset.defaultModel || '';
        }
        
        // 恢复弹窗标题
        const title = modal.querySelector('h4');
        if (title && title.dataset.originalText) {
            title.textContent = title.dataset.originalText;
        }
        
        // 清除模式标记
        modal.dataset.mode = '';
        window.isBackfillMode = false;
    } else {
        // 主API模式：应用到主API区域
        loadPreset(preset.id);
        document.getElementById('api-preset-display').value = preset.name;
        
        const apiFieldsContainer = document.getElementById('api-fields-container');
        if (apiFieldsContainer) {
            apiFieldsContainer.style.display = 'none';
        }
        document.getElementById('save-preset-btn').style.display = 'none';
    }
    
    // 关闭弹窗
    hideModal('preset-modal');
    saveData();
    
    console.log('已选择预设:', preset.name, '模式:', isBackfillMode ? '补全API' : '主API');
};
            
            div.appendChild(contentDiv);
            
            // 操作按钮容器
            const actionsDiv = document.createElement('div');
                        actionsDiv.style.cssText = `
                position: absolute;
                right: 10px;
                top: 50%;  /* 垂直居中 */
                transform: translateY(-50%);  /* 垂直居中 */
                display: flex;
                gap: 6px;
            `;
            
            // 编辑按钮
            const editBtn = document.createElement('button');
            editBtn.innerHTML = '✎';
            editBtn.style.cssText = `
                width: 30px;
                height: 30px;
                border-radius: 6px;
                background: var(--accent-color);
                color: white;
                border: none;
                cursor: pointer;
                font-size: 14px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            editBtn.title = '编辑预设';
            editBtn.onclick = function(e) {
                e.stopPropagation(); // 阻止冒泡，避免触发选择
                editPreset(preset.id);
            };
            
            // 删除按钮
            const deleteBtn = document.createElement('button');
            deleteBtn.innerHTML = '×';
            deleteBtn.style.cssText = `
                width: 30px;
                height: 30px;
                border-radius: 6px;
                background: var(--danger-color);
                color: white;
                border: none;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            deleteBtn.title = '删除预设';
            deleteBtn.onclick = function(e) {
                e.stopPropagation(); // 阻止冒泡
                deletePreset(preset.id);
            };
            
            actionsDiv.appendChild(editBtn);
            actionsDiv.appendChild(deleteBtn);
            div.appendChild(actionsDiv);
            
            list.appendChild(div);
        });
    }

// 【新增】确保列表滚动到顶部
    setTimeout(() => {
        if (list) {
            list.scrollTop = 0;
        }
    }, 50);
}

function openPresetManager() {
    // 显示弹窗
    const modal = document.getElementById('preset-modal');
    modal.style.display = 'flex';
    modal.offsetWidth; // 触发重排
    modal.classList.add('active');
    
    // 然后刷新预设列表
    refreshPresetList();
}


// 显示模型选择弹窗
function showModelSelectDialog(models) {
    // 创建弹窗
    const modal = document.createElement('div');
    modal.id = 'model-select-modal';
    modal.className = 'overlay';
    modal.style.display = 'flex';
    modal.style.zIndex = '2000';
    
    modal.innerHTML = `
    <div style="
        background: var(--bg-color-secondary); 
        border-radius: 20px; 
        width: 90vw;
        max-width: 420px; 
        height: 80vh;
        max-height: 700px;
        display: flex; 
        flex-direction: column; 
        overflow: hidden;
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    ">
        <!-- 标题 -->
        <div style="
            padding: 24px 24px 16px 24px; 
            flex-shrink: 0;
        ">
            <h4 style="
                margin: 0; 
                color: var(--text-color-primary);
                font-size: 20px;
                font-weight: 600;
                text-align: center;
            ">
                选择模型 (${models.length}个)
            </h4>
        </div>
        
        <!-- 搜索框 - 左右有边距 -->
        <div style="
            padding: 0 24px 16px 24px; 
            flex-shrink: 0;
        ">
            <input type="text" id="model-search-input" 
                   placeholder="搜索模型..." 
                   style="
                        width: 100%; 
                        padding: 15px 18px;
                        border-radius: 14px; 
                        border: 1px solid var(--input-border); 
                        background: var(--input-bg); 
                        color: var(--text-color-primary);
                        font-size: 16px;
                        box-sizing: border-box;
                        outline: none;
                   ">
        </div>
        
        <!-- 模型列表容器 - 关键：独立滚动区域 -->
        <div style="
            flex: 1; 
            overflow: hidden;
            position: relative;
            margin: 0 24px;
            background: var(--bg-color-secondary);
            border-radius: 12px;
        ">
            <div id="model-items-container" style="
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                overflow-y: auto;
                overflow-x: hidden;
                scrollbar-width: none;
                -ms-overflow-style: none;
                -webkit-overflow-scrolling: touch;
                padding: 0 12px 100px 12px; /* 底部100px确保不被遮挡 */
            ">
                <!-- 模型列表在这里 -->
            </div>
        </div>
        
        <!-- 底部按钮 - 绝对定位在容器外 -->
        <div style="
            padding: 20px 24px 24px 24px; 
            flex-shrink: 0;
            background: var(--bg-color-secondary);
            border-top: 1px solid var(--input-border);
        ">
            <button onclick="document.getElementById('model-list-modal').remove()" 
                    style="
                        width: 100%; 
                        padding: 18px; 
                        border-radius: 14px;
                        background: var(--input-bg); 
                        color: var(--text-color-primary);
                        border: 1px solid var(--input-border);
                        font-size: 17px;
                        font-weight: 500;
                        cursor: pointer;
                    ">
                取消
            </button>
        </div>
    </div>
`;
    
    document.body.appendChild(modal);
    
    // 填充模型列表
    const container = document.getElementById('model-list-container');
    renderModelList(models, container);
    
    // 搜索功能
    const searchInput = document.getElementById('model-search');
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => {
            const modelId = (model.id || model).toLowerCase();
            return modelId.includes(searchTerm);
        });
        renderModelList(filteredModels, container);
    });
    
    // 点击外部关闭
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            modal.remove();
        }
    });
    
   
}

// 渲染模型列表
function renderModelList(models, container) {
    container.innerHTML = '';
    
    if (models.length === 0) {
        container.innerHTML = `
            <div style="padding: 30px; text-align: center; color: var(--text-color-secondary);">
                未找到匹配的模型
            </div>
        `;
        return;
    }
    
    models.forEach((model, index) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop(); // 取最后一部分
        
        const item = document.createElement('div');
        item.className = 'model-item';
        item.style.cssText = `
            padding: 18px 20px; 
            margin: 0 auto 12px auto; 
            border-radius: 14px;
            border: 1px solid var(--input-border); 
            cursor: pointer;
            background: var(--input-bg); 
            transition: all 0.2s;
            width: 100%; 
            max-width: 100%; 
            box-sizing: border-box;
            word-break: break-word;
            text-align: left;
            display: block;
        `;

        item.innerHTML = `
            <div style="
                font-weight: 600; 
                color: var(--text-color-primary);
                font-size: 17px;
                margin-bottom: 8px;
                text-align: left;
            ">
                ${displayName}
            </div>
            <div style="
                font-size: 14px; 
                color: var(--text-color-secondary); 
                line-height: 1.4;
                text-align: left;
                opacity: 0.8;
            ">
                ${modelId}
            </div>
        `;
        
        item.onclick = function() {
            document.getElementById('ai-model').value = modelId;
            document.getElementById('model-select-modal').remove();
        };
        
        item.addEventListener('mouseenter', function() {
            this.style.backgroundColor = 'var(--input-bg)';
        });
        
        item.addEventListener('mouseleave', function() {
            this.style.backgroundColor = '';
        });
        
        container.appendChild(item);
    });
}

async function openModelSelector() {
    // 先检查API信息
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    
    if (!apiUrl || !apiKey) {
        alert('请先填写API URL和API Key');
        return;
    }
    
    // 显示加载弹窗
    const loadingModal = document.createElement('div');
    loadingModal.id = 'loading-model-modal';
    loadingModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
    `;
    
    loadingModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); padding: 30px; border-radius: 16px; 
                    min-width: 200px; text-align: center;">
            <div style="margin-bottom: 15px;">
                <i class="fa-solid fa-spinner fa-spin" style="font-size: 24px;"></i>
            </div>
            <div>正在获取模型列表...</div>
        </div>
    `;
    
    document.body.appendChild(loadingModal);
    
    try {
        // 尝试获取模型列表
        const models = await fetchModelList(apiUrl, apiKey);
        
        // 移除加载弹窗
        loadingModal.remove();
        
        if (models.length === 0) {
            // 获取失败，显示手动输入
            showManualInputModal();
        } else {
            // 显示模型选择列表
            showModelListModal(models);
        }
        
    } catch (error) {
        // 移除加载弹窗
        loadingModal.remove();
        
        console.error('获取模型失败:', error);
        
        // 更友好的错误提示
        let errorMsg = '获取模型失败: ' + error.message;
        if (error.message.includes('无法找到可用的模型列表端点')) {
            errorMsg = '无法自动获取模型列表。\n\n可能原因：\n1. 该API提供商不支持自动获取模型列表\n2. 模型列表端点与标准OpenAI格式不同\n3. 需要手动输入模型名称';
        }
        
        alert(errorMsg);
        // 显示手动输入
        showManualInputModal();
    }
}

// 获取模型列表
async function fetchModelList(apiUrl, apiKey) {
    console.log('开始获取模型列表，API URL:', apiUrl);
    
    // 尝试多种可能的模型列表端点
    const possibleEndpoints = [];
    
    // 1. 从聊天URL推断模型列表URL
    if (apiUrl.includes('/chat/completions')) {
        // 尝试替换为 /models
        possibleEndpoints.push(apiUrl.replace('/chat/completions', '/models'));
        // 尝试替换为 /v1/models
        possibleEndpoints.push(apiUrl.replace('/v1/chat/completions', '/v1/models'));
        // 尝试移除路径部分
        const baseUrl = apiUrl.split('/chat/completions')[0];
        possibleEndpoints.push(baseUrl + '/models');
        possibleEndpoints.push(baseUrl + '/v1/models');
    }
    
    // 2. 添加一些常见公益站的特定端点
    if (apiUrl.includes('openrouter.ai')) {
        possibleEndpoints.push('https://openrouter.ai/api/v1/models');
    }
    if (apiUrl.includes('api.openai.com')) {
        possibleEndpoints.push('https://api.openai.com/v1/models');
    }
    
    // 3. 最后尝试直接使用 /models
    possibleEndpoints.push(apiUrl.replace(/\/chat\/completions.*$/, '') + '/models');
    
    // 去重
    const uniqueEndpoints = [...new Set(possibleEndpoints.filter(url => url && url !== apiUrl))];
    
    console.log('尝试的端点列表:', uniqueEndpoints);
    
    let lastError = null;
    
    // 尝试每个可能的端点
    for (const modelsUrl of uniqueEndpoints) {
        try {
            console.log(`尝试端点: ${modelsUrl}`);
            
            const response = await fetch(modelsUrl, {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                timeout: 8000 // 8秒超时
            });
            
            if (!response.ok) {
                console.log(`端点 ${modelsUrl} 返回错误: ${response.status}`);
                continue; // 尝试下一个端点
            }
            
            const data = await response.json();
            console.log('获取到的原始数据:', data);
            
            // 多种格式的模型列表提取
            let models = [];
            
            if (Array.isArray(data)) {
                models = data;
            } else if (data.data && Array.isArray(data.data)) {
                models = data.data;
            } else if (data.models && Array.isArray(data.models)) {
                models = data.models;
            } else if (data.result && Array.isArray(data.result)) {
                models = data.result; // 有些API用result字段
            }
            
            // 提取模型ID
            const modelList = models.map(item => {
                if (typeof item === 'string') {
                    return { id: item };
                } else if (item.id) {
                    return { id: item.id };
                } else if (item.model) {
                    return { id: item.model }; // 有些用model字段
                }
                return null;
            }).filter(item => item && item.id);
            
            console.log(`成功从 ${modelsUrl} 获取到 ${modelList.length} 个模型`);
            
            if (modelList.length > 0) {
                return modelList;
            }
            
        } catch (error) {
            console.log(`端点 ${modelsUrl} 失败:`, error.message);
            lastError = error;
            continue; // 继续尝试下一个
        }
    }
    
    // 所有端点都失败了
    throw new Error(lastError ? `获取模型列表失败: ${lastError.message}` : '无法找到可用的模型列表端点');
}

// 为fetch添加timeout支持
if (!fetch.timeout) {
    fetch.timeout = function(resource, options = {}) {
        const { timeout = 8000 } = options;
        
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        
        return fetch(resource, {
            ...options,
            signal: controller.signal
        }).then(response => {
            clearTimeout(id);
            return response;
        }).catch(error => {
            clearTimeout(id);
            throw error;
        });
    };
}
// 显示模型列表弹窗
function showModelListForEdit(models) {
    const modal = document.createElement('div');
    modal.id = 'model-list-edit-modal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    modal.innerHTML = `
    <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                width: 100%; max-width: 320px; max-height: 70vh;
                display: flex; flex-direction: column;">
        <div style="padding: 20px; border-bottom: 1px solid var(--input-border);">
            <h4 style="margin: 0; color: var(--text-color-primary);">选择模型 (${models.length}个)</h4>
        </div>
        
        <div style="padding: 15px; flex: 1; overflow-y: auto;">
            <input type="text" id="model-search-edit-input" 
                   placeholder="搜索模型..." 
                   style="width: 90%; padding: 10px 15px; margin: 0 auto 15px auto;
                          border-radius: 10px; border: 1px solid var(--input-border); 
                          background: var(--input-bg); color: var(--text-color-primary);
                          display: block;">
            
            <div id="model-items-edit-container" style="max-height: 50vh; overflow-y: auto;">
                <!-- 模型列表会在这里动态生成 -->
            </div>
        </div>
        
        <div style="padding: 15px; border-top: 1px solid var(--input-border); text-align: center;">
            <button onclick="document.getElementById('model-list-edit-modal').remove()" 
                    style="padding: 10px 20px; border-radius: 8px;
                           background: var(--input-bg); color: var(--text-color-primary);
                           border: 1px solid var(--input-border); cursor: pointer;">
                取消
            </button>
        </div>
    </div>
    `;
    
    document.body.appendChild(modal);
    
    // 填充模型列表
    renderModelsForEdit(models);
    
    // 搜索功能
    const searchInput = document.getElementById('model-search-edit-input');
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => {
            const modelId = (model.id || model).toLowerCase();
            return modelId.includes(searchTerm);
        });
        renderModelsForEdit(filteredModels);
    });
    
    // 点击外部关闭
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            modal.remove();
        }
    });
    
    
}

function renderModelsForEdit(models) {
    const container = document.getElementById('model-items-edit-container');
    container.innerHTML = '';
    
    if (models.length === 0) {
        container.innerHTML = `
            <div style="padding: 30px; text-align: center; color: var(--text-color-secondary);">
                未找到匹配的模型
            </div>
        `;
        return;
    }
    
    models.forEach((model) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop();
        
        const item = document.createElement('div');
        item.style.cssText = `
            padding: 12px 15px; margin: 0 10px 8px 10px; border-radius: 10px;
            border: 1px solid var(--input-border); cursor: pointer;
            background: var(--input-bg); transition: all 0.2s;
            width: calc(100% - 20px);
            box-sizing: border-box;
            overflow: hidden;
            word-break: break-word;
        `;
        
        item.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary);">
                ${displayName}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px;">
                ${modelId}
            </div>
        `;
        
        item.onclick = function() {
            // 更新编辑弹窗中的模型输入框
            document.getElementById('edit-default-model').value = modelId;
            // 关闭模型选择弹窗
            document.getElementById('model-list-edit-modal').remove();
        };
        
        // 悬停效果
        item.addEventListener('mouseenter', function() {
            this.style.backgroundColor = 'rgba(var(--accent-color-rgb), 0.1)';
            this.style.borderColor = 'var(--accent-color)';
        });
        
        item.addEventListener('mouseleave', function() {
            this.style.backgroundColor = '';
            this.style.borderColor = '';
        });
        
        container.appendChild(item);
    });
}

// 显示手动输入弹窗（备用）
function showManualInputModal() {
    const modelName = prompt('请输入模型名称（例如：qwen-72b-chat）:', 
                            document.getElementById('ai-model').value);
    if (modelName && modelName.trim()) {
        document.getElementById('ai-model').value = modelName.trim();
    }
}

function editPreset(presetId) {
    const isNewPreset = presetId.toString().startsWith('new_');
    let preset;
    
    if (isNewPreset) {
        // 新建模式，创建临时预设对象
        preset = {
            id: presetId,
            name: '',
            apiUrl: '',
            apiKey: '',
            defaultModel: ''
        };
    } else {
        // 编辑现有预设
        preset = APP_DATA.presets.find(p => p.id == presetId);
    }
    
    if (!preset) return;    
    // 先关闭API弹窗，等待动画完成
    const presetModal = document.getElementById('preset-modal');
    if (presetModal && presetModal.style.display === 'flex') {
        // 开始关闭动画
        presetModal.classList.remove('active');
        
                // 【立即创建编辑弹窗，不要等待！】
        const editModal = document.createElement('div');
        editModal.id = 'edit-preset-modal';
        editModal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
            
            editModal.innerHTML = `
    <div style="
        background: var(--bg-color-secondary);
        border-radius: 16px;
        padding: 20px;  // 内边距也改小一点
        width: 90%;
        max-width: 300px;  // 改这里，更小一点
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    ">
                    <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">
            ${isNewPreset ? '新建配置' : '编辑配置'}
        </h4>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                            配置名称
                        </label>
                        <input type="text" id="edit-preset-name" 
                               style="width: 100%; padding: 12px; border-radius: 8px; 
                                      border: 1px solid var(--input-border); 
                                      background: var(--input-bg); color: var(--text-color-primary);
                                      cursor: pointer; box-sizing: border-box;"
                               value="${preset.name || ''}">
                    </div>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                            API URL
                        </label>
                        <input type="text" id="edit-api-url" 
                               style="width: 100%; padding: 12px; border-radius: 8px; 
                                      border: 1px solid var(--input-border); 
                                      background: var(--input-bg); color: var(--text-color-primary);
                                      cursor: pointer; box-sizing: border-box;"
                               value="${preset.apiUrl || ''}">
                    </div>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                            API Key
                        </label>
                        <input type="password" id="edit-api-key" 
                               style="width: 100%; padding: 12px; border-radius: 8px; 
                                      border: 1px solid var(--input-border); 
                                      background: var(--input-bg); color: var(--text-color-primary);
                                      cursor: pointer; box-sizing: border-box;"
                               value="${preset.apiKey || ''}">
                    </div>
                    
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                            模型
                        </label>
                        <input type="text" id="edit-default-model" readonly
                               style="width: 100%; padding: 12px; border-radius: 8px; 
                                      border: 1px solid var(--input-border); 
                                      background: var(--input-bg); color: var(--text-color-primary);
                                      cursor: pointer; box-sizing: border-box;"
                               value="${preset.defaultModel || ''}"
                               placeholder="点击选择模型"
                               onclick="openModelSelectorForEdit()">
                    </div>
                    
                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button onclick="closeEditPresetModal()"
                                style="padding: 10px 20px; border-radius: 8px; 
                                       background: var(--input-bg); color: var(--text-color-primary);
                                       border: 1px solid var(--input-border); cursor: pointer;">
                            取消
                        </button>
                        <button onclick="savePresetEdit('${presetId}')"
                                style="padding: 10px 20px; border-radius: 8px; 
                                       background: var(--accent-color); color: white;
                                       border: none; cursor: pointer;">
                            保存
                        </button>
                    </div>
                </div>
            `;
            
            // 延迟一点开始淡入（和API弹窗淡出同时）
        setTimeout(() => {
            editModal.style.opacity = '1';
        }, 10);

            document.body.appendChild(editModal);
            
            // 点击外部关闭
            editModal.addEventListener('click', function(e) {
                if (e.target === editModal) {
                    closeEditPresetModal();
                }
            });
            
         // 等待动画完成后隐藏API弹窗
        setTimeout(() => {
            presetModal.style.display = 'none';
        }, 300);
        
    } else {
        // 如果API弹窗本来就没显示，直接创建编辑弹窗
        const editModal = document.createElement('div');
        editModal.id = 'edit-preset-modal';
        editModal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: modalFadeIn 0.3s ease;
        `;
        
        editModal.innerHTML = `
            <div style="
                background: var(--bg-color-secondary);
                border-radius: 16px;
                padding: 24px;
                width: 90%;
                max-width: 350px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            ">
                <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">
                    编辑
                </h4>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                        配置名称
                    </label>
                    <input type="text" id="edit-preset-name" 
                           style="width: 100%; padding: 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  cursor: pointer; box-sizing: border-box;"
                           value="${preset.name || ''}">
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                        API URL
                    </label>
                    <input type="text" id="edit-api-url" 
                           style="width: 100%; padding: 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  cursor: pointer; box-sizing: border-box;"
                           value="${preset.apiUrl || ''}">
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                        API Key
                    </label>
                    <input type="password" id="edit-api-key" 
                           style="width: 100%; padding: 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  cursor: pointer; box-sizing: border-box;"
                           value="${preset.apiKey || ''}">
                </div>
                
                <div style="margin-bottom: 24px;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                        模型
                    </label>
                    <input type="text" id="edit-default-model" readonly
                           style="width: 100%; padding: 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  cursor: pointer; box-sizing: border-box;"
                           value="${preset.defaultModel || ''}"
                           placeholder="点击选择模型"
                           onclick="openModelSelectorForEdit()">
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button onclick="closeEditPresetModal()"
                            style="padding: 10px 20px; border-radius: 8px; 
                                   background: var(--input-bg); color: var(--text-color-primary);
                                   border: 1px solid var(--input-border); cursor: pointer;">
                        取消
                    </button>
                    <button onclick="savePresetEdit('${presetId}')"
                            style="padding: 10px 20px; border-radius: 8px; 
                                   background: var(--accent-color); color: white;
                                   border: none; cursor: pointer;">
                        保存
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(editModal);
        
        // 点击外部关闭
        editModal.addEventListener('click', function(e) {
            if (e.target === editModal) {
                closeEditPresetModal();
            }
        });
    }
}

function savePresetEdit(presetId) {
    const isNewPreset = presetId.toString().startsWith('new_');
    let preset;
    
    if (isNewPreset) {
        // 新建配置
        preset = {
            id: Date.now(),
            name: '',
            apiUrl: '',
            apiKey: '',
            defaultModel: ''
        };
        APP_DATA.presets.push(preset);
    } else {
        // 编辑现有配置
        preset = APP_DATA.presets.find(p => p.id == presetId);
    }
    
    if (!preset) return;
    
    const name = document.getElementById('edit-preset-name').value.trim();
    const apiUrl = document.getElementById('edit-api-url').value.trim();
    const apiKey = document.getElementById('edit-api-key').value.trim();
    const defaultModel = document.getElementById('edit-default-model').value.trim();
    
    if (!name) {
        alert('配置名称不能为空');
        return;
    }
    
    if (!apiUrl || !apiKey) {
        alert('API URL 和 API Key 不能为空');
        return;
    }
    
    // 更新预设信息
    preset.name = name;
    preset.apiUrl = apiUrl;
    preset.apiKey = apiKey;
    preset.defaultModel = defaultModel;
    
// 【新增】如果是当前选中的预设，更新使用时间
    if (APP_DATA.currentPresetId === preset.id) {
        preset.lastUsedTime = Date.now();
}
    // 如果是新建的预设并且没有当前预设，就设为当前
    if (isNewPreset && !APP_DATA.currentPresetId) {
        APP_DATA.currentPresetId = preset.id;
        document.getElementById('api-preset-display').value = preset.name;
        
        // 同步到settings
        APP_DATA.settings.apiUrl = apiUrl;
        APP_DATA.settings.apiKey = apiKey;
        APP_DATA.settings.aiModel = defaultModel;
    }
    
    // 保存数据
    saveData();
    
    // 移除编辑弹窗
    const editModal = document.getElementById('edit-preset-modal');
    if (editModal) {
        editModal.style.opacity = '0';
        editModal.style.transition = 'opacity 0.3s ease';
        
        // 等待动画完成
        setTimeout(() => {
            if (editModal && editModal.parentNode) {
                editModal.remove();
            }
            
            // 刷新预设列表
            refreshPresetList();
            
            // 显示API弹窗
            showModal('preset-modal');
            
            // 显示成功消息
            setTimeout(() => {
                alert(isNewPreset ? '配置创建成功！' : '配置已更新');
            }, 100);
            
        }, 300);
    } else {
        refreshPresetList();
        showModal('preset-modal');
        alert(isNewPreset ? '配置创建成功！' : '配置已更新');
    }
}


function deletePreset(presetId) {
    const preset = APP_DATA.presets.find(p => p.id == presetId);
    if (!preset) return;
    
    if (!confirm(`确定要删除配置 "${preset.name}" 吗？此操作不可撤销。`)) {
        return;
    }
    
    // 如果要删除的是当前选中的预设
    if (APP_DATA.currentPresetId === presetId) {
        // 清除当前预设
        APP_DATA.currentPresetId = null;
        
        // 显示API输入字段
        document.getElementById('api-fields-container').style.display = 'block';
        document.getElementById('api-preset-display').value = '新建配置';
        document.getElementById('save-preset-btn').style.display = 'block';
        
        // 清空输入框
        document.getElementById('api-url').value = '';
        document.getElementById('api-key').value = '';
        document.getElementById('ai-model').value = '';
    }
    
    // 从数组中删除
    APP_DATA.presets = APP_DATA.presets.filter(p => p.id !== presetId);
    
    // 如果删除后没有预设了，确保预设数组存在
    if (APP_DATA.presets.length === 0) {
        APP_DATA.presets = [];
    }
    
    // 保存数据
    saveData();
    
    // 刷新预设列表
    refreshPresetList();
    
    alert('配置已删除');
}

async function openModelSelectorForEdit() {
    // 获取当前编辑弹窗中的API信息
    const apiUrl = document.getElementById('edit-api-url').value.trim();
    const apiKey = document.getElementById('edit-api-key').value.trim();
    
    if (!apiUrl || !apiKey) {
        alert('请先填写API URL和API Key');
        return;
    }
    
    // 显示加载弹窗
    const loadingModal = document.createElement('div');
    loadingModal.id = 'loading-edit-model-modal';
    loadingModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
    `;
    
    loadingModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); padding: 30px; border-radius: 16px; 
                    min-width: 200px; text-align: center;">
            <div style="margin-bottom: 15px;">
                <i class="fa-solid fa-spinner fa-spin" style="font-size: 24px;"></i>
            </div>
            <div>正在获取模型列表...</div>
        </div>
    `;
    
    document.body.appendChild(loadingModal);
    
    try {
        // 获取模型列表
        const models = await fetchModelList(apiUrl, apiKey);
        
        // 移除加载弹窗
        loadingModal.remove();
        
        if (models.length === 0) {
            alert('未获取到模型列表，请手动输入模型名称');
            return;
        }
        
        // 显示模型选择弹窗
        showModelListForEdit(models);
    } catch (error) {
        // 移除加载弹窗
        loadingModal.remove();
        
        console.error('获取模型失败:', error);
        
        let errorMsg = '获取模型失败: ' + error.message;
        if (error.message.includes('无法找到可用的模型列表端点')) {
            errorMsg = '无法自动获取模型列表。\n\n请手动输入模型名称，或检查：\n1. API URL是否正确\n2. API Key是否有权限\n3. 该API是否支持模型列表查询';
        }
        
        alert(errorMsg);
    }
}



function showModelListForEdit(models, presetId) {
    const modal = document.createElement('div');
    modal.id = 'model-list-edit-modal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    modal.innerHTML = `
    <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                width: 100%; max-width: 320px; max-height: 70vh;
                display: flex; flex-direction: column;">
        <div style="padding: 20px; border-bottom: 1px solid var(--input-border);">
            <h4 style="margin: 0; color: var(--text-color-primary);">选择模型 (${models.length}个)</h4>
        </div>
        
        <div style="padding: 15px; flex: 1; overflow-y: auto;">
            <input type="text" id="model-search-edit-input" 
                   placeholder="搜索模型..." 
                   style="width: 90%; padding: 10px 15px; margin: 0 auto 15px auto;
                          border-radius: 10px; border: 1px solid var(--input-border); 
                          background: var(--input-bg); color: var(--text-color-primary);
                          display: block;">
            
            <div id="model-items-edit-container">
                <!-- 模型列表会在这里动态生成 -->
            </div>
        </div>
    </div>
    `;
    
    document.body.appendChild(modal);
    
    // 填充模型列表
    renderModelsForEdit(models, presetId);
    
    // 搜索功能
    const searchInput = document.getElementById('model-search-edit-input');
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => {
            const modelId = (model.id || model).toLowerCase();
            return modelId.includes(searchTerm);
        });
        renderModelsForEdit(filteredModels, presetId);
    });
    
    // 点击外部关闭
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            modal.remove();
        }
    });
    
    
}

function renderModelsForEdit(models, presetId) {
    const container = document.getElementById('model-items-edit-container');
    container.innerHTML = '';
    
    if (models.length === 0) {
        container.innerHTML = `
            <div style="padding: 30px; text-align: center; color: var(--text-color-secondary);">
                未找到匹配的模型
            </div>
        `;
        return;
    }
    
    models.forEach((model) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop();
        
        const item = document.createElement('div');
        item.style.cssText = `
            padding: 12px 15px; margin: 0 10px 8px 10px; border-radius: 10px;
            border: 1px solid var(--input-border); cursor: pointer;
            background: var(--input-bg); transition: all 0.2s;
            width: calc(100% - 20px);
            box-sizing: border-box;
            overflow: hidden;
            word-break: break-word;
        `;
        
        item.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary);">
                ${displayName}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px;">
                ${modelId}
            </div>
        `;
        
        item.onclick = function() {
            // 更新编辑弹窗中的模型输入框
            document.getElementById('edit-default-model').value = modelId;
            // 关闭模型选择弹窗
            document.getElementById('model-list-edit-modal').remove();
        };
        
        container.appendChild(item);
    });
}

// 测试公益站API的辅助函数
function testPublicAPI(apiUrl, apiKey, modelName) {
    console.log("测试公益站API:", { apiUrl, apiKey, modelName });
    
    // 创建一个测试弹窗
    const testModal = document.createElement('div');
    testModal.id = 'test-api-modal';
    testModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
    `;
    
    testModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); border-radius: 16px; padding: 24px; 
                    width: 90%; max-width: 400px;">
            <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">
                测试API连接
            </h4>
            
            <div id="test-status" style="margin-bottom: 20px;">
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <i class="fa-solid fa-spinner fa-spin" style="margin-right: 10px;"></i>
                    <span>正在测试连接...</span>
                </div>
                <div id="test-details" style="font-size: 13px; color: var(--text-color-secondary);">
                    
                </div>
            </div>
            
            <div style="text-align: center;">
                <button onclick="document.getElementById('test-api-modal').remove()" 
                        style="padding: 10px 20px; border-radius: 8px;
                               background: var(--accent-color); color: white;
                               border: none; cursor: pointer;">
                    关闭
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(testModal);
    
    // 执行测试
    setTimeout(async () => {
        const statusEl = document.getElementById('test-status');
        const detailsEl = document.getElementById('test-details');
        
        try {
            // 测试1：获取模型列表
            detailsEl.innerHTML = '1. 正在获取模型列表...';
            const models = await fetchModelList(apiUrl, apiKey);
            
            detailsEl.innerHTML += `<br>✓ 成功获取到 ${models.length} 个模型`;
            
            // 测试2：发送测试请求
            detailsEl.innerHTML += '<br>2. 正在发送测试消息...';
            
            const testResponse = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: modelName || models[0]?.id,
                    messages: [{ role: 'user', content: 'Hello' }],
                    max_tokens: 10
                })
            });
            
            if (testResponse.ok) {
                const data = await testResponse.json();
                detailsEl.innerHTML += '<br>✓ API响应正常';
                
                statusEl.innerHTML = `
                    <div style="color: #07C160;">
                        <i class="fa-solid fa-check-circle" style="margin-right: 10px;"></i>
                        <span>API连接测试成功！</span>
                    </div>
                `;
            } else {
                detailsEl.innerHTML += `<br>✗ API响应错误: ${testResponse.status}`;
                statusEl.innerHTML = `
                    <div style="color: #C26D5E;">
                        <i class="fa-solid fa-times-circle" style="margin-right: 10px;"></i>
                        <span>API响应错误</span>
                    </div>
                `;
            }
            
        } catch (error) {
            detailsEl.innerHTML += `<br>✗ 测试失败: ${error.message}`;
            statusEl.innerHTML = `
                <div style="color: #C26D5E;">
                    <i class="fa-solid fa-times-circle" style="margin-right: 10px;"></i>
                    <span>API连接失败</span>
                </div>
            `;
        }
    }, 100);
}

function closeEditPresetModal() {
    const editModal = document.getElementById('edit-preset-modal');
    
    if (editModal) {
        // 淡出效果
        editModal.style.opacity = '0';
        editModal.style.transition = 'opacity 0.3s ease';
        
        // 等待动画完成后移除
        setTimeout(() => {
            if (editModal && editModal.parentNode) {
                editModal.remove();
            }
            
            // 显示API弹窗
            showModal('preset-modal');
        }, 300);
    } else {
        showModal('preset-modal');
    }
}

// 强制关闭所有弹窗
function forceCloseAllModals() {
    // 关闭所有.overlay弹窗
    document.querySelectorAll('.overlay').forEach(modal => {
        modal.style.display = 'none';
        modal.classList.remove('active');
    });
    
    // 关闭动态创建的弹窗
    const dynamicModals = [
        'edit-preset-modal',
        'model-list-modal', 
        'model-list-edit-modal',
        'loading-model-modal',
        'loading-edit-model-modal'
    ];
    
    dynamicModals.forEach(id => {
        const modal = document.getElementById(id);
        if (modal) modal.remove();
    });
    
    // 确保预设弹窗显示正常
    const presetModal = document.getElementById('preset-modal');
    if (presetModal) {
        presetModal.style.display = 'none';
        presetModal.classList.remove('active');
    }
    
    console.log('已强制关闭所有弹窗');
}

function selectPreset(presetId) {
    const apiFieldsContainer = document.getElementById('api-fields-container');
    const modelContainer = document.getElementById('current-preset-model-container');
    
    if (presetId === 'new') {
        // 新建配置模式
        document.getElementById('api-preset-display').value = '新建配置';
        document.getElementById('api-url').value = '';
        document.getElementById('api-key').value = '';
        document.getElementById('ai-model').value = '';
        
        // 【新增】隐藏当前预设模型选择框
        if (modelContainer) {
            modelContainer.style.display = 'none';
        }
        
        // 显示API输入字段（新建配置模式）
        if (apiFieldsContainer) {
            apiFieldsContainer.style.display = 'block';
        }
        
        document.getElementById('save-preset-btn').style.display = 'block';
        APP_DATA.currentPresetId = null;
    } else {
        // 加载现有预设
        loadPreset(presetId);
    }
}

// 打开当前预设的模型选择器
async function openCurrentPresetModelSelector() {
    if (!APP_DATA.currentPresetId) {
        alert('请先选择一个预设');
        return;
    }
    
    const preset = APP_DATA.presets.find(p => p.id == APP_DATA.currentPresetId);
    if (!preset) {
        alert('预设不存在');
        return;
    }
    
    const apiUrl = preset.apiUrl || '';
    const apiKey = preset.apiKey || '';
    
    if (!apiUrl || !apiKey) {
        alert('请先在编辑预设中填写API URL和API Key');
        return;
    }
    
    // 显示加载弹窗
    const loadingModal = document.createElement('div');
    loadingModal.id = 'loading-current-model-modal';
    loadingModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
    `;
    
    loadingModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); padding: 30px; border-radius: 16px; 
                    min-width: 200px; text-align: center;">
            <div style="margin-bottom: 15px;">
                <i class="fa-solid fa-spinner fa-spin" style="font-size: 24px;"></i>
            </div>
            <div>正在获取模型列表...</div>
        </div>
    `;
    
    document.body.appendChild(loadingModal);
    
    try {
        // 获取模型列表
        const models = await fetchModelList(apiUrl, apiKey);
        
        // 移除加载弹窗
        loadingModal.remove();
        
        if (models.length === 0) {
            alert('未获取到模型列表，请手动输入模型名称');
            return;
        }
        
        // 显示模型选择弹窗
        showCurrentPresetModelList(models);
        
    } catch (error) {
        // 移除加载弹窗
        loadingModal.remove();
        
        console.error('获取模型失败:', error);
        
        let errorMsg = '获取模型失败: ' + error.message;
        if (error.message.includes('无法找到可用的模型列表端点')) {
            errorMsg = '无法自动获取模型列表。\n\n请先在编辑预设中手动输入模型名称';
        }
        
        alert(errorMsg);
    }
}

// 显示当前预设的模型列表
function showCurrentPresetModelList(models) {
    const modal = document.createElement('div');
    modal.id = 'current-model-list-modal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    modal.innerHTML = `
    <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                width: 100%; max-width: 400px; max-height: 70vh;
                display: flex; flex-direction: column;">
        <div style="padding: 20px; border-bottom: 1px solid var(--input-border);">
            <h4 style="margin: 0; color: var(--text-color-primary);">选择模型 (${models.length}个)</h4>
        </div>
        
        <div style="padding: 15px; flex: 1; overflow-y: auto;">
            <input type="text" id="current-model-search-input" 
                   placeholder="搜索模型..." 
                   style="width: 90%; padding: 10px 15px; margin: 0 auto 15px auto;
                          border-radius: 10px; border: 1px solid var(--input-border); 
                          background: var(--input-bg); color: var(--text-color-primary);
                          display: block;">
            
            <div id="current-model-items-container" style="max-height: 50vh; overflow-y: auto;">
                <!-- 模型列表会在这里动态生成 -->
            </div>
        </div>
        
        <div style="padding: 15px; border-top: 1px solid var(--input-border); text-align: center;">
            <button onclick="document.getElementById('current-model-list-modal').remove()" 
                    style="padding: 10px 20px; border-radius: 8px;
                           background: var(--input-bg); color: var(--text-color-primary);
                           border: 1px solid var(--input-border); cursor: pointer;">
                取消
            </button>
        </div>
    </div>
    `;
    
    document.body.appendChild(modal);
    
    // 填充模型列表
    renderCurrentPresetModels(models);
    
    // 搜索功能
    const searchInput = document.getElementById('current-model-search-input');
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => {
            const modelId = (model.id || model).toLowerCase();
            return modelId.includes(searchTerm);
        });
        renderCurrentPresetModels(filteredModels);
    });
    
    // 点击外部关闭
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

// 渲染当前预设的模型列表
function renderCurrentPresetModels(models) {
    const container = document.getElementById('current-model-items-container');
    container.innerHTML = '';
    
    if (models.length === 0) {
        container.innerHTML = `
            <div style="padding: 30px; text-align: center; color: var(--text-color-secondary);">
                未找到匹配的模型
            </div>
        `;
        return;
    }
    
    models.forEach((model) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop();
        
        const item = document.createElement('div');
        item.style.cssText = `
            padding: 12px 15px; margin: 0 10px 8px 10px; border-radius: 10px;
            border: 1px solid var(--input-border); cursor: pointer;
            background: var(--input-bg); transition: all 0.2s;
            width: calc(100% - 20px);
            box-sizing: border-box;
            overflow: hidden;
            word-break: break-word;
        `;
        
        item.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary);">
                ${displayName}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px;">
                ${modelId}
            </div>
        `;
        
        item.onclick = function() {
            // 更新当前预设的模型
            if (APP_DATA.currentPresetId) {
                const preset = APP_DATA.presets.find(p => p.id == APP_DATA.currentPresetId);
                if (preset) {
                    preset.defaultModel = modelId;
                    document.getElementById('current-preset-model').value = modelId;
                    APP_DATA.settings.aiModel = modelId;
                    saveData();
                }
            }
            
            // 关闭模型选择弹窗
            document.getElementById('current-model-list-modal').remove();
        };
        
        container.appendChild(item);
    });
}
// ==================== 补全API配置功能（复用主API配置）====================

// 打开补全API的配置管理器（直接复用主API配置列表）
function openBackfillPresetManager() {
    // 标记当前是补全API模式
    window.isBackfillMode = true;
    
    // 直接复用主API的配置管理弹窗
    const modal = document.getElementById('preset-modal');
    
    // 修改弹窗标题
    const title = modal.querySelector('h4');
    if (title) {
        title.dataset.originalText = title.dataset.originalText || title.textContent;
        title.textContent = '长期记忆API配置';
    }
    
    // 修改点击事件，让它选择配置后应用到补全API
    modal.dataset.mode = 'backfill';
    
    // 显示弹窗并刷新列表
    showModal('preset-modal');
    refreshPresetList();
}

async function openBackfillCurrentPresetModelSelector() {
    // 标记当前是补全API模式
    window.isBackfillMode = true;
    
    // 获取当前补全API选择的预设
    const currentId = APP_DATA.currentBackfillPresetId || APP_DATA.currentPresetId;
    if (!currentId) {
        alert('请先选择一个配置');
        return;
    }
    
    const preset = APP_DATA.presets.find(p => p.id == currentId);
    if (!preset) {
        alert('配置不存在');
        return;
    }
    
    const apiUrl = preset.apiUrl || '';
    const apiKey = preset.apiKey || '';
    
    if (!apiUrl || !apiKey) {
        alert('请先在编辑配置中填写API URL和API Key');
        return;
    }
    
    // 显示加载弹窗
    const loadingModal = document.createElement('div');
    loadingModal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; justify-content: center; align-items: center;';
    loadingModal.innerHTML = '<div style="background: var(--bg-color-secondary); padding: 30px; border-radius: 16px; min-width: 200px; text-align: center;"><div style="margin-bottom: 15px;"><i class="fa-solid fa-spinner fa-spin" style="font-size: 24px;"></i></div><div>正在获取模型列表...</div></div>';
    document.body.appendChild(loadingModal);
    
    try {
        const models = await fetchModelList(apiUrl, apiKey);
        loadingModal.remove();
        
        if (models.length === 0) {
            alert('未获取到模型列表');
            return;
        }
        
        // 显示模型选择弹窗
        showBackfillCurrentPresetModelList(models);
    } catch (error) {
        loadingModal.remove();
        alert('获取模型失败: ' + error.message);
    }
}

// 显示补全API的当前预设模型列表
function showBackfillCurrentPresetModelList(models) {
    const modal = document.createElement('div');
    modal.id = 'backfill-current-model-list-modal';
    modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; justify-content: center; align-items: center; padding: 20px;';
    
    modal.innerHTML = `
        <div style="background: var(--bg-color-secondary); border-radius: 16px; width: 100%; max-width: 400px; max-height: 70vh; display: flex; flex-direction: column;">
            <div style="padding: 20px; border-bottom: 1px solid var(--input-border);">
                <h4 style="margin: 0; color: var(--text-color-primary);">选择模型 (${models.length}个)</h4>
            </div>
            <div style="padding: 15px; flex: 1; overflow-y: auto;">
                <input type="text" id="backfill-current-model-search-input" placeholder="搜索模型..." style="width: 90%; padding: 10px 15px; margin: 0 auto 15px auto; border-radius: 10px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color-primary); display: block;">
                <div id="backfill-current-model-items-container" style="max-height: 50vh; overflow-y: auto;"></div>
            </div>
            <div style="padding: 15px; border-top: 1px solid var(--input-border); text-align: center;">
                <button onclick="document.getElementById('backfill-current-model-list-modal').remove()" style="padding: 10px 20px; border-radius: 8px; background: var(--input-bg); color: var(--text-color-primary); border: 1px solid var(--input-border); cursor: pointer;">取消</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    renderBackfillCurrentPresetModels(models);
    
    document.getElementById('backfill-current-model-search-input').addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => (model.id || model).toLowerCase().includes(searchTerm));
        renderBackfillCurrentPresetModels(filteredModels);
    });
}

// 渲染补全API当前预设的模型列表
function renderBackfillCurrentPresetModels(models) {
    const container = document.getElementById('backfill-current-model-items-container');
    container.innerHTML = '';
    
    if (models.length === 0) {
        container.innerHTML = '<div style="padding: 30px; text-align: center; color: var(--text-color-secondary);">未找到匹配的模型</div>';
        return;
    }
    
    models.forEach((model) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop();
        
        const item = document.createElement('div');
        item.style.cssText = 'padding: 12px 15px; margin: 0 10px 8px 10px; border-radius: 10px; border: 1px solid var(--input-border); cursor: pointer; background: var(--input-bg); transition: all 0.2s; width: calc(100% - 20px); box-sizing: border-box; overflow: hidden; word-break: break-word;';
        
        item.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary);">${displayName}</div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px;">${modelId}</div>
        `;
        
        item.onclick = function() {
            const currentId = APP_DATA.currentBackfillPresetId || APP_DATA.currentPresetId;
            const preset = APP_DATA.presets.find(p => p.id == currentId);
            if (preset) {
                preset.defaultModel = modelId;
                document.getElementById('backfill-current-preset-model').value = modelId;
                APP_DATA.currentBackfillPresetId = currentId;
                saveData();
            }
            document.getElementById('backfill-current-model-list-modal').remove();
        };
        
        container.appendChild(item);
    });
}

async function openBackfillModelSelectorForEdit() {
    const apiUrl = document.getElementById('edit-backfill-api-url').value.trim();
    const apiKey = document.getElementById('edit-backfill-api-key').value.trim();
    
    if (!apiUrl || !apiKey) {
        alert('请先填写API URL和API Key');
        return;
    }
    
    const loadingModal = document.createElement('div');
    loadingModal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10002; display: flex; justify-content: center; align-items: center;';
    loadingModal.innerHTML = '<div style="background: var(--bg-color-secondary); padding: 30px; border-radius: 16px; min-width: 200px; text-align: center;"><div style="margin-bottom: 15px;"><i class="fa-solid fa-spinner fa-spin" style="font-size: 24px;"></i></div><div>正在获取模型列表...</div></div>';
    document.body.appendChild(loadingModal);
    
    try {
        const models = await fetchModelList(apiUrl, apiKey);
        loadingModal.remove();
        if (models.length === 0) {
            alert('未获取到模型列表');
            return;
        }
        showBackfillModelListForEdit(models);
    } catch (error) {
        loadingModal.remove();
        alert('获取模型失败: ' + error.message);
    }
}

function showBackfillModelListModal(models, isCurrentPreset) {
    const modal = document.createElement('div');
    modal.id = 'backfill-model-list-modal';
    modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; justify-content: center; align-items: center; padding: 20px;';
    
    modal.innerHTML = `<div style="background: var(--bg-color-secondary); border-radius: 16px; width: 100%; max-width: 320px; max-height: 70vh; display: flex; flex-direction: column;"><div style="padding: 20px; border-bottom: 1px solid var(--input-border);"><h4 style="margin: 0;">选择模型 (${models.length}个)</h4></div><div style="padding: 15px; flex: 1; overflow-y: auto;"><input type="text" id="backfill-model-search-input" placeholder="搜索模型..." style="width: 90%; padding: 10px 15px; margin: 0 auto 15px auto; border-radius: 10px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color-primary); display: block;"><div id="backfill-model-items-container"></div></div><div style="padding: 15px; border-top: 1px solid var(--input-border); text-align: center;"><button onclick="document.getElementById('backfill-model-list-modal').remove()" style="padding: 10px 20px; border-radius: 8px; background: var(--input-bg); color: var(--text-color-primary); border: 1px solid var(--input-border); cursor: pointer;">取消</button></div></div>`;
    
    document.body.appendChild(modal);
    renderBackfillModels(models, isCurrentPreset);
    
    document.getElementById('backfill-model-search-input').addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => (model.id || model).toLowerCase().includes(searchTerm));
        renderBackfillModels(filteredModels, isCurrentPreset);
    });
}

function renderBackfillModels(models, isCurrentPreset) {
    const container = document.getElementById('backfill-model-items-container');
    container.innerHTML = '';
    
    models.forEach((model) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop();
        
        const item = document.createElement('div');
        item.style.cssText = 'padding: 12px 15px; margin: 0 10px 8px 10px; border-radius: 10px; border: 1px solid var(--input-border); cursor: pointer; background: var(--input-bg); transition: all 0.2s; width: calc(100% - 20px); box-sizing: border-box; overflow: hidden; word-break: break-word;';
        
        item.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary);">
                ${displayName}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px;">
                ${modelId}
            </div>
        `;
        
        if (isCurrentPreset) {
            item.onclick = function() {
                if (APP_DATA.currentBackfillPresetId) {
                    const preset = APP_DATA.backfillPresets.find(p => p.id == APP_DATA.currentBackfillPresetId);
                    if (preset) {
                        preset.defaultModel = modelId;
                        document.getElementById('backfill-current-preset-model').value = modelId;
                        saveData();
                    }
                }
                document.getElementById('backfill-model-list-modal').remove();
            };
        } else {
            item.onclick = function() {
                document.getElementById('backfill-ai-model').value = modelId;
                document.getElementById('backfill-model-list-modal').remove();
            };
        }
        
        container.appendChild(item);
    });
}

function showBackfillModelListForEdit(models) {
    const modal = document.createElement('div');
    modal.id = 'backfill-model-list-edit-modal';
    modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10002; display: flex; justify-content: center; align-items: center; padding: 20px;';
    
    modal.innerHTML = `
        <div style="background: var(--bg-color-secondary); border-radius: 16px; width: 100%; max-width: 320px; max-height: 70vh; display: flex; flex-direction: column;">
            <div style="padding: 20px; border-bottom: 1px solid var(--input-border);">
                <h4 style="margin: 0;">选择模型 (${models.length}个)</h4>
            </div>
            <div style="padding: 15px; flex: 1; overflow-y: auto;">
                <input type="text" id="backfill-model-search-edit-input" placeholder="搜索模型..." style="width: 90%; padding: 10px 15px; margin: 0 auto 15px auto; border-radius: 10px; border: 1px solid var(--input-border); background: var(--input-bg); color: var(--text-color-primary); display: block;">
                <div id="backfill-model-items-edit-container"></div>
            </div>
            <div style="padding: 15px; border-top: 1px solid var(--input-border); text-align: center;">
                <button onclick="document.getElementById('backfill-model-list-edit-modal').remove()" style="padding: 10px 20px; border-radius: 8px; background: var(--input-bg); color: var(--text-color-primary); border: 1px solid var(--input-border); cursor: pointer;">取消</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    renderBackfillModelsForEdit(models);
    
    document.getElementById('backfill-model-search-edit-input').addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => (model.id || model).toLowerCase().includes(searchTerm));
        renderBackfillModelsForEdit(filteredModels);
    });
}

function renderBackfillModelsForEdit(models) {
    const container = document.getElementById('backfill-model-items-edit-container');
    container.innerHTML = '';
    
    models.forEach((model) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop();
        
        const item = document.createElement('div');
        item.style.cssText = 'padding: 12px 15px; margin: 0 10px 8px 10px; border-radius: 10px; border: 1px solid var(--input-border); cursor: pointer; background: var(--input-bg); transition: all 0.2s; width: calc(100% - 20px); box-sizing: border-box; overflow: hidden; word-break: break-word;';
        
        item.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary);">
                ${displayName}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px;">
                ${modelId}
            </div>
        `;
        
        item.onclick = function() {
            document.getElementById('edit-backfill-default-model').value = modelId;
            document.getElementById('backfill-model-list-edit-modal').remove();
        };
        
        container.appendChild(item);
    });
}
    // 更新开关状态
    updateSwitchState('deep-preset-switch', APP_DATA.deepPresetEnabled);
    updateSwitchState('regex-switch', APP_DATA.regexEnabled);
    
    // 更新显示框内容
    updateDeepPresetDisplay();
    updateRegexDisplay();

// 更新开关状态
function updateSwitchState(switchId, enabled) {
    const switchElement = document.getElementById(switchId);
    if (!switchElement) return;
    
    const thumb = switchElement.querySelector('.theme-switch-thumb');
    if (!thumb) return;
    
    if (enabled) {
        thumb.style.left = 'calc(100% - 19px)'; // 右边
        switchElement.style.background = 'var(--accent-color)';
    } else {
        thumb.style.left = '1px'; // 左边
        switchElement.style.background = 'var(--input-border)';
    }
}

// 更新深预设显示
function updateDeepPresetDisplay() {
    const display = document.getElementById('deep-preset-display');
    if (!display) return;
    
    if (APP_DATA.currentDeepPresetId) {
        const preset = APP_DATA.deepPresets.find(p => p.id == APP_DATA.currentDeepPresetId);
        if (preset) {
            display.value = preset.name;
            return;
        }
    }
    display.value = '未选择预设';
}

// 切换深预设开关
function toggleDeepPreset() {
    APP_DATA.deepPresetEnabled = !APP_DATA.deepPresetEnabled;
    updateSwitchState('deep-preset-switch', APP_DATA.deepPresetEnabled);
    saveData();
}

// 切换正则开关
function toggleRegex() {
    APP_DATA.regexEnabled = !APP_DATA.regexEnabled;
    updateSwitchState('regex-switch', APP_DATA.regexEnabled);
    saveData();
}

// 打开深预设管理弹窗
function openDeepPresetManager() {
    refreshDeepPresetList();
    showModal('deep-preset-modal');
}

// 打开正则管理弹窗
function openRegexManager() {
    refreshRegexList();
    showModal('regex-modal');
}

// 刷新深预设列表
function refreshDeepPresetList() {
    const list = document.getElementById('deep-preset-list');
    if (!list) return;
    
    if (!APP_DATA.deepPresets || APP_DATA.deepPresets.length === 0) {
        list.innerHTML = `
            <div style="text-align: center; padding: 30px; color: var(--text-color-secondary);">
                <div style="font-size: 36px; margin-bottom: 10px;">📁</div>
                <div>无预设</div>
            </div>
        `;
        return;
    }
    
    // 按最后使用时间排序
    const sortedPresets = [...APP_DATA.deepPresets].sort((a, b) => {
        const timeA = a.lastUsedTime || 0;
        const timeB = b.lastUsedTime || 0;
        return timeB - timeA;
    });
    
    list.innerHTML = '';
    sortedPresets.forEach(preset => {
        const div = document.createElement('div');
        div.style.cssText = `
            padding: 12px 15px; margin-bottom: 8px; border-radius: 10px;
            background: var(--input-bg); border: 1px solid var(--input-border);
            position: relative;
            min-height: 60px;
        `;
        
        // 主内容区域（点击选择）
        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = `
            cursor: pointer;
            margin-right: 40px; /* 给删除按钮留空间 */
        `;
        
        contentDiv.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary); font-size: 17px;">
                ${preset.name}
            </div>
            <div style="font-size: 13px; color: var(--text-color-secondary); margin-top: 6px; line-height: 1.4;">
                ${preset.content.substring(0, 50)}${preset.content.length > 50 ? '...' : ''}
            </div>
        `;
        
        contentDiv.onclick = function() {
            selectDeepPreset(preset.id);
        };
        
        div.appendChild(contentDiv);
        
        // 删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.innerHTML = '×';
        deleteBtn.style.cssText = `
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            border-radius: 6px;
            background: var(--danger-color);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        deleteBtn.title = '删除预设';
        deleteBtn.onclick = function(e) {
            e.stopPropagation(); // 阻止冒泡
            deleteDeepPreset(preset.id);
        };
        
        div.appendChild(deleteBtn);
        list.appendChild(div);
    });
}

// 刷新正则列表
function refreshRegexList() {
    const list = document.getElementById('regex-list');
    if (!list) return;
    
    if (!APP_DATA.regexPatterns || APP_DATA.regexPatterns.length === 0) {
        list.innerHTML = `
            <div style="text-align: center; padding: 30px; color: var(--text-color-secondary);">
                <div style="font-size: 36px; margin-bottom: 10px;">📄</div>
                <div>无正则</div>
            </div>
        `;
        return;
    }
    
    // 按最后使用时间排序
    const sortedRegex = [...APP_DATA.regexPatterns].sort((a, b) => {
        const timeA = a.lastUsedTime || 0;
        const timeB = b.lastUsedTime || 0;
        return timeB - timeA;
    });
    
    list.innerHTML = '';
    sortedRegex.forEach(regex => {
        const div = document.createElement('div');
        div.style.cssText = `
            padding: 12px 15px; margin-bottom: 8px; border-radius: 10px;
            background: var(--input-bg); border: 1px solid var(--input-border);
            position: relative;
            min-height: 60px;
        `;
        
        // 主内容区域（点击选择）
        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = `
            cursor: pointer;
            margin-right: 40px; /* 给删除按钮留空间 */
        `;
        
        contentDiv.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary); font-size: 17px;">
                ${regex.name}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px; line-height: 1.3;">
                <div style="margin-bottom: 2px;">模式: ${regex.pattern.substring(0, 40)}${regex.pattern.length > 40 ? '...' : ''}</div>
                <div>替换: ${regex.replacement.substring(0, 40)}${regex.replacement.length > 40 ? '...' : ''}</div>
            </div>
        `;
        
        contentDiv.onclick = function() {
            selectRegex(regex.id);
        };
        
        div.appendChild(contentDiv);
        
        // 删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.innerHTML = '×';
        deleteBtn.style.cssText = `
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            border-radius: 6px;
            background: var(--danger-color);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        deleteBtn.title = '删除正则';
        deleteBtn.onclick = function(e) {
            e.stopPropagation(); // 阻止冒泡
            deleteRegex(regex.id);
        };
        
        div.appendChild(deleteBtn);
        list.appendChild(div);
    });
}

// 6. 交互动作 (修复 ID 类型匹配问题)
function selectDeepPreset(id) {
    // 强制转为字符串，防止 ID 类型不匹配
    APP_DATA.currentDeepPresetId = String(id);
    
    // 应用参数
    const preset = APP_DATA.deepPresets.find(p => String(p.id) === String(id));
    if (preset) {
        if (preset.temperature !== undefined) {
            APP_DATA.settings.temperature = parseFloat(preset.temperature);
            const tempDisplay = document.getElementById('temperature-value');
            if(tempDisplay) tempDisplay.textContent = APP_DATA.settings.temperature;
        }
    }

    saveData();
    updateDeepPresetUI(); // 刷新界面
}

// 选择正则
function selectRegex(regexId) {
    const regex = APP_DATA.regexPatterns.find(r => r.id == regexId);
    if (!regex) return;
    
    APP_DATA.currentRegexId = regexId;
    regex.lastUsedTime = Date.now();
    updateRegexDisplay();
    saveData();
    hideModal('regex-modal');
}

// 删除深预设
function deleteDeepPreset(presetId) {
    if (!confirm('确定要删除这个预设吗？此操作不可撤销。')) {
        return;
    }
    
    // 如果要删除的是当前选中的预设
    if (APP_DATA.currentDeepPresetId === presetId) {
        APP_DATA.currentDeepPresetId = null;
        updateDeepPresetDisplay();
    }
    
    // 从数组中删除
    APP_DATA.deepPresets = APP_DATA.deepPresets.filter(p => p.id !== presetId);
    saveData();
    refreshDeepPresetList();
}

// 删除正则
function deleteRegex(regexId) {
    if (!confirm('确定要删除这个正则吗？此操作不可撤销。')) {
        return;
    }
    
    // 如果要删除的是当前选中的正则
    if (APP_DATA.currentRegexId === regexId) {
        APP_DATA.currentRegexId = null;
        updateRegexDisplay();
    }
    
    // 从数组中删除
    APP_DATA.regexPatterns = APP_DATA.regexPatterns.filter(r => r.id !== regexId);
    saveData();
    refreshRegexList();
}


// 在AI对话中应用深预设
function applyDeepPresetToPrompt() {
    if (!APP_DATA.deepPresetEnabled || !APP_DATA.currentDeepPresetId) {
        return '';
    }
    
    const preset = APP_DATA.deepPresets.find(p => p.id == APP_DATA.currentDeepPresetId);
    if (!preset) return '';
    
    return `\n【深预设】\n${preset.content}\n`;
}

// 在AI回复后应用正则处理
function applyRegexToText(text) {
    if (!APP_DATA.regexEnabled || !APP_DATA.currentRegexId) {
        return text;
    }
    
    const regex = APP_DATA.regexPatterns.find(r => r.id == APP_DATA.currentRegexId);
    if (!regex) return text;
    
    try {
        const pattern = new RegExp(regex.pattern, 'g');
        return text.replace(pattern, regex.replacement);
    } catch (error) {
        console.error('正则处理错误:', error);
        return text;
    }
}
 
// === 2. 发送函数 (读取全局状态 + 防空拦截) ===
async function sendPushNotification(messageText) {
    // 【新增】只在后台时发送通知
    if (document.visibilityState === 'visible') {
        console.log('前台状态，不发送通知');
        return;
    }
    if (!messageText || typeof messageText !== 'string' || messageText.trim() === "") {
        return;
    }

    // 请确认这是你的 Worker 地址
    const WORKER_URL = "https://my-push-worker.ginkgo-yinxing.workers.dev";
    
    try {
        if (!('serviceWorker' in navigator)) return;
        const registration = await navigator.serviceWorker.ready;
        let subscription = await registration.pushManager.getSubscription();
        
        if (!subscription) {
            subscription = await registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
            });
        }
        
        // 【关键修复】读取 window 上的全局变量
        // 这样发第二条、第三条消息时，它依然能记得开关的状态
        const shouldShowContent = window.isNotificationContentEnabled;
        
        // 决定发送内容
        let finalContent = shouldShowContent ? messageText : "收到一条新消息";
        
        // 截取前100字
        finalContent = String(finalContent).substring(0, 100);

        // 发送
        await fetch(WORKER_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ 
                subscription: subscription.toJSON(),
                message: finalContent 
            })
        });
        
    } catch (e) {
        console.error("推送失败", e);
    }
}



	// 控制静音音频播放的函数
function toggleSilentAudio(shouldPlay) {
    const audio = document.getElementById('silent-audio');
    if (!audio) return;
    
    if (shouldPlay) {
        audio.play().catch(e => console.log("音频播放被拦截:", e));
    } else {
        audio.pause();
    }
}

// 确保变量在全局范围内
let isKeepAliveEnabled = false;

async function toggleKeepAlive() {
    const track = document.getElementById('keep-alive-switch');
    const thumb = track.querySelector('.theme-switch-thumb');
    const audio = document.getElementById('silent-audio');
    
    if (!audio) return;

    isKeepAliveEnabled = !isKeepAliveEnabled;
    
    if (isKeepAliveEnabled) {
        // UI 表现
        thumb.style.left = 'calc(100% - 28px)'; 
        track.style.background = 'var(--accent-color)';
        
        // 强制开启循环模式
        audio.loop = true;
        audio.volume = 0.5; 
        
        try {
            await audio.play();
            console.log("✅ 后台保活已启动并设置为循环模式");
        } catch (e) {
            console.warn("❌ 播放失败:", e);
            isKeepAliveEnabled = false;
            thumb.style.left = '2px';
            track.style.background = 'var(--input-border)';
        }
    } else {
        // 关闭
        thumb.style.left = '2px';
        track.style.background = 'var(--input-border)';
        audio.pause();
    }
}

// --- 新增：双重保险，确保音频结束时自动重新播放 ---
document.getElementById('silent-audio').addEventListener('ended', function() {
    if (isKeepAliveEnabled) {
        this.play();
    }
}, false);

async function checkAndReactivateSubscription() {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
        console.log('浏览器不支持 Push API');
        return;
    }

    try {
        const registration = await navigator.serviceWorker.ready;
        const subscription = await registration.pushManager.getSubscription();
        
        if (subscription) {
            console.log('已存在推送订阅');
            // 将订阅信息发送到服务器
            await sendSubscriptionToServer(subscription);
        } else {
            console.log('尚未订阅推送');
        }
    } catch (error) {
        console.error('检查订阅状态失败:', error);
    }
}

// 页面加载完成后运行
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(checkAndReactivateSubscription, 2000); // 延迟2秒确保SDK加载完成
});

async function requestPushPermission() {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
        alert('您的浏览器不支持推送通知');
        return;
    }

    try {
        const permission = await Notification.requestPermission();
        if (permission === 'granted') {
            // 【重要修改】使用相对路径 ./sw.js
            // 请确保 sw.js 文件和你的 index.html 文件在同一个文件夹里！
            const swPath = './sw.js'; 
            
            const registration = await navigator.serviceWorker.register(swPath);
            await navigator.serviceWorker.ready;
            
            console.log('Service Worker 已注册');
            
            // 订阅
            const subscription = await registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
            });
            
            // 发送给服务器
            const sent = await sendSubscriptionToServer(subscription);
            if (sent) {
                alert('通知已开启！\n如果是iPhone，请确保已点击分享按钮“添加到主屏幕”。');
            } else {
                alert('通知开启失败：无法连接服务器');
            }
        } else {
            alert('您拒绝了通知权限，无法接收消息。');
        }
    } catch (error) {
        console.error('注册失败:', error);
        alert('出错啦: ' + error.message);
    }
}


// 辅助函数：Base64 转换
function urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');
    const rawData = atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}


async function sendSubscriptionToServer(subscription) {
    try {
        console.log("准备发送订阅信息...");
        const response = await fetch('https://my-push-worker.ginkgo-yinxing.workers.dev', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                subscription: subscription,
                action: 'subscribe' // 告诉 worker 这是订阅动作
            })
        });

        if (!response.ok) {
            // 获取服务器返回的详细错误文字
            const errorText = await response.text();
            console.error("Worker 返回错误:", errorText); 
            throw new Error(`服务器拒绝: ${response.status} - ${errorText}`);
        }
        
        const json = await response.json();
        console.log("订阅成功，服务器响应:", json);
        return json;
    } catch (error) {
        console.error('发送订阅失败:', error);
        alert(`订阅失败: ${error.message}`); // 弹窗提示具体错误
        throw error;
    }
}


    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('https://lingshing.github.io/Linkgostart/sw.js')
                .then(registration => {
                    console.log('Service Worker 注册成功:', registration);
                })
                .catch(error => {
                    console.error('Service Worker 注册失败:', error);
                });
        });
    }

// 页面加载时检查授权状态
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        window.OneSignalDeferred = window.OneSignalDeferred || [];
        OneSignalDeferred.push(function(OneSignal) {
            const isSubscribed = OneSignal.User.PushSubscription.optedIn;
            const btn = document.getElementById('push-auth-btn');
            if (btn && isSubscribed) {
                btn.textContent = '已开启';
                btn.style.background = 'var(--accent-color)';
                btn.disabled = true;
            }
        });
    }, 2000);
});

// ==================== 紧急修复功能 ====================
function emergencyFix() {
    // 显示修复选项弹窗
    const fixModal = document.createElement('div');
    fixModal.id = 'emergency-fix-modal';
    fixModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.6); z-index: 9999;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    fixModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                    width: 90%; max-width: 320px; padding: 24px;">
            <h4 style="margin: 0 0 20px 0; color: var(--danger-color); text-align: center;">
                🔧 紧急修复
            </h4>
            
            <p style="color: var(--text-color-secondary); font-size: 14px; margin-bottom: 20px; text-align: center;">
                如果某个聊天卡死了，请选择修复方式：
            </p>
            
            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button onclick="fixTypingState()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: var(--accent-color); color: white;
                    font-size: 15px; cursor: pointer;">
                    🔄 解除卡死状态
                </button>
                
                <button onclick="showForcePagedLoadSelector()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: #FF6B6B; color: white;
                    font-size: 15px; cursor: pointer;">
                    ⚡ 强制分页加载（消息过多卡死用这个）
                </button>
                
                <button onclick="fixAndRerender()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: var(--warning-color); color: white;
                    font-size: 15px; cursor: pointer;">
                    🔃 重新渲染聊天界面
                </button>
                
                <button onclick="showChatSelector()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: var(--input-bg); color: var(--text-color-primary);
                    border: 1px solid var(--input-border);
                    font-size: 15px; cursor: pointer;">
                    🗑️ 清空某个聊天的历史
                </button>
                
                <button onclick="document.getElementById('emergency-fix-modal').remove()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: var(--input-bg); color: var(--text-color-secondary);
                    font-size: 15px; cursor: pointer; margin-top: 10px;">
                    取消
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(fixModal);
    
    // 点击外部关闭
    fixModal.addEventListener('click', function(e) {
        if (e.target === fixModal) {
            fixModal.remove();
        }
    });
}

// 修复1：解除卡死状态
function fixTypingState() {
    // 重置所有状态变量
    isTyping = false;
    currentAIRequest = null;
    
    // 取消正在进行的网络请求
    if (currentController) {
        currentController.abort();
        currentController = null;
    }
    
    // 移除所有正在加载的气泡
    document.querySelectorAll('.typing-indicator').forEach(el => {
        const msgDiv = el.closest('.chat-message');
        if (msgDiv) msgDiv.remove();
    });
    
    // 关闭修复弹窗
    const modal = document.getElementById('emergency-fix-modal');
    if (modal) modal.remove();
    
    alert('✅ 已解除卡死状态！\n\n现在可以继续聊天了。');
}

// 修复2：重新渲染聊天界面
function fixAndRerender() {
    // 先解除卡死状态
    isTyping = false;
    currentAIRequest = null;
    if (currentController) {
        currentController.abort();
        currentController = null;
    }
    
    // 如果当前有聊天，重新渲染
    if (currentContact) {
        const container = document.getElementById('chat-messages');
        if (container) {
            container.innerHTML = '';
            renderMessages(currentContact.history);
        }
    }
    
    // 关闭修复弹窗
    const modal = document.getElementById('emergency-fix-modal');
    if (modal) modal.remove();
    
    alert('✅ 已重新渲染聊天界面！');
}

// 修复3：显示聊天选择器（清空历史）
function showChatSelector() {
    const modal = document.getElementById('emergency-fix-modal');
    if (!modal) return;
    
    // 更新弹窗内容为聊天列表
    const content = modal.querySelector('div');
    if (!content) return;
    
    let chatListHTML = '';
    APP_DATA.contacts.forEach(contact => {
        chatListHTML += `
            <button onclick="clearChatHistory(${contact.id})" style="
                padding: 12px; border-radius: 8px; border: none;
                background: var(--input-bg); color: var(--text-color-primary);
                border: 1px solid var(--input-border);
                font-size: 14px; cursor: pointer; text-align: left;
                display: flex; justify-content: space-between; align-items: center;">
                <span>${contact.name}</span>
                <span style="color: var(--text-color-secondary); font-size: 12px;">
                    ${contact.history.length} 条消息
                </span>
            </button>
        `;
    });
    
    content.innerHTML = `
        <h4 style="margin: 0 0 20px 0; color: var(--text-color-primary); text-align: center;">
            选择要清空的聊天
        </h4>
        
        <p style="color: var(--danger-color); font-size: 13px; margin-bottom: 15px; text-align: center;">
            ⚠️ 清空后无法恢复！
        </p>
        
        <div style="display: flex; flex-direction: column; gap: 10px; max-height: 50vh; overflow-y: auto;">
            ${chatListHTML || '<p style="text-align: center; color: var(--text-color-secondary);">没有聊天记录</p>'}
        </div>
        
        <button onclick="document.getElementById('emergency-fix-modal').remove()" style="
            width: 100%; padding: 14px; border-radius: 10px; border: none;
            background: var(--input-bg); color: var(--text-color-secondary);
            font-size: 15px; cursor: pointer; margin-top: 15px;">
            返回
        </button>
    `;
}

// 清空指定聊天的历史
function clearChatHistory(contactId) {
    const contact = APP_DATA.contacts.find(c => c.id === contactId);
    if (!contact) return;
    
    if (!confirm(`确定要清空「${contact.name}」的所有聊天记录吗？\n\n此操作无法撤销！`)) {
        return;
    }
    
    // 清空历史
    contact.history = [];
    saveData();
    
    // 如果当前正在这个聊天中，重新渲染
    if (currentContact && currentContact.id === contactId) {
        const container = document.getElementById('chat-messages');
        if (container) {
            container.innerHTML = '';
        }
    }
    
    // 关闭弹窗
    const modal = document.getElementById('emergency-fix-modal');
    if (modal) modal.remove();
    
    alert(`✅ 已清空「${contact.name}」的聊天记录！`);
}

// 修复4：显示强制分页加载选择器
function showForcePagedLoadSelector() {
    const modal = document.getElementById('emergency-fix-modal');
    if (!modal) return;
    
    // 更新弹窗内容为聊天列表
    const content = modal.querySelector('div');
    if (!content) return;
    
    let chatListHTML = '';
    APP_DATA.contacts.forEach(contact => {
        const msgCount = contact.history.length;
        const isLarge = msgCount > 100;
        chatListHTML += `
            <button onclick="forcePagedLoad(${contact.id})" style="
                padding: 12px; border-radius: 8px; border: none;
                background: ${isLarge ? 'rgba(255, 107, 107, 0.1)' : 'var(--input-bg)'}; 
                color: var(--text-color-primary);
                border: 1px solid ${isLarge ? '#FF6B6B' : 'var(--input-border)'};
                font-size: 14px; cursor: pointer; text-align: left;
                display: flex; justify-content: space-between; align-items: center;">
                <span>${contact.name}</span>
                <span style="color: ${isLarge ? '#FF6B6B' : 'var(--text-color-secondary)'}; font-size: 12px; font-weight: ${isLarge ? 'bold' : 'normal'};">
                    ${msgCount} 条消息 ${isLarge ? '⚠️' : ''}
                </span>
            </button>
        `;
    });
    
    content.innerHTML = `
        <h4 style="margin: 0 0 15px 0; color: #FF6B6B; text-align: center;">
            ⚡ 强制分页加载
        </h4>
        
        <p style="color: var(--text-color-secondary); font-size: 13px; margin-bottom: 15px; text-align: center; line-height: 1.5;">
            选择卡死的聊天，系统将只加载最近20条消息。<br>
            <span style="color: #FF6B6B;">红色标记的聊天消息过多，建议处理。</span>
        </p>
        
        <div style="display: flex; flex-direction: column; gap: 10px; max-height: 45vh; overflow-y: auto;">
            ${chatListHTML || '<p style="text-align: center; color: var(--text-color-secondary);">没有聊天记录</p>'}
        </div>
        
        <button onclick="emergencyFix()" style="
            width: 100%; padding: 14px; border-radius: 10px; border: none;
            background: var(--input-bg); color: var(--text-color-secondary);
            font-size: 15px; cursor: pointer; margin-top: 15px;">
            返回
        </button>
    `;
}

// 强制分页加载指定聊天
function forcePagedLoad(contactId) {
    const contact = APP_DATA.contacts.find(c => c.id === contactId);
    if (!contact) return;
    
    const msgCount = contact.history.length;
    
    // 关闭修复弹窗
    const modal = document.getElementById('emergency-fix-modal');
    if (modal) modal.remove();
    
    // 重置所有状态
    isTyping = false;
    currentAIRequest = null;
    if (currentController) {
        currentController.abort();
        currentController = null;
    }
    
    // 设置当前聊天
    APP_DATA.currentChatId = contactId;
    currentContact = contact;
    
    // 强制只渲染最后20条
    currentStartIndex = Math.max(0, contact.history.length - 20);
    
    // 显示聊天窗口
    document.querySelectorAll('.page').forEach(page => {
        page.style.display = 'none';
    });
    
    const chatWindow = document.getElementById('chat-window');
    chatWindow.style.display = 'flex';
    document.getElementById('chat-role-name').textContent = contact.name;
    
    // 清空消息容器
    const container = document.getElementById('chat-messages');
    if (container) {
        container.innerHTML = '<div id="loading-more" style="display:none; text-align:center; padding:10px; color:var(--text-color-secondary);">加载中...</div>';
    }
    
    // 只渲染最后20条消息
    const recentMessages = contact.history.slice(-20);
    
    // 延迟渲染，确保DOM已更新
    setTimeout(() => {
        recentMessages.forEach(msg => {
            appendMessageToDOM(msg.content, msg.role, false);
        });
        
        scrollToBottomInstant();
        
        alert(`✅ 已强制分页加载「${contact.name}」！\n\n原有 ${msgCount} 条消息，当前只显示最近 20 条。\n\n向上滚动可以加载更多历史消息。`);
    }, 100);
}

// 切换流式输出开关
function toggleStream() {
    APP_DATA.settings.stream = !APP_DATA.settings.stream;
    updateSwitchState('stream-switch', APP_DATA.settings.stream);
    saveData();
}

// Base64 转换函数
function urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');
    const rawData = atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

// 发送订阅到服务器
async function sendSubscriptionToServer(subscription) {
    try {
        const response = await fetch(WORKER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'subscribe',
                subscription: subscription
            })
        });
        
        if (!response.ok) {
            throw new Error('订阅失败');
        }
        
        console.log('订阅成功发送到服务器');
        return true;
    } catch (error) {
        console.error('发送订阅失败:', error);
        return false;
    }
}
// === 通知内容开关逻辑 ===

// === 最终修正版 JS：完全使用你的 CSS 变量 ===
let isNotificationContentEnabled = true; // 默认开启

function toggleNotificationContent() {
    window.isNotificationContentEnabled = !window.isNotificationContentEnabled;
    
    const switchEl = document.getElementById('notification-content-switch');
    const thumbEl = switchEl.querySelector('.theme-switch-thumb');
    
    if (window.isNotificationContentEnabled) {
        switchEl.style.background = 'var(--accent-color)'; 
        thumbEl.style.transform = 'translateX(20px)';
    } else {
        switchEl.style.background = 'var(--input-border)';
        thumbEl.style.transform = 'translateX(0px)';
    }
    
    APP_DATA.settings.notificationShowContent = window.isNotificationContentEnabled;
    saveData();
    
    console.log('通知内容开关状态:', window.isNotificationContentEnabled); // 添加这行调试
}

// 更新通知内容开关UI（不触发toggle，仅更新显示）
function updateNotificationSwitchUI(isEnabled) {
    const switchEl = document.getElementById('notification-content-switch');
    if (!switchEl) return;
    
    const thumbEl = switchEl.querySelector('.theme-switch-thumb');
    if (!thumbEl) return;
    
    if (isEnabled) {
        switchEl.style.background = 'var(--accent-color)';
        thumbEl.style.transform = 'translateX(20px)';
    } else {
        switchEl.style.background = 'var(--input-border)';
        thumbEl.style.transform = 'translateX(0px)';
    }
}
// --- 📋 复制功能的辅助函数 ---
function copyText(button, elementId) {
    const textarea = document.getElementById(elementId);
    if (!textarea) return;
    
    // 执行复制
    navigator.clipboard.writeText(textarea.value).then(() => {
        // 视觉反馈：图标变成对号
        const icon = button;
        icon.className = 'fa-solid fa-check';
        icon.style.color = 'var(--accent-color)';
        
        // 1.5秒后变回复制图标
        setTimeout(() => {
            icon.className = 'fa-regular fa-copy clickable';
            icon.style.color = '';
        }, 1500);
    }).catch(err => {
        console.error('复制失败:', err);
        alert('复制失败，请手动复制');
    });
}

/* ================= 纯净版修复代码 (只修复深预设弹窗) ================= */

// 1. 数据安全检查 (这是让弹窗能正常运行的核心)
function ensureTavernData() {
    if (!window.APP_DATA) window.APP_DATA = {};
    // 确保 deepPresets 是一个数组，防止代码读取时崩溃
    if (!APP_DATA.deepPresets || !Array.isArray(APP_DATA.deepPresets)) APP_DATA.deepPresets = [];
    if (!APP_DATA.regexCollections || !Array.isArray(APP_DATA.regexCollections)) APP_DATA.regexCollections = [];
}

// 2. 仅重写"深预设"的打开逻辑
function openDeepPresetManager() {
    ensureTavernData(); // 先穿"防弹衣"
    
    // 如果原代码有更新UI的函数，就调用它
    if (typeof updateDeepPresetUI === 'function') {
        updateDeepPresetUI();
    }
    
    // 查找弹窗元素
    const modal = document.getElementById('deep-preset-modal');
    if (!modal) {
        alert('错误：找不到 id 为 deep-preset-modal 的弹窗元素！');
        return;
    }
    
    // 强制显示弹窗 (兼容两种常见的显示方式)
    if (typeof showModal === 'function') {
        showModal('deep-preset-modal');
    } else {
        modal.classList.add('active');
        modal.style.display = 'flex';
    }
}


</script>

<!-- 配置管理弹窗 -->
<div id="preset-modal" class="overlay">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;">
  
  <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">配置管理</h4>
        
        <div id="preset-list" style="max-height: 50vh; overflow-y: auto; margin-bottom: 10px; padding-right: 5px;">
        </div>
        
        <!-- 新建配置按钮 -->
        <div style="text-align: center; padding-top: 15px; border-top: 1px solid var(--input-border);">
            <button onclick="doCreateNewPreset()" 
                    style="width: 100%; padding: 14px; border-radius: var(--radius-default); 
                           background: var(--accent-color); color: white; border: none; 
                           cursor: pointer; font-size: 16px; margin-bottom: 10px;">
                <i class="fas fa-plus-circle"></i> 新建配置
            </button>
          
        </div>
    </div>
</div>

<!-- 预设详情弹窗 -->
<div id="deep-preset-detail-modal" class="overlay" style="z-index: 10000;">
    <div class="modal-content" style="width: 90%; max-width: 350px; max-height: 80vh; display:flex; flex-direction:column; background: var(--bg-color-secondary) !important;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; height: 40px;">
            <div class="back-button clickable" onclick="hideModal('deep-preset-detail-modal')" style="margin-right: 15px; display: flex; align-items: center;">
                <i class="fa-solid fa-angle-left"></i>
            </div>
            <h4 id="preset-detail-title" style="margin:0; flex-grow:1; text-align:center; color: var(--text-color-primary); font-size: 15px !important; line-height: 40px; transform: translateY(6px);">预设详情</h4>
            <div style="width: 40px;"></div>
        </div>
        <div style="flex:1; overflow-y: auto; margin-bottom: 15px; background:var(--input-bg); border-radius:8px; padding:10px;" id="deep-preset-details"></div>
    </div>
</div>

</body>
