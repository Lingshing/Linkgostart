<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linkgo⭐</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Linkgo">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/Lingshing/Linkgostart/refs/heads/main/linkgo-icon.jpg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ----------------------- 全局与主题样式 ----------------------- */
        :root {
            /* 主题变量 */
            --bg-color-primary: #f0f0f5; 
            --bg-color-secondary: #ffffff; 
            --text-color-primary: #1c1c1e; 
            --text-color-secondary: #8e8e93; 
            --accent-color: #7B9E6D; 
            --danger-color: #E8AF98;
            --warning-color: #A89F4D;
            --shadow-light: 0 4px 12px rgba(0, 0, 0, 0.05);
            --shadow-dark: 0 4px 12px rgba(0, 0, 0, 0.3);
            --input-bg: #f7f7f7;
            --input-border: #e0e0e0; 
            --radius-default: 16px; 
            --bubble-radius: 6px; /* 需求4: 气泡圆角不要那么圆 */

            --phone-width: 100%;
            --phone-height: 100vh;
        }

        .dark-mode {
            --bg-color-primary: #121212;
            --bg-color-secondary: #1e1e1e;
            --text-color-primary: #e0e0e0; /* 统一白色文字 */
            --text-color-secondary: #aaa; /* 提高对比度 */
            --accent-color: #8AAE7F;
            --shadow-light: 0 4px 12px rgba(0, 0, 0, 0.5);
            --shadow-dark: 0 4px 12px rgba(0, 0, 0, 0.8);
            --input-bg: #2b2b2b;
            --input-border: #444;
            --danger-color: #D17A6B;
        }
        

        /* 基础样式和动效 */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color-primary);
            font-family: -apple-system, BlinkMacSystemFont, 
                 'SF Pro Text', 'Helvetica Neue', 
                 'PingFang SC', 'Hiragino Sans GB',
                 sans-serif;
    -webkit-font-smoothing: antialiased;  /* 字体抗锯齿 */
    -moz-osx-font-smoothing: grayscale;
            transition: background-color 0.3s;
            color: var(--text-color-primary); /* 确保所有文字颜色统一 */
        }
        
        .clickable:active {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }

        .phone-frame {
            width: var(--phone-width);
            height: var(--phone-height);
            background: linear-gradient(145deg, var(--bg-color-primary), var(--bg-color-primary));
            border-radius: 0;
            box-shadow: var(--shadow-dark);
            padding: 10px;
            box-sizing: border-box;
            position: relative;
        }

        .phone-screen {
            width: 100%;
            height: 100%;
            background-color: var(--bg-color-secondary);
            border-radius: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .status-bar {
            width: 100%;
            height: 0px; /* 需求4: 只保留最小高度 */
            background-color: var(--bg-color-secondary);
            box-sizing: border-box;
        }

        /* ----------------------- APP 图标和主界面 ----------------------- */
        /* 添加这行，让图标颜色继承父元素颜色 */
        .fas, .fab {
             color: inherit;
        }

        .app-container {
            flex-grow: 1;
            width: 100%;
            padding: 40px 20px;
            display: flex;
            justify-content: center; 
            align-items: flex-start;
            gap: 40px; 
        }

        .app-icon {
            text-align: center;
            cursor: pointer;
            width: 65px; 
        }
        
        .app-icon .app-icon-image {
             transition: transform 0.1s ease;
        }
        .app-icon:active .app-icon-image {
             transform: scale(0.95);
        }

        .app-icon-image {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(8px); 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            border-radius: var(--radius-default); 
            margin: 0 auto 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            color: #ffffff; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* ----------------------- 页面切换结构 ----------------------- */
        .page {
            position: absolute;
            inset: 0;
            top: 0px; /* 调整状态栏高度 */
            background: var(--bg-color-secondary);
            display: none; 
            flex-direction: column;
            color: var(--text-color-primary);
        }

        .page-header {
            display: flex;
            align-items: center;
            padding: 10px 15px; 
            /* 修改点：背景改为透明(透出手机底色) 或 直接写 black */
            background-color: var(--bg-color-primary); 
            /* 修改点：去掉底部边框，让它看起来和背景一体 */
            border-bottom: none; 
            position: sticky;
            top: 0px;
            z-index: 2;
            height: 50px;
            box-sizing: border-box;
        }
        
        /* 设置页面调整 */
        .page-header h3 {
            flex-grow: 1;
            text-align: center; 
            margin: 0;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            /* 修改点：字号16px，不加粗 */
            font-size: 16px; 
            font-weight: normal; 
        }

        /* 需求3: 聊天室页面 */
        .page-header h3.small-title {
            font-size: 16px;
        }

        .back-button, .action-button, .manage-button {
            display: flex;
            align-items: center;
            cursor: pointer;
            color: var(--text-color-primary);
            padding: 5px;
            font-size: 16px;
            z-index: 3;
            transition: transform 0.1s ease;
        }
        .back-button:active, .action-button:active, .manage-button:active {
            transform: scale(0.94);
        }
        
        .back-button { margin-right: auto; }
        
        /* 需求2: 管理按钮 */
        .manage-button {
            margin-left: auto;
            margin-right: 15px;
            font-size: 16px;
        }

        /* 需求2: 加号放大 */
        .action-button.plus-btn {
            font-size: 16px; 
            font-weight: 300;
            line-height: 1;
        }
        /* 仅针对聊天窗口的三个点 */
#chat-window .action-button {
    font-size: 24px;
    font-weight: 700;
}
        .back-icon { margin-right: 5px; }

        /* ----------------------- 设置 & 选项页面样式 ----------------------- */
        #settings-page .content, #options-page .content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-group {
            margin-bottom: 30px; 
            padding: 15px;
            background-color: var(--input-bg);
            border-radius: var(--radius-default); 
            box-shadow: var(--shadow-light);
            border: 1px solid var(--input-border);
        }

        .settings-group h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-color-primary);
        }

        .settings-group label {
            display: block;
            margin: 15px 0 8px; 
            font-weight: bold;
            font-size: 14px;
            color: var(--text-color-primary);
        }

        .settings-group input:not([type="checkbox"]), 
.theme-switch-group button,
.options-save-btn,
.file-upload-btn,
.modal-content input {
    width: 100%;
    padding: 12px; 
    margin-bottom: 10px;
    border: 1px solid var(--input-border);
    border-radius: var(--radius-default); 
    background-color: var(--bg-color-secondary);
    color: var(--text-color-primary);
    box-sizing: border-box;
    transition: background-color 0.3s, border-color 0.3s;
}

/* 修复设置页面输入框颜色问题 */
#settings-page input[type="text"],
#settings-page input[type="password"],
#settings-page input[type="number"] {
    background-color: var(--input-bg) !important;
    border: 1px solid var(--input-border);
    border-radius: var(--radius-default);
    padding: 12px;
    width: 100%;
    color: var(--text-color-primary);
    box-sizing: border-box;
    transition: background-color 0.3s, border-color 0.3s;
}

#settings-page input[type="text"]:focus,
#settings-page input[type="password"]:focus,
#settings-page input[type="number"]:focus {
    outline: none;
    border-color: var(--accent-color);
    background-color: var(--input-bg) !important;
}

/* 专门为textarea添加样式，允许滚动 */
.settings-group textarea,
.modal-content textarea {
    width: 100%;
    padding: 12px; 
    margin-bottom: 10px;
    border: 1px solid var(--input-border);
    border-radius: var(--radius-default); 
    background-color: var(--bg-color-secondary);
    color: var(--text-color-primary);
    box-sizing: border-box;
    transition: background-color 0.3s, border-color 0.3s;
    resize: vertical !important;
    min-height: 80px;
    max-height: 300px;
    overflow-y: auto !important;
    scrollbar-width: thin;
}

/* 确保滚动条可见 */
.settings-group textarea::-webkit-scrollbar,
.modal-content textarea::-webkit-scrollbar {
    display: block;
    width: 6px;
}

.settings-group textarea::-webkit-scrollbar-thumb,
.modal-content textarea::-webkit-scrollbar-thumb {
    background-color: var(--input-border);
    border-radius: 3px;
}


        .options-save-btn, .theme-switch-group button {
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.1s ease;
        }

        .options-save-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 12px;
        }
        .options-save-btn:active {
            background-color: #0056b3;
            transform: scale(0.98);
        }

        /* ----------------------- 聊天室 (联系人) 页面样式 ----------------------- */
        #contacts-page .contacts-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 15px;
        }

        .contact-item {
            display: flex;
            align-items: center;
            padding: 15px 0; 
            border-bottom: 1px solid var(--input-border);
            cursor: pointer;
            transition: background-color 0.1s;
        }
        
        .contact-item:active { background-color: rgba(0, 0, 0, 0.05); } 
        
        /* 需求2: 删除按钮 */
        .delete-btn-wrapper {
            width: 0;
            overflow: hidden;
            transition: width 0.3s ease, margin-right 0.3s ease;
            margin-right: 0;
            display: flex;
            align-items: center;
        }
        .delete-btn-wrapper.show {
            width: 30px;
            margin-right: 10px;
        }
        .delete-icon {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background-color: var(--danger-color);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            line-height: 1;
            font-weight: bold;
        }

        /* 新增：批量删除选择框 */
        .contact-checkbox {
            width: 0;
            overflow: hidden;
            transition: width 0.3s ease, margin-right 0.3s ease;
            margin-right: 0;
            display: flex;
            align-items: center;
        }
        .contact-checkbox.show {
            width: 30px;
            margin-right: 10px;
        }
        
        .contact-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .contact-avatar {
            width: 45px;
            height: 45px;
            border-radius: 4px; /* 微信风格圆角 */
            background-color: var(--accent-color);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            margin-right: 15px;
            flex-shrink: 0;
            overflow: hidden;
        }
        .contact-avatar img { width: 100%; height: 100%; object-fit: cover; }


        /* ----------------------- 聊天窗口样式 ----------------------- */
        #chat-window { background-color: var(--bg-color-primary); }

        .chat-message { margin-bottom: 15px; display: flex; align-items: flex-start; width: 100%;}
        
        /* 需求4: AI在左边有头像，我在右边没头像 */
        .chat-message.ai { justify-content: flex-start; }
        .chat-message.user { justify-content: flex-end; }
        
        /* 确保AI的多个气泡之间有合适的间距 */
        .chat-message.ai {
            display: flex;
            /* 修改点：改为 flex-start 让头像和气泡顶部对齐 */
            align-items: flex-start; 
            margin-bottom: 15px;
        }

        .chat-message.ai .avatar {  
    width: 36px; 
    height: 36px; 
    margin-right: 8px; 
    flex-shrink: 0;
    border-radius: 8px; 
    /* 修改点：移除或调整顶部边距 */
    margin-top: 0; /* 将 4px 改为 0 */
}

.chat-message.ai:last-child {
    margin-bottom: 15px; /* 最后一个AI消息保持原来的间距 */
}

/* 确保用户消息和AI消息之间有正常间距 */
.chat-message.user {
    margin-bottom: 15px;
}

        .chat-message.user .avatar { display: none; } /* 用户无头像 */

        /* 需求4: 气泡圆角不要那么圆 (6px) */
        .chat-message .bubble {
            max-width: 70%;
            padding: 10px 12px;
            border-radius: var(--bubble-radius); 
            line-height: 1.4;
            font-size: 17px;
            font-family: "PingFang SC", -apple-system, sans-serif;
            word-wrap: break-word; 
            position: relative;
        }

       .chat-message.ai .bubble {
    background-color: var(--bg-color-secondary);
    color: var(--text-color-primary);
    padding: 10px 12px;
    border-radius: 6px;
    max-width: 70%;
    line-height: 1.4;
    cursor: pointer; /* 新增：显示为可点击 */
    transition: background-color 0.1s, transform 0.1s; /* 新增：过渡效果 */
}

/* 新增：点击时的反馈效果 */
.chat-message.ai .bubble:active {
    background-color: rgba(0, 0, 0, 0.05);
    transform: scale(0.99);
}

/* 深色模式适配 */
.dark-mode .chat-message.ai .bubble:active {
    background-color: rgba(255, 255, 255, 0.05);
}

        .chat-message.user .bubble {
    background-color: #95ec69;  /* 微信浅绿色 */
    color: black;              
    margin-right: 10px;
}

/* 白天模式保持不变，深色模式可以调整 */
.dark-mode .chat-message.user .bubble {
    background-color: #07C160;  /* 深色模式用微信绿 */
    color: black;
}
        
        /* 消息包装器 */
.messages-wrapper {
    flex: 1;
    position: relative;
    overflow: hidden;
}

/* 消息容器 */
.messages-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    overflow-y: auto;
    padding: 15px 0;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

/* 确保最后一条消息不被遮挡 */
.messages-container::after {
    content: '';
    display: block;
    height: 0px; /* 输入框高度 + 安全距离 */
}

/* ----------------------- 输入框区域 - iOS风格 ----------------------- */
.chat-input-area {
    flex-shrink: 0;
    padding: 12px 16px 16px 16px; /* 增加内边距，让输入框抬高 */
    display: flex;
    align-items: flex-end;
    background-color: var(--bg-color-secondary);
    border-top: 1px solid var(--input-border);
    box-sizing: border-box;
    /* 移除min-height，让高度自适应 */
}

/* ----------------------- 无边框iOS风格输入框 ----------------------- */
.chat-input-area {
    flex-shrink: 0;
    padding: 16px 16px 20px 16px; /* 保持抬高效果 */
    display: flex;
    align-items: center;
    background-color: var(--bg-color-secondary);
    /* 完全移除边框 */
    border-top: none;
    box-sizing: border-box;
    /* 轻微阴影保持悬浮感，但更柔和 */
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.04);
    z-index: 10;
}

.dark-mode .chat-input-area {
    box-shadow: 0 -2px 15px rgba(0, 0, 0, 0.15);
    background-color: var(--bg-color-secondary);
}

/* 输入框本身 - 无边框版本 */
.chat-input-area textarea {
    flex-grow: 1;
    resize: none;
    min-height: 36px;
    max-height: 100px;
    padding: 9px 16px;
    /* 移除边框 */
    border: none;
    /* 保持圆角 */
    border-radius: 19px;
    margin: 0;
     font-size: 17px;
    font-family: "PingFang SC", -apple-system, sans-serif !important;
    -webkit-font-smoothing: antialiased;
    font-synthesis: style weight;
    box-sizing: border-box;
    background-color: var(--input-bg);
    color: var(--text-color-primary);
    transition: all 0.2s ease;
    line-height: 1.4;
    
    /* 只用内部阴影，不要外部边框 */
    box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.08);
    
    /* 隐藏滚动条 */
    overflow: hidden;
    -webkit-overflow-scrolling: touch;
}

.dark-mode .chat-input-area textarea {
    background-color: rgba(118, 118, 128, 0.24);
    color: var(--text-color-primary);
    box-shadow: inset 0 1px 6px rgba(0, 0, 0, 0.2);
}

/* 聚焦状态 - 只用阴影表示 */
.chat-input-area textarea:focus {
    outline: none;
    background-color: var(--input-bg);
    /* 聚焦时内部阴影加深 */
    box-shadow: inset 0 1px 6px rgba(0, 0, 0, 0.12),
                0 0 0 1px rgba(0, 122, 255, 0.2); /* 非常细的聚焦指示 */
}

.dark-mode .chat-input-area textarea:focus {
    box-shadow: inset 0 0.1px 1px rgba(255, 255, 255, 0.3),
                0 0 0 0.1px rgba(255, 255, 255, 0.3);
}

/* 确保所有textarea都有相同样式 */
textarea {
    resize: none !important;
    font-family: inherit; /* 继承字体 */
}

/* 隐藏textarea的三角标（各个浏览器） */
textarea::-webkit-resizer {
    display: none !important;
}
textarea::-moz-resize {
    display: none !important;
}
textarea::-ms-resize {
    display: none !important;
}

/* 修改所有输入框的光标颜色 */
input, textarea {
    caret-color: #07C160; 
}

/* 深色模式下的光标颜色 */
.dark-mode input,
.dark-mode textarea {
    caret-color: #07C160; 
}

        /* ----------------------- 模态框/弹窗样式 ----------------------- */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 40;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: var(--bg-color-secondary);
            border-radius: var(--radius-default);
            width: 80%; 
            max-height: 80%;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

/* 新建角色弹窗优化样式 */
#new-contact-modal .modal-content {
    width: 85%;
    max-width: 400px;
    max-height: 85vh;
    padding: 24px;
    display: flex;
    flex-direction: column;
}

#new-contact-modal .modal-content h4 {
    margin-bottom: 24px;
    font-size: 20px;
    text-align: center;
    color: var(--text-color-primary);
}

#new-contact-modal .modal-scroll-area {
    flex: 1;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    margin-bottom: 16px;
}

#new-contact-modal .modal-scroll-area::-webkit-scrollbar {
    display: none;
}

#new-contact-modal .modal-content label {
    display: block;
    margin: 18px 0 8px 0;
    font-weight: 600;
    font-size: 15px;
    color: var(--text-color-primary);
}

#new-contact-modal .modal-content input,
#new-contact-modal .modal-content textarea {
    width: 100%;
    padding: 14px 16px;
    margin-bottom: 8px;
    border: 1px solid var(--input-border);
    border-radius: 12px;
    background-color: var(--bg-color-secondary);
    color: var(--text-color-primary);
    box-sizing: border-box;
    font-size: 16px;
}

#new-contact-modal .modal-content input:focus,
#new-contact-modal .modal-content textarea:focus {
    outline: none;
    /* 移除边框颜色变化和阴影 */
    border-color: var(--input-border);
}

#new-contact-modal .modal-content textarea:focus {
    min-height: 120px;
    line-height: 1.5;
}

#new-contact-modal .modal-footer {
    margin-top: 8px;
    padding-top: 20px;
    border-top: 1px solid var(--input-border);
}

#new-contact-modal .modal-footer button {
    padding: 14px 24px;
    font-size: 16px;
    font-weight: 600;
    border-radius: 12px;
}

/* 移除数字输入框箭头 */
input[type="number"] {
    -moz-appearance: textfield;
    appearance: textfield;
}

input[type="number"]::-webkit-outer-spin-button,
input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

#memory-content-container textarea {
    scrollbar-width: none;
    -ms-overflow-style: none;
    overflow-y: hidden; /* 强制隐藏垂直滚动条 */
}

#memory-content-container textarea::-webkit-scrollbar {
    display: none;
}

        .overlay.active .modal-content {
            transform: scale(1);
            opacity: 1;
        }

        .modal-content h4 { 
            margin-bottom: 20px; 
            color: var(--text-color-primary);
        }
        
        .modal-content label { 
            margin-top: 15px; 
            color: var(--text-color-primary);
        }

        .modal-footer {
            display: flex;
            justify-content: space-around;
            padding-top: 20px; 
            gap: 10px;
        }

        .modal-footer button {
            flex: 1;
            padding: 12px 10px;
            border-radius: var(--radius-default); 
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.1s ease;
        }
        
        .modal-footer button:active { transform: scale(0.96); }

        .modal-footer .save-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
        }

        .modal-footer .cancel-btn {
            background-color: var(--input-bg);
            color: var(--text-color-primary);
            border: 1px solid var(--input-border);
        }
        
        /* ----------------------- 选项页面 (Prompt/记忆/头像) ----------------------- */
        .options-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 0; 
            border-bottom: 1px solid var(--input-border);
            cursor: pointer;
            transition: background-color 0.1s;
        }
        .options-item:active { background-color: rgba(0, 0, 0, 0.05); }

        .options-item:last-child { border-bottom: none; }

        .options-item span { 
            font-weight: bold; 
            color: var(--text-color-primary);
        }
        
        .options-item .indicator {
            color: var(--text-color-secondary);
            font-weight: normal;
        }
        
        #memory-modal-title { 
            margin-bottom: 20px; 
            color: var(--text-color-primary);
        }

        /* 新增：批量删除工具栏 */
        .batch-toolbar {
            display: none;
            position: sticky;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-color-secondary);
            border-top: 1px solid var(--input-border);
            padding: 12px 15px;
            z-index: 5;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .batch-toolbar.show {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .batch-info {
            color: var(--text-color-primary);
            font-size: 14px;
        }
        
        .batch-delete-btn {
            background-color: var(--danger-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-default);
            cursor: pointer;
            font-weight: bold;
        }
        
        .batch-cancel-btn {
            background-color: var(--input-bg);
            color: var(--text-color-primary);
            border: 1px solid var(--input-border);
            padding: 8px 16px;
            border-radius: var(--radius-default);
            cursor: pointer;
            margin-right: 10px;
        }
        
        /* 新增：临时记忆对话框样式 */
        .round-container {
            margin-bottom: 20px;
            border: 1px solid var(--input-border);
            border-radius: var(--radius-default);
            padding: 15px;
            background-color: var(--input-bg);
        }
        
        /* 确保临时记忆对话框中的文本可滚动 */
.round-message {
    padding: 8px 12px;
    border-radius: 8px;
    background-color: var(--bg-color-secondary);
    border: 1px solid var(--input-border);
    color: var(--text-color-primary);
    max-height: 150px;
    overflow-y: auto !important;
    white-space: pre-wrap;
    word-break: break-word;
}

        /* 添加删除按钮样式 */
.round-header {
    font-weight: bold;
    margin-bottom: 10px;
    color: var(--text-color-primary);
    font-size: 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.round-delete-btn {
    background-color: var(--danger-color);
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    font-size: 18px;
    line-height: 1;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0;
    transition: transform 0.1s ease;
}

.round-delete-btn:hover {
    transform: scale(1.1);
}
        
        .round-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .round-message {
            padding: 8px 12px;
            border-radius: 8px;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--input-border);
            color: var(--text-color-primary);
        }
        
        .round-message.user {
            align-self: flex-end;
            background-color: #95ec69;
            color: #1c1c1e;
            max-width: 80%;
        }
        
        .round-message.ai {
            align-self: flex-start;
            background-color: var(--bg-color-secondary);
            max-width: 80%;
        }

        /* 新增：设置页头像设置区域 */
        .avatar-settings {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--input-border);
        }
        
        .avatar-preview-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .avatar-preview-label {
            margin-bottom: 10px;
            color: var(--text-color-primary);
            font-weight: bold;
        }
        
        .avatar-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* 新增：AI消息逐句显示效果 */
        .typing-indicator {
            display: flex;
            padding: 10px 14px;
            border-radius: var(--bubble-radius);
            background-color: var(--bg-color-secondary);
            margin-bottom: 5px;
        }
        
        .typing-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: var(--text-color-secondary);
            margin: 0 1px;
            animation: typing 1.5s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) { animation-delay: -0.3s; }
        .typing-dot:nth-child(2) { animation-delay: -0.15s; }
        .typing-dot:nth-child(3) { animation-delay: 0s; }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-3px); }
        }

        /* 新增：选择/取消全选按钮 */
        .select-all-btn {
            background-color: var(--warning-color);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
                  
        /* 清理按钮 - 简洁ins风 */
.clear-buttons {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 15px;
}

.clear-btn {
    display: flex;
    align-items: center;
    padding: 14px 16px;
    border-radius: 10px;
    border: 1px solid var(--input-border);
    font-size: 15px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    background: var(--bg-color-secondary);
    color: var(--text-color-primary);
}

.clear-btn:active {
    transform: scale(0.98);
}

.clear-short-btn {
    border-left: 4px solid #D39C70; 
}

.clear-long-btn {
    border-left: 4px solid #8A7FAC; 
}

.clear-icon {
    font-size: 18px;
    margin-right: 12px;
} 

.clear-short-btn .clear-icon {
    color: #D39C70; /* 图标也用陶土橙 */
}

.clear-long-btn .clear-icon {
    color: #8A7FAC; /* 图标也用灰紫色 */
}

/* 主题切换开关 - 容器 */
.theme-switch-container {
    display: flex;
    justify-content: center;
    margin: 15px 0;
}

/* 轨道（背景条） */
.theme-switch-track {
    position: relative;
    width: 68px;
    height: 34px;
    background: linear-gradient(90deg, #ffd700 0%, #007aff 100%);
    border-radius: 34px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    overflow: hidden;
}

/* 深色模式下的轨道 */
.dark-mode .theme-switch-track {
    background: #4a4a4a;
}

/* 圆形滑块 */
.theme-switch-thumb {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 30px;
    height: 30px;
    background: white;
    border-radius: 50%;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
    z-index: 2;
}

/* 深色模式下滑块位置（滑动到右侧） */
.dark-mode .theme-switch-thumb {
    left: calc(100% - 32px);
    background: #f5f5f7;
}

/* 两侧图标 */
.theme-icon-left,
.theme-icon-right {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-size: 14px;
    color: white;
    z-index: 1;
    transition: all 0.3s ease;
}

.theme-icon-left {
    left: 9px;
}

.theme-icon-right {
    right: 9px;
}

/* 深色模式下图标颜色 */
.dark-mode .theme-icon-left {
    color: #888;
}

.dark-mode .theme-icon-right {
    color: #ffd700;
}
/* 为主题模式标题添加样式 */
#settings-page .content > div:has(h4:contains("主题模式")) h4 {
    margin: 0 0 15px 0;
    text-align: center;
    color: var(--text-color-primary);
}

/* ----------------------- 修复记忆弹窗头部固定 ----------------------- */
        
        /* 1. 针对记忆弹窗：禁止整个卡片滚动，这样标题和底部按钮就会固定住 */
        #memory-modal .modal-content {
            overflow: hidden !important; 
        }

        /* 2. 让中间的内容容器填满剩余空间，并开启独立滚动 */
        #memory-content-container {
            flex-grow: 1;           /* 自动占据剩余高度 */
            overflow-y: auto;       /* 内容多了只在这里出现滚动条 */
            margin-bottom: 10px;    /* 和底部按钮保持距离 */
            padding-right: 5px;     /* 防止滚动条紧贴文字 */
            
            /* 针对不同浏览器的滚动条美化（可选） */
            scrollbar-width: thin; 
        }

/* ----------------------- 隐藏记忆弹窗中文本框的滚动条 ----------------------- */
        
        /* 针对 Chrome/Safari/Edge */
        #memory-content-container textarea::-webkit-scrollbar {
            display: none;
        }

        /* 针对 Firefox */
        #memory-content-container textarea {
            scrollbar-width: none; 
            -ms-overflow-style: none;
        }

/* 仅聊天界面滑动效果 */
#chat-window {
    position: absolute;
    top: 0px;
    bottom: 0;
    left: 0;
    right: 0;
    overflow: hidden;
}

/* 进入聊天界面时的动画 - 从右向左滑动 */
.slide-in-right {
    animation: slideInRight 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

/* 退出聊天界面时的动画 - 从左向右滑动 */
.slide-out-left {
    animation: slideOutLeft 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

/* 确保消息容器在动画开始时就是可见的 */
#chat-window.slide-in-right .messages-container {
    opacity: 1;
    transition: opacity 0.1s;
}

/* 修改动画，确保内容同时出现 */
@keyframes slideInRight {
    from {
        transform: translateX(100%);
    }
    to {
        transform: translateX(0);
    }
}

@keyframes slideOutLeft {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%); /* 向右滑出 */
        opacity: 0.9;
    }
}

/* 强制所有头像圆角 - Safari兼容 */
.avatar,
.chat-message.ai .avatar,
.contact-avatar {
    -webkit-border-radius: 8px !important;
    -moz-border-radius: 8px !important;
    border-radius: 4px !important;
    overflow: hidden !important;
}

/* 头像内的图片 */
.avatar img,
.chat-message.ai .avatar img,
.contact-avatar img {
    -webkit-border-radius: 8px !important;
    -moz-border-radius: 8px !important;
    border-radius: 8px !important;
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
}

/* 对于头像文字（非图片）也确保圆角 */
.contact-avatar:not(:has(img)) {
    -webkit-border-radius: 8px !important;
    -moz-border-radius: 8px !important;
    border-radius: 8px !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
}

/* ----------------------- AI消息操作菜单 ----------------------- */
.context-menu {
    position: fixed;
    background: transparent; /* 改为透明背景 */
    border: none; /* 去掉边框 */
    border-radius: 0; /* 去掉圆角 */
    box-shadow: none; /* 去掉阴影 */
    z-index: 9999;
    min-width: 40px; /* 缩小宽度 */
    overflow: visible; /* 允许内容超出 */
    backdrop-filter: none; /* 去掉模糊效果 */
    -webkit-backdrop-filter: none;
    animation: menuFadeIn 0.2s ease;
    padding: 0; /* 去掉内边距 */
    margin-left: -8px !important;
}

@keyframes menuFadeIn {
    from {
        opacity: 0;
        transform: translateY(-5px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.menu-item {
    padding: 0; /* 去掉内边距 */
    color: var(--text-color-primary); /* 使用文字颜色 */
    font-size: 24px; /* 稍微调大字体 */
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    white-space: nowrap;
    border-bottom: none;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40px;
    width: 40px;
    background: transparent; /* 透明背景 */
    border-radius: 0; /* 去掉圆角 */

     /* 新增：强制保持正方形 */
    aspect-ratio: 1 / 1; /* 宽高比1:1 */
    
    /* 针对不支持aspect-ratio的浏览器 */
    min-height: 40px;
    min-width: 40px;
}

/* 手机：更大的图标 */
@media screen and (max-width: 768px) {
    .context-menu {
        min-width: 60px !important;
    }
    .menu-item {
        font-size: 40px !important;
        height: 60px !important;
        width: 60px !important;

        aspect-ratio: 1 / 1 !important;
        min-height: 60px !important;
        min-width: 60px !important;
    }
}

.menu-item:hover {
    background-color: transparent;
    color: #95ec69; /* 鼠标悬停时用用户气泡颜色 */
}

.dark-mode .menu-item:hover {
    color: #07C160; /* 深色模式用深绿色 */
}

.menu-item:active {
    background-color: transparent; /* 去掉蓝色背景 */
    color: #95ec69; /* 点击时变成用户气泡的颜色 */
}

.dark-mode .menu-item:active {
    color: #07C160; /* 深色模式用深绿色 */
}
.context-menu::before {
    display: none; /* 隐藏小三角箭头 */
}

/* 温度滑块样式 - 简洁版 */
.temp-slider-container {
    padding: 12px 0;
}

.temp-slider-track {
    position: relative;
    width: 100%;
    height: 3px;
    background: rgba(0, 0, 0, 0.1);
    border-radius: 1.5px;
    cursor: pointer;
}

.dark-mode .temp-slider-track {
    background: rgba(255, 255, 255, 0.1);
}

.temp-slider-thumb {
    position: absolute;
    top: 50%;
    left: 35%;
    transform: translate(-50%, -50%);
    width: 18px;
    height: 18px;
    background: rgba(123, 158, 109, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 50%;
    box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.1),
        0 0 0 1px rgba(255, 255, 255, 0.3) inset;
    cursor: pointer;
    z-index: 2;
    transition: all 0.2s ease;
}

.temp-slider-thumb:hover {
    transform: translate(-50%, -50%) scale(1.1);
}

.temp-slider-thumb:active {
    cursor: grabbing;
    transform: translate(-50%, -50%) scale(0.95);
    background: rgba(136, 171, 218, 0.9);
}

.dark-mode .temp-slider-thumb {
    background: rgba(138, 174, 127, 0.8);
    box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(255, 255, 255, 0.1) inset;
}


/* 左侧按钮容器 */
.left-header-buttons {
    display: flex;
    align-items: center;
    gap: 1px;
     margin-left: 0;
}

/* 给齿轮单独的样式 */
.app-icon {
    cursor: pointer;
    font-size: 18px;
    color: var(--text-color-primary);
    padding: 8px;
    border-radius: 8px;
    transition: transform 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
}

/* 保留齿轮的缩放效果 */
.app-icon:hover {
    transform: scale(1.1);
}
.app-icon:hover {
    transform: scale(1.1); /* 改为缩放效果 */  
}

/* 刷新按钮样式 */
.refresh-btn {
    font-size: 18px;
    color: var(--text-color-primary); /* 改为和齿轮一样的颜色 */
    cursor: pointer;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    border-radius: 8px;
    min-width: 40px;
    min-height: 40px;
}

.refresh-btn:hover {
    /* 悬停时不转 */
}

.refresh-btn:active {
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* 新增：渐停动画 */
@keyframes spinToStop {
    0% { transform: rotate(var(--start-angle)); }
    100% { transform: rotate(var(--end-angle)); }
}

.refresh-btn.refreshing i {
    animation: spin 0.5s linear infinite;
}

/* 预设弹窗项样式 */
.preset-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.preset-item:active {
    transform: translateY(0);
}

/* 确保预设管理弹窗也有动画 */
#preset-modal .modal-content {
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

#preset-modal.active .modal-content {
    transform: scale(1);
    opacity: 1;
}

#preset-modal {
    transition: opacity 0.3s ease;
}

/* 模型选择弹窗样式 */
.model-item:active {
    background-color: var(--accent-color) !important;
    color: white !important;
}

.model-item:active div {
    color: white !important;
}

/* 滚动条美化 */
#model-list-container::-webkit-scrollbar {
    width: 6px;
}

#model-list-container::-webkit-scrollbar-thumb {
    background-color: var(--input-border);
    border-radius: 3px;
}

/* 自定义滚动条隐藏 */
#model-list-modal > div {
    overflow: hidden; /* 隐藏外部滚动条 */
}

/* 弹性滚动容器 */
#model-items-container {
    -webkit-overflow-scrolling: touch; /* iOS弹性滚动 */
    overscroll-behavior: contain; /* 防止滚动传播 */
    height: calc(70vh - 150px); /* 固定高度 */
    overflow-y: scroll; /* 启用滚动但隐藏滚动条 */
    scrollbar-width: none; /* Firefox隐藏滚动条 */
    -ms-overflow-style: none; /* IE隐藏滚动条 */
}

/* Chrome/Safari隐藏滚动条 */
#model-items-container::-webkit-scrollbar {
    display: none;
}

/* 强制隐藏所有滚动条 */
#model-list-modal ::-webkit-scrollbar {
    display: none !important;
    width: 0 !important;
    height: 0 !important;
    background: transparent !important;
}

#model-list-modal ::-webkit-scrollbar-track {
    display: none !important;
    background: transparent !important;
}

#model-list-modal ::-webkit-scrollbar-thumb {
    display: none !important;
    background: transparent !important;
}

#model-list-modal ::-webkit-scrollbar-corner {
    display: none !important;
    background: transparent !important;
}

/* Firefox隐藏滚动条 */
#model-list-modal {
    scrollbar-width: none !important;
}

/* 模型列表容器特殊处理 */
#model-items-container {
    -webkit-overflow-scrolling: touch !important;
    scrollbar-width: none !important;
    -ms-overflow-style: none !important;
}

#model-items-container::-webkit-scrollbar {
    display: none !important;
    width: 0 !important;
    height: 0 !important;
}

/* 强制隐藏模型弹窗的所有滚动条 */
#model-list-modal *::-webkit-scrollbar {
    display: none !important;
    width: 0 !important;
    height: 0 !important;
}

#model-items-container {
    -webkit-overflow-scrolling: touch !important;
    scrollbar-width: none !important;
    -ms-overflow-style: none !important;
}

/* 预设操作按钮样式 */
.preset-edit-btn, .preset-delete-btn {
    width: 30px;
    height: 30px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s;
}

.preset-edit-btn {
    background: var(--accent-color);
    color: white;
}

.preset-delete-btn {
    background: var(--danger-color);
    color: white;
    font-size: 18px;
    font-weight: bold;
}

.preset-edit-btn:hover, .preset-delete-btn:hover {
    transform: scale(1.1);
}

/* 编辑预设弹窗动画 */
#edit-preset-modal {
    animation: modalFadeIn 0.3s ease;
}

/* 弹窗动画 */
@keyframes modalFadeIn {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes modalFadeOut {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(20px);
    }
}

/* 现有的模态框动画增强 */
.overlay.active .modal-content {
    transform: scale(1);
    opacity: 1;
}

.modal-content {
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

/* 动态创建的弹窗也统一动画 */
#edit-preset-modal,
#model-list-modal,
#model-list-edit-modal {
    animation: modalFadeIn 0.3s ease;
}
/* 手机专用弹窗样式 */
@media screen and (max-width: 768px) {
    /* 所有弹窗内容 */
    .modal-content,
    #preset-modal .modal-content,
    #new-contact-modal .modal-content,
    #memory-modal .modal-content {
        width: 90% !important;
        max-width: 300px !important;
        max-height: 70vh !important;
        padding: 20px !important;
        margin: 10px !important;
    }
    
    /* 编辑预设弹窗 */
    #edit-preset-modal > div {
        width: 90% !important;
        max-width: 300px !important;
        padding: 20px !important;
    }
    
    /* 模型选择弹窗 */
    #model-list-modal > div,
    #model-list-edit-modal > div {
        width: 90% !important;
        max-width: 320px !important;
    }
    
    /* 弹窗内部标题 */
    .modal-content h4 {
        font-size: 18px !important;
        margin-bottom: 15px !important;
    }
    
    /* 弹窗内部输入框 */
    .modal-content input,
    .modal-content textarea {
        padding: 10px !important;
        font-size: 16px !important;
    }
    
    /* 弹窗按钮 */
    .modal-footer button {
        padding: 12px 16px !important;
        font-size: 16px !important;
    }
}
   </style>
</head>
<body>

    <div class="phone-frame" id="phone-frame">
        <div class="phone-screen" id="phone-screen">
                        <div class="status-bar">
                <!-- 需求4: 时间/信号/电量都去掉 -->
            </div>
            
            <div id="contacts-page" class="page" style="display: flex;">
               <div class="page-header" style="justify-content: space-between;">
    <div style="display: flex; align-items: center;">
        <div class="app-icon clickable" onclick="showPage('settings-page')" title="设置" style="margin-left: -15px; margin-right: -15px;">
    <i class="fas fa-cog"></i>
</div>
<div class="refresh-btn clickable" onclick="refreshAllData();" title="刷新所有数据">
            <i class="fa-solid fa-rotate"></i>
        </div>
        <div class="refresh-btn clickable" onclick="emergencyFix();" title="紧急修复" style="color: var(--danger-color);">
            <i class="fa-solid fa-wrench"></i>
        </div>
    </div>
    <h3 class="small-title" style="position: static; transform: none; left: auto; width: auto;">聊天室</h3>
    <div style="display: flex; align-items: center;">
        <div class="manage-button clickable" onclick="toggleManageMode()">管理</div>
        <div class="action-button plus-btn clickable" onclick="prepareRoleModal(null)"><i class="fa-solid fa-plus"></i></div>
    </div>
</div>
                <div id="contacts-list" class="contacts-list">
</div>
                <!-- 批量删除工具栏 -->
                <div id="batch-toolbar" class="batch-toolbar">
                    <div>
                        <button class="batch-cancel-btn clickable" onclick="cancelBatchDelete()">取消</button>
                        <button class="select-all-btn clickable" onclick="toggleSelectAll()">全选</button>
                    </div>
                    <div class="batch-info" id="selected-count">已选择 0 项</div>
                    <button class="batch-delete-btn clickable" onclick="deleteSelectedContacts()">删除</button>
                </div>
            </div>

            <div id="settings-page" class="page">
                <div class="page-header">
                    <div class="back-button" onclick="showPage('contacts-page')"><i class="fa-solid fa-angle-left"></i></div>
                    <h3>设置</h3>
                </div>
                <div class="content">
                    
<div style="display: flex; justify-content: space-between; gap: 10px; margin-bottom: 20px;">
    
    <div style="flex: 1; display: flex; align-items: center; justify-content: space-between; padding: 15px; background-color: var(--input-bg); border-radius: var(--radius-default); border: 1px solid var(--input-border);">
        <h4 style="font-size: 16px;">主题</h4>
        <div class="theme-switch-container" style="margin: 0;">
            <div class="theme-switch-track clickable" onclick="toggleThemeAuto()">
                <div class="theme-switch-thumb"></div>
                <i class="fas fa-sun theme-icon-left"></i>
                <i class="fas fa-moon theme-icon-right"></i>
            </div>
        </div>
    </div>

    <div style="flex: 1; display: flex; align-items: center; justify-content: space-between; padding: 15px; background-color: var(--input-bg); border-radius: var(--radius-default); border: 1px solid var(--input-border);">
        <h4 style="font-size: 16px;">保活</h4>
        <div class="theme-switch-container" style="margin: 0;">
            <div class="theme-switch-track clickable" onclick="toggleKeepAlive()" id="keep-alive-switch" style="background: var(--input-border);">
                <div class="theme-switch-thumb" style="left: 2px;"></div>
                <i class="fas fa-lock theme-icon-left" style="color: #888; font-size: 10px; left: 8px;"></i>
                <i class="fas fa-infinity theme-icon-right" style="color: #ffd700; font-size: 10px; right: 8px;"></i>
            </div>
        </div>
    </div>
</div>

<audio id="silent-audio" loop playsinline preload="auto" style="display:none;">
    <source src="https://raw.githubusercontent.com/anars/blank-audio/master/10-seconds-of-silence.mp3" type="audio/mpeg">
</audio>
<div class="settings-group">
    <h4>API 配置</h4>
    
    <!-- 预设选择 -->
    <label>配置名称:</label>
    <input type="text" id="api-preset-display" readonly 
           style="width: 100%; padding: 12px; margin-bottom: 10px; border-radius: var(--radius-default); 
                  background: var(--input-bg); color: var(--text-color-primary); 
                  border: 1px solid var(--input-border); cursor: pointer; 
                  font-size: 16px; box-sizing: border-box;"
           value="新建配置"
           onclick="openPresetManager()">
    
    <!-- 【新增】当前预设的模型选择（默认隐藏） -->
    <div id="current-preset-model-container" style="display: none; margin-bottom: 10px;">
        <label for="current-preset-model">当前模型:</label>
        <input type="text" id="current-preset-model" readonly
               style="width: 100%; padding: 12px; margin-top: 5px; border: 1px solid var(--input-border); 
                      border-radius: var(--radius-default); background-color: var(--input-bg); 
                      color: var(--text-color-primary); cursor: pointer; 
                      font-size: 16px; box-sizing: border-box;"
               onclick="openCurrentPresetModelSelector()"
               placeholder="点击选择模型">
    </div>
    
    <!-- 当没有预设时隐藏的区域 -->
    <div id="api-fields-container" style="display: none;">
        <!-- API URL -->
        <label for="api-url">API URL:</label>
        <input type="text" id="api-url" placeholder="输入 API URL">
        
        <!-- API Key -->
        <label for="api-key">API Key:</label>
        <input type="password" id="api-key" placeholder="输入您的 API Key">

        <!-- 【修改】模型选择（用于新建配置） -->
        <label for="ai-model" style="margin-top: 15px;">AI 模型:</label>
        <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="ai-model" readonly 
                   style="width: 100%; padding: 12px; margin-top: 5px; border: 1px solid var(--input-border); 
                          border-radius: var(--radius-default); background-color: var(--input-bg); 
                          color: var(--text-color-primary); cursor: pointer; 
                          font-size: 16px; box-sizing: border-box;"
                   onclick="openModelSelector()" 
                   placeholder="点击选择模型">
        </div>
        
        <!-- 保存为预设按钮 -->
        <button id="save-preset-btn" onclick="saveAsPreset()" 
                style="width: 100%; padding: 12px; margin-top: 15px; 
                       border-radius: var(--radius-default); background: var(--accent-color); 
                       color: white; border: none; cursor: pointer;">
            保存为预设
        </button>
    </div>
</div>
    
    <div class="settings-group">
    <h4>模型参数</h4>

    <!-- 流式输出开关 -->
    <div style="margin-bottom: 20px;">
    <div style="display: flex; align-items: center; margin-bottom: 8px;">
        <label style="font-weight: bold; font-size: 14px; color: var(--text-color-primary); margin-right: 10px;">流式输出</label>
        <div class="theme-switch-track clickable" 
             style="width: 40px; height: 20px; background: var(--input-border); margin-top: 9px;" 
             onclick="toggleStream()" 
             id="stream-switch">
            <div class="theme-switch-thumb" style="width: 18px; height: 18px; top: 1px; left: 1px;"></div>
        </div>
     </div>
    </div>

    <label style="margin-top: 10px; display: block;">温度 (Temperature): 
        <span id="temperature-value" style="font-weight: bold; color: var(--accent-color);">0.7</span>
    </label>
    <div class="temp-slider-container" style="margin: 12px 0 8px;">
        <div class="temp-slider-track" id="temp-track">
            <div class="temp-slider-thumb" id="temp-slider-thumb"></div>
        </div>
    </div>
    <input type="hidden" id="temperature" value="0.7">

    <div style="height: 15px;"></div> <label style="display: block;">最大回复长度 (Max Tokens): 
        <span id="maxTokens-value" style="font-weight: bold; color: var(--accent-color);">2048</span>
    </label>
    <div class="temp-slider-container" style="margin: 12px 0 8px;">
        <div class="temp-slider-track" id="maxTokens-track">
            <div class="temp-slider-thumb" id="maxTokens-thumb"></div>
        </div>
    </div>
    <input type="hidden" id="maxTokens-input" value="2048">
    
    <p style="font-size: 11px; color: var(--text-color-secondary); margin-top: 10px;">
        提示：温度影响创造力，Token 影响回复长度。
    </p>
</div>

    <!-- 新增：预设与正则管理模块 -->
<div class="settings-group">
    <h4>预设与正则管理</h4>
    
    <!-- 预设管理 -->
    <div style="margin-bottom: 10px;">
        <div style="display: flex; align-items: center; margin-bottom: 8px;">
            <label style="font-weight: bold; font-size: 14px; color: var(--text-color-primary); margin-right: 10px;">预设 (Deep Preset)</label>
            <div class="theme-switch-track clickable" style="width: 40px; height: 20px; background: var(--input-border); margin-top: 10px;" onclick="toggleDeepPreset()" id="deep-preset-switch">
                <div class="theme-switch-thumb" style="width: 18px; height: 18px; top: 1px; left: 1px;"></div>
            </div>
        </div>
        
        <input type="text" id="deep-preset-display" readonly 
               style="width: 100%; padding: 10px 12px; border-radius: var(--radius-default); 
                      background: var(--input-bg); color: var(--text-color-primary); 
                      border: 1px solid var(--input-border); cursor: pointer; 
                      font-size: 14px; box-sizing: border-box;"
               value="未选择预设"
               onclick="openDeepPresetManager()">
    </div>
    
    <!-- 正则管理 -->
    <div>
        <div style="display: flex; align-items: center; margin-bottom: 8px;">
            <label style="font-weight: bold; font-size: 14px; color: var(--text-color-primary); margin-right: 10px;">正则 (Regex)</label>
            <div class="theme-switch-track clickable" style="width: 40px; height: 20px; background: var(--input-border); margin-top: 10px" onclick="toggleRegex()" id="regex-switch">
                <div class="theme-switch-thumb" style="width: 18px; height: 18px; top: 1px; left: 1px;"></div>
            </div>
        </div>
        
        <input type="text" id="regex-display" readonly 
               style="width: 100%; padding: 10px 12px; border-radius: var(--radius-default); 
                      background: var(--input-bg); color: var(--text-color-primary); 
                      border: 1px solid var(--input-border); cursor: pointer; 
                      font-size: 14px; box-sizing: border-box;"
               value="未选择正则"
               onclick="openRegexManager()">
    </div>
</div>

<!-- 预设管理弹窗 -->
<div id="deep-preset-modal" class="overlay" style="z-index: 9999;">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;">
        <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">预设管理</h4>
        
        <div style="max-height: 50vh; overflow-y: auto; margin-bottom: 20px;" id="deep-preset-list">
            <!-- 预设列表会动态生成在这里 -->
            <div style="text-align: center; padding: 30px; color: var(--text-color-secondary);">
                <div style="font-size: 36px; margin-bottom: 10px;">📁</div>
                <div>无预设</div>
            </div>
        </div>
        
        <div style="display: flex; gap: 12px; justify-content: center;">
            <button onclick="importDeepPresetFile()" 
                    style="padding: 10px 20px; border-radius: 8px; background: var(--accent-color); 
                           color: white; border: none; cursor: pointer;">导入</button>
            <button onclick="hideModal('deep-preset-modal')" 
                    style="padding: 10px 20px; border-radius: 8px; background: var(--input-bg); 
                           color: var(--text-color-primary); border: 1px solid var(--input-border); 
                           cursor: pointer;">关闭</button>
        </div>
    </div>
</div>

<!-- 正则管理弹窗 -->
<div id="regex-modal" class="overlay" style="z-index: 9999;">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;">
        <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">正则管理</h4>
        
        <div style="max-height: 50vh; overflow-y: auto; margin-bottom: 20px;" id="regex-list">
            <!-- 正则列表会动态生成在这里 -->
            <div style="text-align: center; padding: 30px; color: var(--text-color-secondary);">
                <div style="font-size: 36px; margin-bottom: 10px;">📄</div>
                <div>无正则</div>
            </div>
        </div>
        
        <div style="display: flex; gap: 12px; justify-content: center;">
            <button onclick="importRegexFile()" 
                    style="padding: 10px 20px; border-radius: 8px; background: var(--accent-color); 
                           color: white; border: none; cursor: pointer;">导入</button>
            <button onclick="hideModal('regex-modal')" 
                    style="padding: 10px 20px; border-radius: 8px; background: var(--input-bg); 
                           color: var(--text-color-primary); border: 1px solid var(--input-border); 
                           cursor: pointer;">关闭</button>
        </div>
    </div>
</div>                
<div class="settings-group">
    <h4>记忆配置</h4>
    
    <label for="context-limit">携带历史轮数 (临时记忆):</label>
    <p style="font-size: 12px; color: var(--text-color-secondary); margin-top: 2px; margin-bottom: 8px;">发送给AI的最近对话轮数（1轮=我问+AI答）。</p >
    <input type="number" id="context-limit" value="10" placeholder="默认 10">
    
    <label for="diary-interval">自动写日记频率 (轮数):</label>
    <p style="font-size: 12px; color: var(--text-color-secondary); margin-top: 2px; margin-bottom: 8px;">每隔多少轮对话，让AI总结一次长期记忆。</p >
    <input type="number" id="diary-interval" value="10" placeholder="默认 10">
</div>
                    <!-- 新增：头像设置区域 -->
                    <div class="settings-group avatar-settings">
                        <h4>AI 头像设置</h4>
                        <div class="avatar-preview-container">
                            <div class="avatar-preview-label">当前头像预览</div>
                            <div id="current-ai-avatar-preview" class="contact-avatar" style="width: 80px; height: 80px; font-size: 36px;"></div>
                            <input type="file" id="ai-avatar-file" accept="image/*" style="display: none;">
                            <input type="hidden" id="ai-avatar-base64">
                                                                                                                                                                                                                        <div class="avatar-actions" style="display: flex; gap: 10px;">
                                <button class="file-upload-btn clickable" onclick="document.getElementById('ai-avatar-file').click()" style="padding: 8px 15px; font-size: 14px; height: 36px; border: none; background: var(--accent-color); color: white; border-radius: 8px; white-space: nowrap;">上传新头像</button>
                                <button class="clickable" onclick="resetAvatar()" style="padding: 8px 15px; font-size: 14px; height: 36px; background-color: var(--input-bg); color: var(--text-color-primary); border: 1px solid var(--input-border); border-radius: 8px; white-space: nowrap;">重置</button>
                            </div>
                        </div>
                    </div>
                    
<div class="settings-group">
    <h4>通知服务</h4>
    <div style="display: flex; justify-content: center;">
        <button id="push-auth-btn" onclick="requestPushPermission()" 
                style="flex: 1; padding: 12px; background: var(--accent-color); color: white; 
                       border: none; border-radius: 10px; font-size: 15px; font-weight: 500; 
                       cursor: pointer; transition: all 0.2s;">
            允许接收通知
        </button>
    </div>
</div>

                                        <!-- 数据管理 -->
<div class="settings-group">
    <h4>数据管理</h4>
    <div style="margin-bottom: 12px; padding: 10px; background: var(--input-bg); border-radius: 8px;">
        <div style="display: flex; justify-content: space-between; font-size: 14px;">
            <span style="color: var(--text-color-primary);">已占用缓存:</span>
            <span id="cache-size" style="font-weight: bold; color: var(--accent-color);">计算中...</span>
        </div>
        <div style="height: 4px; background: var(--input-border); border-radius: 2px; margin-top: 8px; overflow: hidden;">
            <div id="cache-progress" style="height: 100%; background: var(--accent-color); width: 0%; transition: width 0.3s;"></div>
        </div>
    </div>

    <div style="display: flex; gap: 10px;">
        <button onclick="exportData()" style="flex:1; padding: 10px; background: var(--accent-color); color: white; border: none; border-radius: 10px;">导出数据</button>
        <button onclick="importData()" style="flex:1; padding: 10px; background: var(--input-bg); color: var(--text-color-primary); border: 1px solid var(--input-border); border-radius: 10px;">导入数据</button>
    </div>
</div>

<button onclick="saveSettings()" class="options-save-btn clickable">保存配置</button>
                    
                    
                </div>
            </div>
            
            <!-- 修改chat-window的结构 -->
<div id="chat-window" class="page">
    <div class="page-header">
        <div class="back-button" onclick="exitChatWindow()"><i class="fa-solid fa-angle-left"></i></div>
        <h3 id="chat-role-name"></h3> 
        <div class="action-button clickable" onclick="showPage('options-page')">···</div>
    </div>
    
    <!-- 新增：消息容器包装器 -->
    <div class="messages-wrapper">
        <div id="chat-messages" class="messages-container">
    <div id="loading-more" style="display:none; text-align:center; padding:10px; color:var(--text-color-secondary);">加载中...</div>
</div>
    </div>

    <div class="chat-input-area">
        <textarea id="chat-textarea" rows="1"></textarea>
    </div>
</div>
            
<!-- AI消息操作菜单 -->
<div id="ai-context-menu" class="context-menu" style="display: none;">
    <div class="menu-item clickable" onclick="regenerateFromBubble()">⟳</div>
</div>

                        <div id="options-page" class="page">
                <div class="page-header">
                    <div class="back-button" onclick="showPage('chat-window')"><i class="fa-solid fa-angle-left"></i></div>
                    <h3 id="options-role-name"></h3> 
                </div>
                <div class="content">
                    <div class="settings-group">
                       
                    <div class="options-item clickable" onclick="showMemoryModal('prompt')">
                            <span>角色 Prompt</span>
                            <span class="indicator">修改 ❯</span>
                        </div>
                        
                        <div class="options-item clickable" onclick="showMemoryModal('short')">
                            <span>临时记忆</span>
                            <span class="indicator">查看/编辑 ❯</span>
                        </div>
                        
                        <div class="options-item clickable" onclick="showMemoryModal('long')">
                            <span>长期记忆</span>
                            <span class="indicator">查看/编辑 ❯</span>
                        </div>
                    </div>
                    
                    <!-- 新增：清理记忆区域 -->
                    <div class="settings-group">
                        <h4 style="color: var(--warning-color); display: flex; align-items: center;">
    <i class="fas fa-eraser" style="margin-right: 10px;"></i>
    清理记忆
</h4>
                        <p style="color: var(--text-color-secondary); margin-top: 0; font-size: 14px;">这些操作不可撤销，请谨慎使用</p>
                        
                        <div class="clear-buttons">
                        <button class="clear-btn clear-short-btn clickable" onclick="clearShortTermMemory()">
                            <span class="clear-icon"><i class="fas fa-broom"></i></span>
                            <span>清空临时记忆</span>
                        </button>
                        
                        <button class="clear-btn clear-long-btn clickable" onclick="clearLongTermMemory()">
                            <span class="clear-icon"><i class="fas fa-trash-alt"></i></span>
                            <span>清空长期记忆</span>
                        </button>
                    </div>
                    </div>
                </div>
            </div>
            
            <div id="new-contact-modal" class="overlay">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;">
        <h4 id="modal-role-title">新建角色</h4>
        
        <div class="modal-scroll-area">
            <label for="modal-role-name">角色名:</label>
            <input type="text" id="modal-role-name" placeholder="例如: 心理导师">
            
            <label for="modal-role-prompt">角色设定 Prompt:</label>
            <textarea id="modal-role-prompt" rows="8" placeholder="填写对应的角色名和相关prompt"></textarea>
            
            <input type="hidden" id="modal-role-id">
        </div>
        
        <div class="modal-footer">
            <button class="cancel-btn clickable" onclick="hideModal('new-contact-modal')">取消</button>
            <button class="save-btn clickable" onclick="saveRoleFromModal()">保存</button>
        </div>
    </div>
</div>
            
           <div id="memory-modal" class="overlay">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;"> 
                    <div style="display: flex; align-items: center; margin-bottom: 15px;">
                        <div class="back-button clickable" onclick="goBackInMemoryModal()" style="margin-right: 15px;">
    <i class="fa-solid fa-angle-left"></i>
</div>
                        <h4 id="memory-modal-title" style="margin: 0; flex-grow: 1;"></h4>
                    </div>
                    
                    <div id="memory-content-container"></div>
                    
                    <div class="modal-footer">
                        <button id="memory-save-btn" class="save-btn clickable" onclick="saveContextModalData()">保存修改</button>
                        <button class="cancel-btn clickable" onclick="hideModal('memory-modal')">关闭</button>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
     // Web Push 配置
        const VAPID_PUBLIC_KEY = 'BB0Y_7xT1-C-_I-TgXqFPUrgi2iuo5gkgkUbtuwBn5ganWvdraCOniES3ocdaTDEWVFqrAw5jGvJuKrskKuFY00'; // 替换为您生成的公钥
        const WORKER_URL = 'https://lkgo-push.ginkgo-yinxing.workers.dev';

	// 初始化分词器，指定中文环境 
	const segmenter = new Intl.Segmenter('zh-Hans', { granularity: 'word' });

	// 简单的停用词表（可以根据需要增加）
	const stopWords = new Set(['的', '了', '是', '我', '你', '他', '在', '不', '有', '个', '也', '就']);

    function extractKeywords(text) {
        // 1. 使用浏览器原生能力进行分词 
        const segments = segmenter.segment(text);
        const keywords = [];

        for (const segment of segments) {
            // 只保留“词语”类型，且长度大于1，且不是废词 
            if (segment.isWordLike && segment.segment.length > 1 && !stopWords.has(segment.segment)) {
                keywords.push(segment.segment);
            }
        }
        return keywords;
    }

        function calculateMemoryScore(queryKeywords, memoryKeywords) {
        let score = 0;
        queryKeywords.forEach(qKey => {
            if (memoryKeywords.includes(qKey)) {
                // 匹配到的词越长，分数越高（加权评分）
                score += qKey.length; 
            }
        });
        return score;
    }

        // 核心数据
        let APP_DATA = JSON.parse(localStorage.getItem('AI_PHONE_APP_DATA')) || {
    contacts: [
        { 
            id: 1, 
            name: '心理导师', 
            prompt: '你是一位专业的心理导师，以温暖、同情和专业的态度回复用户的问题。', 
            history: [], 
            longMemories: [], // 改为数组
            shortTermMemory: [],
            summaryCount: 0,
            summaryThreshold: 30
        },
        { 
            id: 2, 
            name: '英语陪练', 
            prompt: '你是一位只说英语的口语陪练，每句话都必须是英语。', 
            history: [], 
            longMemories: [], // 改为数组
            shortTermMemory: [],
            summaryCount: 0,
            summaryThreshold: 30
        }
    ],
            settings: {
            apiUrl: 'https://api.siliconflow.cn/v1/chat/completions',
            apiKey: '',
            aiModel: 'qwen-72b-chat',
            temperature: 0.7,
            aiAvatarBase64: 'AI',
            contextLimit: 20,
            diaryInterval: 20,
            stream: false  
        },
            currentTheme: 'light',
            currentChatId: null,
            activeModalContext: null,
            presets: [], 
            currentPresetId: null, // 当前预设ID
            // 新增：深预设和正则数据
            deepPresets: [],        // 深预设数组
            regexPatterns: [],      // 正则表达式数组
            currentDeepPresetId: null,  // 当前选中的深预设ID
            currentRegexId: null,       // 当前选中的正则ID
            deepPresetEnabled: false,   // 深预设是否启用
            regexEnabled: false         // 正则是否启用
        };  // <-- 确保这里的分号

            let currentContact = null;
            let isManageMode = false; // 管理模式状态
            let batchMode = false; // 批量删除模式
            let selectedContacts = new Set(); // 选择的联系人ID集合
            let isTyping = false; // AI是否正在输入
            let currentAIRequest = null; // 新增：存储当前AI请求
            let currentController = null; // 新增：用于取消请求的控制器
            let currentStartIndex = 0;
            const PAGE_SIZE = 10; 
            let isLoadingMore = false; 
        
        // ----------------------- 数据存储和加载 -----------------------
        function saveData() {
            localStorage.setItem('AI_PHONE_APP_DATA', JSON.stringify(APP_DATA));
        }

        function loadSettings() {
            document.getElementById('api-url').value = APP_DATA.settings.apiUrl;
            document.getElementById('api-key').value = APP_DATA.settings.apiKey;
            document.getElementById('ai-model').value = APP_DATA.settings.aiModel;
            document.getElementById('temperature').value = APP_DATA.settings.temperature || 0.7;
            document.getElementById('maxTokens-input').value = APP_DATA.settings.maxTokens || 2048; // 新增加载项
            document.getElementById('context-limit').value = APP_DATA.settings.contextLimit || 20;
            document.getElementById('diary-interval').value = APP_DATA.settings.diaryInterval || 10;
            
            loadAvatarPreview(APP_DATA.settings.aiAvatarBase64, 'current-ai-avatar-preview');
            document.getElementById('ai-avatar-base64').value = APP_DATA.settings.aiAvatarBase64;
            
            // 【新增】加载当前配置的显示
            if (APP_DATA.currentPresetId) {
                const preset = APP_DATA.presets.find(p => p.id == APP_DATA.currentPresetId);
                if (preset) {
                    document.getElementById('api-preset-display').value = preset.name;
                    document.getElementById('save-preset-btn').style.display = 'none';
                    document.getElementById('api-fields-container').style.display = 'none';
                    // 新增：加载深预设和正则设置
                    loadDeepPresetAndRegexSettings();
                    // 加载流式开关状态
                    updateSwitchState('stream-switch', APP_DATA.settings.stream || false);

                }
            }
        }
        
        // 新增：初始化预设系统
function initPresetSystem() {
    const apiFieldsContainer = document.getElementById('api-fields-container');
    const modelContainer = document.getElementById('current-preset-model-container');
    
    // 确保预设数组存在
    if (!APP_DATA.presets) {
        APP_DATA.presets = [];
    }
    
    console.log('初始化配置系统，配置数量:', APP_DATA.presets.length);
    
    if (APP_DATA.presets.length === 0) {
        // 没有配置，显示新建配置状态
        document.getElementById('api-preset-display').value = '新建配置';
        document.getElementById('save-preset-btn').style.display = 'block';
        APP_DATA.currentPresetId = null;
        
        // 【新增】隐藏当前预设模型选择框
        if (modelContainer) {
            modelContainer.style.display = 'none';
        }
        
        // 显示 API 输入字段（因为是新建配置状态）
        if (apiFieldsContainer) {
            apiFieldsContainer.style.display = 'block';
        }
    } else {
        // 如果有配置，加载第一个或当前配置
        if (APP_DATA.currentPresetId) {
            loadPreset(APP_DATA.currentPresetId);
        } else {
            loadPreset(APP_DATA.presets[0].id);
        }
    }
}


// 显示预设管理弹窗（简单版）
function showPresetModal() {
    refreshPresetList(); // 刷新列表
    showModal('preset-modal'); // 显示弹窗
}

// 新增：在弹窗中编辑预设
function editPresetInModal(presetId, event) {
    event.stopPropagation();
    
    const preset = APP_DATA.presets.find(p => p.id == presetId);
    if (!preset) return;
    
    const newName = prompt('修改配置名称:', preset.name);
    if (newName && newName.trim()) {
        preset.name = newName.trim();
        saveData();
        showPresetModal(); // 刷新弹窗
    }
}

// 新增：在弹窗中删除配置
function deletePresetInModal(presetId, event) {
    event.stopPropagation();
    
    if (!confirm('确定要删除这个配置吗？')) return;
    
    // 从数组中删除
    APP_DATA.presets = APP_DATA.presets.filter(p => p.id != presetId);
    
    // 如果删的是当前配置
    if (APP_DATA.currentPresetId == presetId) {
        // 如果还有配置，切换到第一个
        if (APP_DATA.presets.length > 0) {
            loadPreset(APP_DATA.presets[0].id);
        } else {
            // 没有配置了，回到新建状态
            document.getElementById('api-preset-display').value = '新建配置';
            document.getElementById('api-url').value = '';
            document.getElementById('api-key').value = '';
            document.getElementById('ai-model').value = '';
            document.getElementById('save-preset-btn').style.display = 'block';
            APP_DATA.currentPresetId = null;
        }
    }
    
    saveData();
    showPresetModal(); // 刷新弹窗
}

function loadPreset(presetId) {
    const preset = APP_DATA.presets.find(p => p.id == presetId);
    const apiFieldsContainer = document.getElementById('api-fields-container');
    const modelContainer = document.getElementById('current-preset-model-container');
    
    if (!preset) {
        console.log('未找到配置:', presetId);
        return;
    }

    console.log('加载配置:', preset.name);
    
    APP_DATA.currentPresetId = presetId;
    document.getElementById('api-preset-display').value = preset.name;
    
    // 【新增】记录最后使用时间
    preset.lastUsedTime = Date.now();
    
    // 【新增】显示当前配置的模型选择框
    if (modelContainer) {
        modelContainer.style.display = 'block';
        document.getElementById('current-preset-model').value = preset.defaultModel || '';
    }
    
    // 【新增】隐藏新建配置区域（如果有配置）
    if (apiFieldsContainer) {
        apiFieldsContainer.style.display = 'none';
    }
    document.getElementById('save-preset-btn').style.display = 'none';
    
    // 同步到settings
    APP_DATA.settings.apiUrl = preset.apiUrl || '';
    APP_DATA.settings.apiKey = preset.apiKey || '';
    APP_DATA.settings.aiModel = preset.defaultModel || '';
    
    // 保存当前状态
    saveData();
}

// 新增：创建新配置（从弹窗）
function createNewPreset() {
    hideModal('preset-modal');
    selectPreset('new');
}

/// 保存为配置（简单版）
function saveAsPreset() {
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const model = document.getElementById('ai-model').value.trim();
    
    if (!apiUrl || !apiKey) {
        alert('请先填写API URL和API Key');
        return;
    }

    const presetName = prompt('请输入配置名称:', '我的配置');
    if (!presetName || !presetName.trim()) return;
    
        // 创建新配置
    const newPreset = {
        id: Date.now(),
        name: presetName.trim(),
        apiUrl: apiUrl,
        apiKey: apiKey,
        defaultModel: model,
        lastUsedTime: Date.now()  
    };
    
    console.log('正在保存配置:', newPreset); // 调试用
    
    // 添加到配置数组
    if (!APP_DATA.presets) {
        APP_DATA.presets = [];
    }
    APP_DATA.presets.push(newPreset);
    APP_DATA.currentPresetId = newPreset.id;
    
    // 同步到settings
    APP_DATA.settings.apiUrl = apiUrl;
    APP_DATA.settings.apiKey = apiKey;
    APP_DATA.settings.aiModel = model;
    
    // 保存到本地存储
    localStorage.setItem('AI_PHONE_APP_DATA', JSON.stringify(APP_DATA));
    
    // 更新显示
    document.getElementById('api-preset-display').value = newPreset.name;
    document.getElementById('save-preset-btn').style.display = 'none';
    
    // 隐藏API输入字段
    const apiFieldsContainer = document.getElementById('api-fields-container');
    if (apiFieldsContainer) {
        apiFieldsContainer.style.display = 'none';
    }
    
    alert('配置保存成功！');
    
    // 刷新配置列表（如果弹窗打开着）
    refreshPresetList();
}

async function fetchModels() {
    // 获取API信息
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    
    // 验证
    if (!apiUrl || !apiKey) {
        alert('请先填写API URL和API Key');
        return;
    }
    
    // 显示加载中
    const modelInput = document.getElementById('ai-model');
    const originalValue = modelInput.value;
    modelInput.value = '正在获取模型列表...';
    modelInput.disabled = true;
    
    try {
        // 构建模型列表URL（兼容不同API提供商）
        let modelsUrl = '';
        if (apiUrl.includes('siliconflow')) {
            modelsUrl = apiUrl.replace('/chat/completions', '/models');
        } else if (apiUrl.includes('openai')) {
            modelsUrl = 'https://api.openai.com/v1/models';
        } else {
            // 通用格式：尝试移除路径末尾部分
            modelsUrl = apiUrl.replace(/\/chat\/completions$/, '/models');
        }
        
        console.log('请求模型列表URL:', modelsUrl);
        
        // 发送请求
        const response = await fetch(modelsUrl, {
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`请求失败: ${response.status}`);
        }
        
        const data = await response.json();
        
        // 提取模型列表（兼容不同格式）
        let models = [];
        if (Array.isArray(data)) {
            models = data; // 直接是数组
        } else if (data.data && Array.isArray(data.data)) {
            models = data.data; // {data: [...]}
        } else if (data.models && Array.isArray(data.models)) {
            models = data.models; // {models: [...]}
        }
        
        if (models.length === 0) {
            alert('未获取到模型列表，请手动输入模型名称');
            modelInput.value = originalValue;
            return;
        }
        
        // 显示模型选择弹窗
        showModelSelectDialog(models);
        
    } catch (error) {
        console.error('获取模型失败:', error);
        alert('获取模型失败: ' + error.message + '\n请手动输入模型名称');
    } finally {
        modelInput.disabled = false;
        if (modelInput.value === '正在获取模型列表...') {
            modelInput.value = originalValue;
        }
    }
}


       
function saveSettings() {
    // 【重要修改】如果当前在"新建配置"状态，不要更新任何配置
    if (APP_DATA.currentPresetId) {
        const preset = APP_DATA.presets.find(p => p.id == APP_DATA.currentPresetId);
        if (preset) {
            preset.apiUrl = document.getElementById('api-url').value;
            preset.apiKey = document.getElementById('api-key').value;
            preset.defaultModel = document.getElementById('ai-model').value;
        }
    }
    
    // 保存到APP_DATA.settings
    APP_DATA.settings.apiUrl = document.getElementById('api-url').value;
    APP_DATA.settings.apiKey = document.getElementById('api-key').value;
    APP_DATA.settings.aiModel = document.getElementById('ai-model').value;
    APP_DATA.settings.temperature = parseFloat(document.getElementById('temperature').value) || 0.7;
    APP_DATA.settings.maxTokens = parseInt(document.getElementById('maxTokens-input').value) || 2048;
    // 新增：保存记忆设置
    APP_DATA.settings.contextLimit = parseInt(document.getElementById('context-limit').value) || 20;
    APP_DATA.settings.diaryInterval = parseInt(document.getElementById('diary-interval').value) || 10;
    // 【重要】OneSignal Key 不在这里保存，它有专门的保存函数

    const avatarBase64 = document.getElementById('ai-avatar-base64').value;
    APP_DATA.settings.aiAvatarBase64 = avatarBase64 || 'AI';
    
    saveData();
    alert('设置已保存！');
    renderContacts(); 
}
        
// 显示弹窗并加载已保存的 Key
function showPushKeyModal() {
    // 确保从 APP_DATA 读取
    const savedKey = APP_DATA.settings.oneSignalKey || '';
    document.getElementById('onesignal-key-input').value = savedKey;
    showModal('push-key-modal');
}

function savePushKey() {
    const keyVal = document.getElementById('onesignal-key-input').value.trim();
    if (!keyVal) return;
    
    // 强制更新到 settings 对象中，防止被 saveSettings 覆盖
    APP_DATA.settings.oneSignalKey = keyVal;
    
    saveData(); // 保存到本地存储 [cite: 496]
    hideModal('push-key-modal');
    alert('通知 API 配置已成功同步！');
}
        // ----------------------- 页面切换 -----------------------
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.style.display = 'none';
            });
            document.getElementById(pageId).style.display = 'flex';
            
            if (pageId === 'settings-page') {
                loadSettings();
                updateCacheSize();
            } else if (pageId === 'options-page') {
                document.getElementById('options-role-name').textContent = currentContact ? currentContact.name + ' 选项' : '选项';
          } else if (pageId === 'chat-window') {
    // 智能更新：根据标记或数据变化决定是否重新渲染
    if (currentContact) {
        // 检查是否需要刷新（比如从记忆编辑页面返回）
        if (window.needRefreshChat) {
            renderMessages(currentContact.history);
            window.needRefreshChat = false; // 重置标记
        } else {
            // 检查消息数量是否一致
            const container = document.getElementById('chat-messages');
            if (container) {
                const displayedCount = container.querySelectorAll('.chat-message').length;
                const actualCount = currentContact.history.length;
                
                // 如果数量不一致（比如清理了记忆），重新渲染
                if (displayedCount !== actualCount) {
                    renderMessages(currentContact.history);
                }
            }
        }
        
        scrollToBottomInstant();
    }
} else if (pageId === 'contacts-page') {
                // 退出聊天窗口时退出管理模式
                isManageMode = false;
                batchMode = false;
                selectedContacts.clear();
                document.getElementById('batch-toolbar').classList.remove('show');
                renderContacts();
            }
        }

        function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    
    modal.style.display = 'flex';
    
    // 强制重绘以确保动画生效
    modal.offsetWidth;
    
    modal.classList.add('active');
}

       function hideModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    
    // 移除active类开始淡出动画
    modal.classList.remove('active');
    
    // 等待动画完成后隐藏
    setTimeout(() => {
        modal.style.display = 'none';
    }, 300);
}

        function toggleTheme(mode) {
            if (mode === 'dark') {
                document.documentElement.classList.add('dark-mode');
            } else {
                document.documentElement.classList.remove('dark-mode');
            }
            APP_DATA.currentTheme = mode;
            saveData();
        }

        // ----------------------- 聊天室 (联系人) 管理 -----------------------
        
        // 切换管理模式
        function toggleManageMode() {
            isManageMode = !isManageMode;
            batchMode = isManageMode;
            
            if (!batchMode) {
                selectedContacts.clear();
                document.getElementById('batch-toolbar').classList.remove('show');
            } else {
                document.getElementById('batch-toolbar').classList.add('show');
                updateSelectedCount();
            }
            
            renderContacts();
        }
        
        function cancelBatchDelete() {
            batchMode = false;
            isManageMode = false;
            selectedContacts.clear();
            document.getElementById('batch-toolbar').classList.remove('show');
            renderContacts();
        }
        
        function toggleSelectAll() {
            if (selectedContacts.size === APP_DATA.contacts.length) {
                // 如果已经全选，则取消全选
                selectedContacts.clear();
            } else {
                // 否则全选
                APP_DATA.contacts.forEach(contact => {
                    selectedContacts.add(contact.id);
                });
            }
            renderContacts();
            updateSelectedCount();
        }
        
        function updateSelectedCount() {
            document.getElementById('selected-count').textContent = `已选择 ${selectedContacts.size} 项`;
        }
        
        function toggleContactSelection(id) {
            if (selectedContacts.has(id)) {
                selectedContacts.delete(id);
            } else {
                selectedContacts.add(id);
            }
            renderContacts();
            updateSelectedCount();
        }
        
        function deleteSelectedContacts() {
            if (selectedContacts.size === 0) {
                alert('请先选择要删除的聊天室');
                return;
            }
            
            if (confirm(`确定要删除选中的 ${selectedContacts.size} 个聊天室吗？`)) {
                APP_DATA.contacts = APP_DATA.contacts.filter(c => !selectedContacts.has(c.id));
                saveData();
                selectedContacts.clear();
                batchMode = false;
                isManageMode = false;
                document.getElementById('batch-toolbar').classList.remove('show');
                renderContacts();
            }
        }

        function renderContacts() {
            const list = document.getElementById('contacts-list');
            list.innerHTML = '';
            
            if (APP_DATA.contacts.length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-color-secondary);">暂无聊天室</div>';
                return;
            }
                // 按最后聊天时间排序（最新的在最上面）
                const sortedContacts = [...APP_DATA.contacts].sort((a, b) => {
                    const timeA = a.lastChatTime || 0;
                    const timeB = b.lastChatTime || 0;
                    return timeB - timeA;
                });

            sortedContacts.forEach(contact => {
                const item = document.createElement('div');
                item.className = 'contact-item clickable'; 
                
                // 批量选择框或删除按钮
                if (batchMode) {
                    const checkboxWrapper = document.createElement('div');
                    checkboxWrapper.className = `contact-checkbox ${batchMode ? 'show' : ''}`;
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = selectedContacts.has(contact.id);
                    checkbox.onclick = (e) => {
                        e.stopPropagation();
                        toggleContactSelection(contact.id);
                    };
                    checkboxWrapper.appendChild(checkbox);
                    item.appendChild(checkboxWrapper);
                } 
                    else if (isManageMode) {
    const actionWrapper = document.createElement('div');
    actionWrapper.className = `delete-btn-wrapper ${isManageMode ? 'show' : ''}`;
    actionWrapper.style.display = 'flex';
    actionWrapper.style.gap = '10px';
    actionWrapper.style.alignItems = 'center';
    
    // 修改按钮
    const editBtn = document.createElement('div');
    editBtn.className = 'edit-icon';
    editBtn.innerHTML = '✎';
    editBtn.style.cssText = 'width:22px;height:22px;border-radius:50%;background-color:#88ABDA;color:white;display:flex;justify-content:center;align-items:center;font-size:14px;cursor:pointer;';
    editBtn.onclick = (e) => {
        e.stopPropagation();
        const newName = prompt('修改角色名：', contact.name);
        if (newName && newName.trim()) {
            contact.name = newName.trim();
            saveData();
            renderContacts();
            alert('修改成功！');
        }
    };
    
    // 删除按钮
    const deleteBtn = document.createElement('div');
    deleteBtn.className = 'delete-icon';
    deleteBtn.textContent = '-';
    deleteBtn.onclick = (e) => {
        e.stopPropagation();
        deleteContact(contact.id);
    };
    
    actionWrapper.appendChild(editBtn);
    actionWrapper.appendChild(deleteBtn);
    item.appendChild(actionWrapper);
}
                
                // 头像
                const avatar = document.createElement('div');
                avatar.className = 'contact-avatar';
                // 使用 AI 设置的头像或默认首字
                if(APP_DATA.settings.aiAvatarBase64 && APP_DATA.settings.aiAvatarBase64 !== 'AI' && APP_DATA.settings.aiAvatarBase64.startsWith('data:image')) {
                     const img = document.createElement('img');
                     img.src = APP_DATA.settings.aiAvatarBase64;
                     avatar.appendChild(img);
                } else {
                     avatar.textContent = contact.name.charAt(0);
                }
                item.appendChild(avatar);

                                                                // 名字
                let nameElement;
                
                if (isManageMode) {
                    // 管理模式：显示输入框
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = contact.name;
                    nameInput.style.cssText = `
                        border: 1px solid var(--accent-color);
                        border-radius: 6px;
                        padding: 4px 8px;
                        background: var(--bg-color-secondary);
                        color: var(--text-color-primary);
                        font-size: inherit;
                        width: 120px;
                        user-select: text !important;
                        -webkit-user-select: text !important;
                        caret-color: #07C160;
                    `;
                    nameInput.onclick = (e) => {
                        e.stopPropagation();
                        nameInput.select();
                    };
                    nameInput.onblur = () => {
                        const newName = nameInput.value.trim();
                        if (newName && newName !== contact.name) {
                            contact.name = newName;
                            saveData();
                            renderContacts();
                        }
                    };
                    nameInput.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            nameInput.blur();
                        }
                        e.stopPropagation();
                    };
                    nameElement = nameInput;
                } else {
                    // 正常模式：显示普通文本
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = contact.name;
                    nameElement = nameSpan;
                }
                     // 添加到item前先移除点击动画类
                item.classList.remove('clickable');
                item.appendChild(nameElement);
                
                              // 点击事件
item.onclick = () => {
    if (batchMode) {
        toggleContactSelection(contact.id);
    } else {
        openChatWindow(contact.id);
    }
};


                list.appendChild(item);
            });
        }
        
        function deleteContact(id) {
            if(confirm('确定要删除这个聊天室吗？')) {
                APP_DATA.contacts = APP_DATA.contacts.filter(c => c.id !== id);
                saveData();
                renderContacts();
            }
        }
        
        function prepareRoleModal(contact = null) {
            document.getElementById('modal-role-id').value = contact ? contact.id : '';
            document.getElementById('modal-role-name').value = contact ? contact.name : '';
            document.getElementById('modal-role-prompt').value = contact ? contact.prompt : '';
            document.getElementById('modal-role-title').textContent = contact ? '编辑角色' : '新建角色';
            
            showModal('new-contact-modal');
        }

        function saveRoleFromModal() {
            const id = document.getElementById('modal-role-id').value;
            const name = document.getElementById('modal-role-name').value.trim();
            const prompt = document.getElementById('modal-role-prompt').value.trim();
            
            if (!name || !prompt) {
                alert('角色名和 Prompt 不能为空！');
                return;
            }
            
            if (id) {
                const contact = APP_DATA.contacts.find(c => c.id == id);
                if (contact) {
                    contact.name = name;
                    contact.prompt = prompt;
                }
            } else {
                const newId = APP_DATA.contacts.length > 0 ? Math.max(...APP_DATA.contacts.map(c => c.id)) + 1 : 1;
                APP_DATA.contacts.push({
                    id: newId,
                    name: name,
                    prompt: prompt,
                    history: [],
                    longMemory: '无'
                });
            }
            saveData();
            renderContacts();
            hideModal('new-contact-modal');
        }
        
        // ----------------------- 聊天逻辑 -----------------------
      function openChatWindow(contactId) {
    // 重置分页
      currentStartIndex = 0;
    const contactsPage = document.getElementById('contacts-page');
    const chatWindow = document.getElementById('chat-window');
    
    // 设置聊天信息
    APP_DATA.currentChatId = contactId;
    currentContact = APP_DATA.contacts.find(c => c.id === contactId);
    document.getElementById('chat-role-name').textContent = currentContact.name;
    
    // 先隐藏聊天室
    contactsPage.style.display = 'none';
    
    // 立即显示聊天窗口
    chatWindow.style.display = 'flex';
    chatWindow.classList.add('slide-in-right');
    
    // 【关键修改】在动画开始前就渲染消息
   renderMessages(currentContact.history.slice(-20));
    
    // 【关键修改】立即滚动到底部，不等待
    setTimeout(() => {
        const container = document.getElementById('chat-messages');
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    }, 10);
    
    // 等待动画结束
    setTimeout(() => {
        chatWindow.classList.remove('slide-in-right');
    }, 300);
}
        
       function exitChatWindow() {
    const contactsPage = document.getElementById('contacts-page');
    const chatWindow = document.getElementById('chat-window');
    
 
    currentAIRequest = null;
    isTyping = false;
    
    // 3. 动画效果
    chatWindow.classList.add('slide-out-left');
    contactsPage.style.display = 'flex';
    
    setTimeout(() => {
        chatWindow.style.display = 'none';
        chatWindow.classList.remove('slide-out-left');
        
        // 4. 退出管理模式
        isManageMode = false;
        batchMode = false;
        selectedContacts.clear();
        document.getElementById('batch-toolbar').classList.remove('show');
        renderContacts();
    }, 300);
}

       function renderMessages(history, startFromEnd = true) {
    const container = document.getElementById('chat-messages');
    
    if (startFromEnd) {
        // 从最后开始显示
        currentStartIndex = Math.max(0, history.length - PAGE_SIZE);
    }
    
    const messagesToShow = history.slice(currentStartIndex);
    
    // 清空容器但保留加载提示
    const loadingElement = document.getElementById('loading-more');
    container.innerHTML = '';
    if (loadingElement) {
        container.appendChild(loadingElement);
    }
    
    // 渲染消息
    let segmentGroup = [];
    
    messagesToShow.forEach((msg, index) => {
        if (msg.role === 'ai' && msg.isSegment && msg.segmentIndex !== undefined) {
            if (msg.segmentIndex === 0) {
                if (segmentGroup.length > 0) {
                    displaySegmentGroup(segmentGroup, container);
                }
                segmentGroup = [msg];
            } else {
                segmentGroup.push(msg);
            }
        } else {
            if (segmentGroup.length > 0) {
                displaySegmentGroup(segmentGroup, container);
                segmentGroup = [];
            }
            appendMessageToDOM(msg.content, msg.role, false);
        }
    });
    
    if (segmentGroup.length > 0) {
        displaySegmentGroup(segmentGroup, container);
    }
    
    scrollToBottomInstant();
}

function loadMoreMessages() {
    if (!currentContact || isLoadingMore) return;
    
    // 已经是最前面了
    if (currentStartIndex <= 0) return;
    
    isLoadingMore = true;
    
    // 显示加载提示
    const loadingElement = document.getElementById('loading-more');
    if (loadingElement) {
        loadingElement.style.display = 'block';
    }
    
    // 往前取10条
    currentStartIndex = Math.max(0, currentStartIndex - PAGE_SIZE);
    
    // 重新渲染
    setTimeout(() => {
        renderMessages(currentContact.history, false);
        isLoadingMore = false;
        if (loadingElement) {
            loadingElement.style.display = 'none';
        }
    }, 300);
}

// 新增：立即滚动到底部（不使用动画）
function scrollToBottomInstant() {
    const container = document.getElementById('chat-messages');
    if (!container) return;
    
    const messages = container.querySelectorAll('.chat-message');
    if (messages.length === 0) return;
    
    const lastMessage = messages[messages.length - 1];
    const desiredSpacing = 15;
    
    // 计算目标滚动位置
    const lastMessageBottom = lastMessage.offsetTop + lastMessage.offsetHeight;
    const containerHeight = container.clientHeight;
    
    // 目标位置：最后一条消息底部 + 期望的间距
    const targetScroll = lastMessageBottom - containerHeight + desiredSpacing;
    
    // 立即滚动，不使用平滑效果
    container.scrollTop = targetScroll;
}


function showAIContextMenu(bubbleElement) {
    // 检查是否是正在输入的气泡
    const isTypingBubble = bubbleElement.classList.contains('typing-indicator');
    if (isTypingBubble) {
        // 【修改】这里只是显示菜单，不立即执行
        // 菜单的点击事件会处理重新生成
    }

    const menu = document.getElementById('ai-context-menu');
    if (!menu) return;
    
    // 关闭其他可能打开的菜单
    closeAIMenu();
    
        // 记录点击的气泡元素
    menu.dataset.bubbleElement = 'clicked';
    
    // 保存到全局变量，这样regenerateAIReply函数能知道
    window.lastClickedBubble = bubbleElement;
    
    // 获取气泡位置
    const rect = bubbleElement.getBoundingClientRect();
    
   // 计算菜单位置（在气泡右上角，与气泡垂直居中）
    // 判断是手机还是电脑
let iconHeight = 40; // 电脑默认
if (window.innerWidth <= 768) {
    iconHeight = 60; // 手机更大
}
let menuTop = rect.top + (rect.height / 2) - (iconHeight / 2);
    let menuLeft = rect.right + 0;  // 在气泡右侧像素
    
    // 获取窗口尺寸和菜单尺寸
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const menuWidth = 40;
    const menuHeight = 40;
    
    // 调整位置，确保不超出窗口
if (menuLeft + menuWidth > windowWidth - 10) {
    // 如果右侧超出，贴在屏幕右侧边缘
    menuLeft = windowWidth - menuWidth - 10;
}
if (menuLeft < 10) {
    menuLeft = 10;
}
    if (menuTop + menuHeight > windowHeight - 10) {
        // 如果底部超出，显示在气泡上方
        menuTop = rect.top - menuHeight - 8;
    }
    
    // 显示菜单
    menu.style.top = menuTop + 'px';
    menu.style.left = menuLeft + 'px';
    menu.style.display = 'block';
    
    // 点击其他地方关闭菜单
    setTimeout(() => {
        document.addEventListener('click', function closeMenuHandler(e) {
            if (!menu.contains(e.target)) {
                closeAIMenu();
                document.removeEventListener('click', closeMenuHandler);
            }
        });
    }, 10);
}
// 关闭菜单（点击外部）
function closeAIMenuOnClickOutside(event) {
    const menu = document.getElementById('ai-context-menu');
    if (!menu) return;
    
    // 如果点击的不是菜单本身
    if (!menu.contains(event.target)) {
        menu.style.display = 'none';
        document.removeEventListener('click', closeAIMenuOnClickOutside);
    }
}

// 关闭菜单
function closeAIMenu() {
    const menu = document.getElementById('ai-context-menu');
    if (menu) {
        menu.style.display = 'none';
        document.removeEventListener('click', closeAIMenuOnClickOutside);
    }
}

// 显示分组的分割消息
function displaySegmentGroup(segmentGroup, container) {
    if (segmentGroup.length === 0) return;
    
    // 按segmentIndex排序
    segmentGroup.sort((a, b) => a.segmentIndex - b.segmentIndex);
    
    // 显示每个分割消息
    segmentGroup.forEach((msg, index) => {
        const {msgDiv, bubble} = appendMessageToDOM(msg.content, msg.role, false);
        // 可以添加一些标记，表明这是分割的一部分
        if (index > 0) {
            bubble.style.marginTop = '5px';
        }
    });
}
        
        function appendMessageToDOM(text, role, isTypingEffect = false) {
            const container = document.getElementById('chat-messages');
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message ${role}`;
            
                                    if (role === 'ai') {
                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'avatar';
                
                // 原来的头像内容
                if (APP_DATA.settings.aiAvatarBase64 && APP_DATA.settings.aiAvatarBase64.startsWith('data:image')) {
                    const img = document.createElement('img');
                    img.src = APP_DATA.settings.aiAvatarBase64;
                    img.style.width = '100%'; 
                    img.style.height = '100%'; 
                    img.style.objectFit = 'cover';
                    avatarDiv.appendChild(img);
                } else {
                    avatarDiv.textContent = currentContact ? currentContact.name.charAt(0) : 'AI';
                    avatarDiv.style.backgroundColor = 'var(--accent-color)';
                    avatarDiv.style.color = 'white';
                    avatarDiv.style.display = 'flex';
                    avatarDiv.style.justifyContent = 'center';
                    avatarDiv.style.alignItems = 'center';
                }
                msgDiv.appendChild(avatarDiv); 
            }

            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            
            if (isTypingEffect && role === 'ai') {
                // 显示打字效果
                bubble.classList.add('typing-indicator');
                bubble.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;
            } else {
                bubble.textContent = text;
            }
            
                    // 如果是AI消息，给气泡添加点击事件（包括正在输入的和已完成的）
    if (role === 'ai') {
        bubble.style.cursor = 'pointer';
        
        bubble.onclick = function(e) {
            e.stopPropagation();
            e.preventDefault();
            
            // 如果是正在输入的气泡，稍等一会儿再显示菜单
            if (isTypingEffect) {
                setTimeout(() => {
                    if (this.parentNode) { // 确保气泡还在
                        showAIContextMenu(this);
                    }
                }, 100);
            } else {
                showAIContextMenu(this);
            }
        };
    }
            
            msgDiv.appendChild(bubble);

            container.appendChild(msgDiv);
            scrollToBottom();
            
            return {msgDiv, bubble};
        }
        
     // 在不同气泡中逐句显示（智能分割）
async function typeMessageInMultipleBubbles(fullText, firstBubble, firstMsgDiv) {
    console.log("原始AI回复:", fullText);
    
    // ========== 第二重清理 ==========
    // 再次确保没有正斜线
    fullText = fullText.replace(/\//g, '');
    
    // 同时清理其他可能的问题字符
    fullText = fullText.replace(/[／∕⧸⁄]/g, ''); // 各种全角、数学斜线
    // ==============================

    // ========== 新增：合并连续标点 ==========
    fullText = fullText.replace(/([!?！？])\1+/g, '$1');

    // 优先：换行符分割
    if (fullText.includes('\n')) {
        const lines = fullText.split('\n').filter(line => line.trim().length > 0);
        if (lines.length > 1) {
            console.log("按换行符分割:", lines.length, "行");
            return await displaySentences(lines, fullText, firstBubble, firstMsgDiv);
        }
    }

    // 情况1：如果已经有反斜线，直接按反斜线分割
     if (fullText.includes('\\')) {
        console.log("按反斜线分割");
        const sentences = splitByBackslash(fullText);
        if (sentences.length > 1) {
            return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
        }
    }
    
    // 情况2：如果有中文标点，按中文标点分割
    const chinesePunctuation = /[。！？；]/;
    if (chinesePunctuation.test(fullText)) {
        console.log("检测到中文标点，按标点分割");
        const sentences = splitByChinesePunctuation(fullText);
        return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
    }
    
    // 情况3：如果有英文标点，按英文标点分割
    const englishPunctuation = /[.!?;]/;
    if (englishPunctuation.test(fullText)) {
        console.log("检测到英文标点，按标点分割");
        const sentences = splitByEnglishPunctuation(fullText);
        return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
    }
    
    // 情况4：如果有换行符，按换行符分割
    if (fullText.includes('\n')) {
        console.log("检测到换行符，按换行符分割");
        const sentences = splitByNewline(fullText);
        return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
    }
    
    // 情况5：如果有逗号或分号，按逗号/分号分割
    const commaSemicolon = /[,，]/;
    if (commaSemicolon.test(fullText)) {
        console.log("检测到逗号，按逗号分割");
        const sentences = splitByComma(fullText);
        return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
    }
    
    // 情况6：按长度分割（长文本拆分成短句）
    if (fullText.length > 30) {
        console.log("长文本，按长度分割");
        const sentences = splitByLength(fullText);
        return await displaySentences(sentences, fullText, firstBubble, firstMsgDiv);
    }
    
    // 情况7：直接显示（短文本）
    console.log("短文本，直接显示");
    firstBubble.textContent = fullText;
    return { fullReply: fullText, sentences: [fullText] };
}


// 【修改】按中文标点分割，防止切断中文省略号
function splitByChinesePunctuation(text) {
    const sentences = [];
    let currentSentence = '';
    
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        currentSentence += char;
        
        // 如果是中文标点
        if (/[。！？；]/.test(char)) {
            sentences.push(currentSentence);
            currentSentence = '';
        }
        // 特殊处理中文省略号（通常是 '…' 或 '……'）
        // 如果是 '…'，我们通常不把它当作句子结束符来强制换气泡，除非你希望省略号后换行
        // 这里保持原逻辑：只在 。！？； 处分割，忽略 …
    }
    
    if (currentSentence.trim()) {
        sentences.push(currentSentence.trim());
    }
    
    return sentences;
}

function splitByBackslash(text) {
    if (!text) return [];
    // 常见的逻辑是按 \ 符号分割，并过滤掉空字符串
    return text.split('\\').map(item => item.trim()).filter(item => item !== "");
}

// 【修改】按英文标点分割，但智能识别省略号
function splitByEnglishPunctuation(text) {
    const sentences = [];
    let currentSentence = '';
    
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        currentSentence += char;
        
        // 检查是否是英文标点
        if (/[.!?;]/.test(char)) {
            // 特殊处理：如果是点号 '.'
            if (char === '.') {
                // 向后看：如果后面还有一个点，说明是省略号的一部分，暂不分割
                if (i + 1 < text.length && text[i+1] === '.') {
                    continue;
                }
                // 向前看：如果前面是一个点，说明可能是省略号的结尾（...），也不分割，等后面再看
                // 但这里为了简化，我们只做“向后看”就足够防止单个点被切分
            }

            // 只有不是省略号的一部分时，才结束当前句子
            sentences.push(currentSentence);
            currentSentence = '';
        }
    }
    
    // 添加最后剩余的部分
    if (currentSentence.trim()) {
        sentences.push(currentSentence.trim());
    }
    
    return sentences;
}

function splitByNewline(text) {
    return text.split('\n').map(s => s.trim()).filter(s => s.length > 0);
}

function splitByComma(text) {
    // 按逗号分割，但避免分割太短的句子
    const sentences = [];
    const parts = text.split(/[,，]/).map(s => s.trim()).filter(s => s.length > 0);
    
    // 如果逗号分割后句子太短，合并相邻的短句
    let combined = '';
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        
        if (combined.length + part.length < 20) {
            // 合并短句
            combined += (combined ? '，' : '') + part;
        } else {
            // 保存当前合并的句子
            if (combined) {
                sentences.push(combined);
            }
            // 开始新的合并
            combined = part;
        }
    }
    
    // 添加最后一个合并的句子
    if (combined) {
        sentences.push(combined);
    }
    
    return sentences;
}

function splitByLength(text) {
    // 按长度分割长文本（每20-40字为一个句子）
    const sentences = [];
    const maxLength = 40;
    const minLength = 20;
    
    let currentSentence = '';
    const words = text.split('');
    
    for (let i = 0; i < words.length; i++) {
        currentSentence += words[i];
        
        // 如果当前句子达到最大长度，或者遇到自然断点
        if (currentSentence.length >= maxLength || 
            (currentSentence.length >= minLength && /[。！？.!?，,]/.test(words[i]))) {
            sentences.push(currentSentence.trim());
            currentSentence = '';
        }
    }
    
    // 添加最后一句
    if (currentSentence.trim()) {
        sentences.push(currentSentence.trim());
    }
    
    return sentences;
}

async function displaySentences(sentences, originalText, firstBubble, firstMsgDiv) {
    // 清理句子
    sentences = sentences.map(s => s.trim()).filter(s => s.length > 0);
    
    // 如果没有有效的句子，直接显示
    if (sentences.length === 0) {
        firstBubble.textContent = originalText;
        return { fullReply: originalText, sentences: [] };
    }
    
    // 如果只有一个句子，直接显示
    if (sentences.length === 1) {
        firstBubble.textContent = sentences[0];
        return { fullReply: originalText, sentences: [sentences[0]] };
    }

    
    // 多个句子：逐句在不同气泡中显示
    let fullReply = '';
    for (let i = 0; i < sentences.length; i++) {
        const sentence = sentences[i];
        fullReply += (i > 0 ? '\\' : '') + sentence;
        
        if (i === 0) {
             // 第一句使用原来的气泡
            firstBubble.textContent = sentence;
            addClickToBubble(firstBubble);
            // 发送第一句的通知
            sendPushNotification(sentence.substring(0, 60));
        } else {
            // 后续句子创建新的气泡
            const newBubble = createNewBubble(sentence, firstMsgDiv);
            addClickToBubble(newBubble);
            // 发送后续句子的通知
             sendPushNotification(sentence.substring(0, 60));
        }

        
        // 随机延迟1-2秒
        const delay = 1000 + Math.random() * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        
        // 修改点：每次内容更新后，强制滚动到底部
        scrollToBottom();
    }
    
    return { fullReply, sentences };
}

// 【新增】给气泡添加点击事件的辅助函数
function addClickToBubble(bubble) {
    if (!bubble) return;
    
    bubble.style.cursor = 'pointer';
    bubble.onclick = function(e) {
        e.stopPropagation();
        e.preventDefault();
        showAIContextMenu(this);
    };
}

// 【修改】createNewBubble 函数，返回新气泡
function createNewBubble(text, referenceMsgDiv) {
    const newMsg = document.createElement('div');
    newMsg.className = 'chat-message ai';
    
    // 复制头像部分
    const avatarClone = referenceMsgDiv.querySelector('.avatar').cloneNode(true);
    newMsg.appendChild(avatarClone);
    
    // 创建新的气泡
    const newBubble = document.createElement('div');
    newBubble.className = 'bubble';
    newBubble.textContent = text;
    newMsg.appendChild(newBubble);
    
    // 添加到消息容器
    const container = document.getElementById('chat-messages');
    container.appendChild(newMsg);
    
    return newBubble; // 【重要】返回气泡元素
}

function scrollToBottom() {
    const container = document.getElementById('chat-messages');
    if (!container) return;
    
    const messages = container.querySelectorAll('.chat-message');
    if (messages.length === 0) return;
    
    const lastMessage = messages[messages.length - 1];
    const desiredSpacing = 15;
    
    // 计算目标滚动位置
    const lastMessageBottom = lastMessage.offsetTop + lastMessage.offsetHeight;
    const containerHeight = container.clientHeight;
    
    // 目标位置：最后一条消息底部 + 期望的间距
    const targetScroll = lastMessageBottom - containerHeight + desiredSpacing;
    
    // 只在需要时才滚动（避免不必要的滚动）
    const currentScroll = container.scrollTop;
    const threshold = 10;
    
    if (Math.abs(currentScroll - targetScroll) > threshold) {
        container.scrollTo({
            top: targetScroll,
            behavior: 'smooth'
        });
    }
}

async function sendMessage() {
    const text = document.getElementById('chat-textarea').value.trim();
    if (!text || !currentContact || isTyping) return;

    appendMessageToDOM(text, 'user');
    currentContact.history.push({ role: 'user', content: text });
    document.getElementById('chat-textarea').value = '';
    document.getElementById('chat-textarea').style.height = '36px';

    isTyping = true;
    const {msgDiv, bubble} = appendMessageToDOM('', 'ai', true);
    const currentChatIdAtRequest = APP_DATA.currentChatId;
    const currentContactIdAtRequest = currentContact.id;

    // 1. 获取 AI 回复
    const aiReply = await mockAIResponse(text, currentContact);
    
    console.log("【调试】AI回复内容:", aiReply);

    if (!currentContact || currentContact.id !== currentContactIdAtRequest || APP_DATA.currentChatId !== currentChatIdAtRequest) {
        isTyping = false;
        if (msgDiv && msgDiv.parentNode) msgDiv.remove();
        return;
    }
    
    bubble.classList.remove('typing-indicator');
    bubble.innerHTML = '';

    // 2. 执行逐句显示效果
    const { sentences, fullReply } = await typeMessageInMultipleBubbles(aiReply, bubble, msgDiv);

    if (sentences && sentences.length > 1) {
        sentences.forEach((sentence, index) => {
            currentContact.history.push({ 
                role: 'ai', 
                content: sentence,
                isSegment: true,
                segmentIndex: index 
            });
        });
    } else {
        currentContact.history.push({ role: 'ai', content: fullReply });
        currentContact.lastChatTime = Date.now();
    }

    isTyping = false;
    
    // 限制临时记忆只保留最近100回合（约200条消息）
    trimHistoryToLimit(currentContact, 100);
    
    saveData(); 
    simulateMemorySummary(currentContact).catch(e => console.log("记忆摘要跳过"));
}

// 新增：限制历史记录只保留最近N轮对话
function trimHistoryToLimit(contact, maxRounds) {
    if (!contact || !contact.history) return;
    
    // 计算用户消息数量（每条用户消息代表一轮）
    let userMsgCount = 0;
    let cutIndex = 0;
    
    // 从后往前数，找到第maxRounds轮的起始位置
    for (let i = contact.history.length - 1; i >= 0; i--) {
        if (contact.history[i].role === 'user') {
            userMsgCount++;
            if (userMsgCount > maxRounds) {
                cutIndex = i + 1; // 从这个位置之后开始保留
                break;
            }
        }
    }
    
    // 如果超过限制，截取历史记录
    if (cutIndex > 0) {
        const removedCount = cutIndex;
        contact.history = contact.history.slice(cutIndex);
        console.log(`已清理临时记忆，移除了前 ${removedCount} 条消息，保留最近 ${maxRounds} 轮对话`);
    }
}


async function mockAIResponse(userMessage, contact) {
    console.log("开始调用AI API...");
    
    // 新增：如果有之前的请求，取消它
    if (currentController) {
        currentController.abort();
        currentController = null;
    }
    
    // 新增：创建新的AbortController用于取消
    currentController = new AbortController();
    
    const settings = APP_DATA.settings;
    if (!settings.apiKey || !settings.apiUrl) {
        return "[系统提示]：请先在设置页填写 API Key 和 API URL！";
    }

    // 1. 提取当前用户说话的关键词
    const queryKeywords = extractKeywords(userMessage);
    console.log("当前对话关键词:", queryKeywords);

    // 2. 匹配与算分
    let scoredMemories = [];
    if (contact.longMemories) {
        scoredMemories = contact.longMemories.map(m => {
            const score = calculateMemoryScore(queryKeywords, m.keywords || []);
            return { ...m, score: score };
        });
    }

    // 3. 挑选得分最高的前 15 条
    const topMemories = scoredMemories
        .filter(m => m.score > 0)
        .sort((a, b) => b.score - a.score)
        .slice(0, 15);

    // 4. 将这些“往事”转化成文本
    let longTermMemoryText = "";
    if (topMemories.length > 0) {
        longTermMemoryText = topMemories.map((m, i) => `${i+1}. ${m.content}`).join('\n');
    } else {
        longTermMemoryText = "（脑海中没有相关的特定往事）";
    }

    // 2. 获取临时记忆 (修改为：按轮数截取)
    const roundLimit = settings.contextLimit || 10; 
    let startIndex = 0;
    let userMsgCount = 0;
    
    for (let i = contact.history.length - 1; i >= 0; i--) {
        if (contact.history[i].role === 'user') {
            userMsgCount++;
            if (userMsgCount > roundLimit) {
                startIndex = i + 1;
                break;
            }
        }
    }
    
    const recentHistory = contact.history.slice(startIndex).map(m => 
        m.content
    ).join('\n');

    // 3. 构建 Prompt
    const messages = [
        {
            role: "system",
            content: `【绝对规则】你是${contact.name}，正在与用户进行角色扮演对话。用户扮演与你对话的对方。

            【关键警告】
            如果你在回复中使用正斜线（/），系统会自动删除它！
            这会导致你的回复变得混乱、不完整。
            所以绝对不要使用正斜线（/）！

            【正确的分隔方式】
            使用反斜线（\）来分隔不同的回复部分，像这样：
            （动作1）内容1\（动作2）内容2\（动作3）内容3

            【错误的分隔方式】
            （动作1）内容1/（动作2）内容2/（动作3）内容3  ← 这样会被系统删除斜线，变成：
            （动作1）内容1（动作2）内容2（动作3）内容3


            【严格人称规范】
            1. 用户消息中所有括号()内的内容，都是对你的客观描述或你执行的动作
            2. 例如："（你困了）" → 表示你现在困了
            3. 例如："（你联系了学弟）" → 表示你联系了学弟
            4. 例如："（描写你的外貌）" → 表示描写你自己的外貌
            5. 括号内永远是你（${contact.name}）的行为/状态，不是用户的

            【人称解析规则 - 最重要！】
            用户发送的消息需要这样理解：

            1. **括号内有"你"字** → 描述的是你（${contact.name}）的状态/动作
            - 用户说"（你摔倒了）" → 你摔倒了，你要回应自己摔倒的情况
            - 用户说"（你的腿传来剧痛）" → 你的腿在疼，你要表现出疼痛
            - 用户说"（你哭了）" → 你在哭，你要表现出哭泣的状态

            2. **括号内没有"你"字** → 描述的是用户自己的动作
            - 用户说"（轻笑）" → 用户在轻笑
            - 用户说"（走近）" → 用户走近了你
            - 用户说"（叹气）" → 用户叹气了

            3. **括号外的内容** → 用户对你说的话

            【你的回复要求】
            1. 第一人称：永远用"我"自称
            2. 对用户的称呼：用"你"称呼用户
            3. 格式：（动作描写）对话内容
            4. 使用反斜线\分隔不同的句子
            5. 每次回复3-4句

            【错误示例纠正】
            用户输入：（你联系了学弟）
            错误：你联系了学弟吗？（混淆人称）
            正确：（微笑着点头）嗯，我刚才联系了学弟，他很快就回复了

            用户输入：（你摔倒了）
            错误：你没事吧？（把用户当成了摔倒的人）
            正确：（揉着膝盖站起来）哎呀，不小心摔了一跤，不过没事

            用户输入：（描写你的衣服）
            错误：你的衣服很漂亮（说用户的衣服）
            正确：（整理了一下裙摆）我今天穿了浅蓝色的连衣裙，喜欢吗？
                        
            【你的设定】
            ${contact.prompt}

            ${applyDeepPresetToPrompt()}  

            【你的私人日记（长期记忆）】
            这是你过去写下的日记，记录了你和用户的过往，请参考这些记忆来保持人设连贯：
            ${longTermMemoryText}

            【回复格式要求】
            1. 必须使用反斜线 \ 来分隔不同的回复部分
            2. 每个部分应该是一个完整的句子或表达
            3. 示例格式：（轻笑着摸摸你的头）你已经做得很棒了\（蹭蹭你的颈窝）好喜欢你…\（轻轻点头）都听你的！
            4. 在每个对话前必须使用适当的动作描述，如：（轻笑着摸摸你的头）你已经做得很棒了、（蹭蹭你的颈窝）好喜欢你…、（轻轻点头）都听你的！
            5. 绝对不要在一个部分中包含多个句子，每个句子都要用反斜线分隔
            6.每次只回复3-4句

            【示例】
            用户：你好
            正确回复：（轻笑着摸摸你的头）你已经做得很棒了\（蹭蹭你的颈窝）好喜欢你…\（轻轻点头）都听你的！
            错误回复：AI：（轻笑着摸摸你的头）你已经做得很棒了（带角色标识符）
            错误回复：（轻笑着摸摸你的头）你已经做得很棒了（蹭蹭你的颈窝）好喜欢你…（轻轻点头）都听你的！（没有用反斜线分隔）
            `
                    },
                    {        
                        role: "user",
                        content: `
            【最近的对话记录】
            ${recentHistory}

            【当前用户说】：${userMessage}

            请根据记忆和设定回复。`
        }
    ];

    try {
        console.log("发送API请求到:", settings.apiUrl);
        console.log("使用模型:", settings.aiModel);
        console.log("消息长度:", JSON.stringify(messages).length);
        
        const response = await fetch('https://api.ginkgo-yinxing.workers.dev/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${settings.apiKey}`,
                'X-Target-API': settings.apiUrl
            },
            body: JSON.stringify({
            model: settings.aiModel,
            messages: messages,
            temperature: settings.temperature || 0.7,
            max_tokens: settings.maxTokens || 2048, // 使用你滑块保存的变量
            stream: settings.stream || false
    }),
            signal: currentController.signal
        });

        console.log("API响应状态:", response.status, response.statusText);
        
       if (response.ok) {
            const rawText = await response.text(); 
            console.log("服务器返回的原始数据:", rawText);

            let result = "";

            // 检查服务器是否强行返回了带 "data:" 的流格式 [cite: 723, 724]
            if (rawText.includes('data:')) {
                const lines = rawText.split('\n');
                for (let line of lines) {
                    let cleanLine = line.trim();
                    if (cleanLine.startsWith('data:') && !cleanLine.includes('[DONE]')) {
                        try {
                            const json = JSON.parse(cleanLine.replace('data:', '').trim());
                            // 兼容流式(delta)和非流式(message)格式 [cite: 748, 749]
                            const content = json.choices?.[0]?.delta?.content || json.choices?.[0]?.message?.content || "";
                            result += content;
                        } catch (e) {
                            console.error("解析单行流数据失败", e);
                        }
                    }
                }
            } else {
                // 如果是正常的 JSON 格式 [cite: 748]
                try {
                    const data = JSON.parse(rawText);
                    if (data.choices && data.choices[0]?.message?.content) {
                        result = data.choices[0].message.content;
                    } else {
                        result = rawText;
                    }
                } catch (e) {
                    result = rawText;
                }
            }

            // 强力删除所有正斜线并应用正则 [cite: 755, 756]
            result = result.replace(/\//g, '');
            result = applyRegexToText(result); 
            
            if (currentContact) {
                saveData(); // [cite: 757]
            }
            
            return result || "AI 返回了空内容";
            
        } else {
            const errorText = await response.text();
            console.error("API错误响应:", errorText);
            
            let errorMsg = `[API错误]：${response.status}`;
            if (errorText) {
                try {
                    const errorData = JSON.parse(errorText);
                    if (errorData.error?.message) {
                        errorMsg = `[API错误]：${errorData.error.message}`;
                    }
                } catch (e) {
                    errorMsg = `[API错误]：${response.status} - ${errorText.substring(0, 100)}`;
                }
            }
            return errorMsg;
        }
    } catch (error) {
        console.error("网络请求错误:", error);
        
        let errorMsg = `[网络错误]：${error.message}`;
        
        // 更友好的错误提示
        if (error.name === 'AbortError') {
            errorMsg = "[请求已取消]";
        } else if (error.message.includes('Failed to fetch')) {
            errorMsg = "[网络连接失败]：请检查API URL是否正确，网络是否通畅";
        } else if (error.message.includes('timeout')) {
            errorMsg = "[请求超时]：API响应时间过长，请稍后重试";
        }
        
        return errorMsg;
    }
}
        async function simulateMemorySummary(contact) {
    console.log("?? 触发长期记忆生成逻辑...");
    
    // 使用全局设置的频率
    const interval = APP_DATA.settings.diaryInterval || 10;
    
    // 计算纯对话消息数量
    const userMessagesCount = contact.history.filter(m => m.role === 'user').length;
    
    // 改为：大于等于频率就触发（更宽松）
    if (userMessagesCount < interval || contact.history.length < 5) {
        return;
    }

    console.log("?? 正在请求 AI 撰写日记...");
    
    // 提取最近的对话内容用于总结
    const recentChat = contact.history.slice(-(interval * 2 + 5)).map(m => 
        m.content
    ).join('\n');

    const apiUrl = APP_DATA.settings.apiUrl;
    const apiKey = APP_DATA.settings.apiKey;
    const model = APP_DATA.settings.aiModel;

  const summaryMessages = [
    {
        role: "system",
        content: `你是一个记忆提取器，负责从对话中提取${contact.name}（AI角色）的记忆。

            【核心规则 - 人称解析】
            在对话记录中，需要根据以下规则判断动作归属：

            1. **用户消息中括号内包含"你"字** → 这是对${contact.name}的描述
            - "（你摔倒了）" → ${contact.name}摔倒了
            - "（你的腿传来剧痛）" → ${contact.name}的腿疼
            - "（你联系了学弟）" → ${contact.name}联系了学弟

            2. **用户消息中括号内不包含"你"字** → 这是用户自己的动作
            - "（轻笑）" → 用户轻笑
            - "（叹气）" → 用户叹气
            - "（走近）" → 用户走近

            3. **${contact.name}的消息中的括号** → 都是${contact.name}自己的动作

            【记忆提取要求】
            1. 以${contact.name}的第一人称"我"来记录
            2. 用"用户"或"对方"指代用户
            3. 每条记忆必须独立、具体
            4. 严格按照上述规则判断动作归属
            5. 每次提取3-5条，用换行分隔

            【示例】
            对话："（你摔倒了）（轻笑）你没事吧？"
            正确记忆：我摔倒了，用户轻笑着问我有没有事

            对话："（叹气）（你看起来很累）休息一下吧"
            正确记忆：用户叹了口气，说我看起来很累，让我休息一下`
                },
                {
                    role: "user",
                    content: `这是最近的对话记录：\n${recentChat}\n\n请按照规则提取${contact.name}的记忆事实：`
                }
            ];



       try {
        console.log("发送日记总结请求到:", apiUrl); 
        const response = await fetch('https://api.ginkgo-yinxing.workers.dev/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`,
                'X-Target-API': apiUrl  // 使用你的代理
            },

            body: JSON.stringify({
                model: model,
                messages: summaryMessages,
                temperature: 0.5,
                max_tokens: 200
            })
        });

        console.log("日记API响应状态:", response.status);
        
        if (response.ok) {
            const data = await response.json();
            console.log("日记API响应数据:", data);
            
            let diaryContent = "";
            
            // 多种响应格式支持
            if (data.choices && data.choices[0]?.message?.content) {
                diaryContent = data.choices[0].message.content;
            } else if (data.choices && data.choices[0]?.text) {
                diaryContent = data.choices[0].text;
            } else if (data.result) {
                diaryContent = data.result;
            } else if (data.response) {
                diaryContent = data.response;
            } else if (data.message && data.message.content) {
                diaryContent = data.message.content;
            } else if (data.content) {
                diaryContent = data.content;
            }
            
           if (diaryContent) {
                const now = new Date();
                const dateStr = `${now.getMonth()+1}月${now.getDate()}日`;
                
                // 提取关键词
                const keywords = extractKeywords(diaryContent);

                if (!contact.longMemories) contact.longMemories = [];
                contact.longMemories.push({
                    id: Date.now(),
                    date: dateStr,
                    content: diaryContent,
                    keywords: keywords,
                    type: 'ai_generated'
                });
                
                // 保持日记在一定数量
                if (contact.longMemories.length > 30) {
                    contact.longMemories = contact.longMemories.slice(-30);
                }
                
                saveData();
                console.log("? 日记已生成并保存:", diaryContent);
            }
        } else {
            console.error("日记生成失败，状态码:", response.status);
        }
    } catch (e) {
        console.error("生成日记失败:", e);
    }
}

        // ----------------------- 选项页 (Prompt/记忆) -----------------------
        function showMemoryModal(contextType) {
            if (!currentContact) return;
            APP_DATA.activeModalContext = contextType;
            
            const title = document.getElementById('memory-modal-title');
            const container = document.getElementById('memory-content-container');
            const saveBtn = document.getElementById('memory-save-btn');

            container.innerHTML = '';
            saveBtn.style.display = 'inline-block';

            if (contextType === 'prompt') {
                title.textContent = '修改角色 Prompt';
                const textarea = document.createElement('textarea');
                textarea.id = 'memory-content';
                textarea.rows = 15;
                textarea.placeholder = '内容';
                textarea.value = currentContact.prompt;
                container.appendChild(textarea);
            
           } else if (contextType === 'long') {
    title.textContent = '长期记忆日记';
    
    // 设置区域
    const settingsDiv = document.createElement('div');
    settingsDiv.innerHTML = `
        <div style="padding:15px; background:var(--input-bg); border-radius:12px; margin-bottom:20px; font-size:14px;">
            <span style="color:var(--text-color-secondary);">提示：日记生成频率和携带轮数请在【设置】页面修改。</span>
        </div>
    `;
    container.appendChild(settingsDiv);
    
    // 记忆列表
    const listDiv = document.createElement('div');
    
    if (!currentContact.longMemories || currentContact.longMemories.length === 0) {
        listDiv.innerHTML = `
            <div style="text-align:center; padding:40px; color:var(--text-color-secondary);">
                <div style="font-size:48px; margin-bottom:20px;">??</div>
                <div>还没有长期记忆哦</div>
            </div>
        `;
    } else {
        // 【修改】去掉 .reverse()，保持原始顺序（新的在下面）
        currentContact.longMemories.forEach(memory => {
            const memoryDiv = document.createElement('div');
            memoryDiv.style.cssText = `
                margin-bottom:15px; border:1px solid var(--input-border); 
                border-radius:10px; padding:15px; background:var(--bg-color-secondary);
            `;
            memoryDiv.innerHTML = `
                <div style="font-weight:bold; color:var(--text-color-primary); margin-bottom:8px;">
                    ${memory.date}
                    <button onclick="deleteMemory('${memory.id}')" style="float:right; background:var(--danger-color); color:white; border:none; border-radius:50%; width:24px; height:24px; font-size:16px; cursor:pointer;">×</button>
                </div>
                <textarea style="width:100%; min-height:60px; padding:8px; border:1px solid var(--input-border); border-radius:6px; background:var(--input-bg); color:var(--text-color-primary);">${memory.content}</textarea>
            `;
            listDiv.appendChild(memoryDiv);
        });
        
        // 【新增】自动滚动到最新的一条（最下面）
        setTimeout(() => {
            container.scrollTop = container.scrollHeight;
        }, 100);
    }
    container.appendChild(listDiv);

            } else if (contextType === 'short') {
                title.textContent = '临时记忆 (按轮数管理)';
                
                // 优化：按轮数分组逻辑 (用户消息 = 新的一轮开始)
                const rounds = [];
                let currentRound = [];
                
                currentContact.history.forEach((message, index) => {
                    // 如果遇到用户消息，且当前轮已经有内容，说明上一轮结束了
                    if (message.role === 'user' && currentRound.length > 0) {
                        rounds.push([...currentRound]);
                        currentRound = [];
                    }
                    currentRound.push(message);
                });
                // 最后一轮
                if (currentRound.length > 0) {
                    rounds.push([...currentRound]);
                }
                
                // 存储 rounds 供删除使用
                window.tempMemoryRounds = rounds;
                
                // 渲染界面
                rounds.forEach((round, roundIndex) => {
                    const roundContainer = document.createElement('div');
                    roundContainer.className = 'round-container';
                    roundContainer.dataset.roundIndex = roundIndex;
                    
                    const roundHeader = document.createElement('div');
                    roundHeader.className = 'round-header';
                    
                    const roundTitle = document.createElement('span');
                    roundTitle.textContent = `第${roundIndex + 1}轮对话`;
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'round-delete-btn clickable';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.title = '删除这一轮对话';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteRound(roundIndex);
                    };
                    
                    roundHeader.appendChild(roundTitle);
                    roundHeader.appendChild(deleteBtn);
                    roundContainer.appendChild(roundHeader);
                    
                    const roundContent = document.createElement('div');
                    roundContent.className = 'round-content';
                    
                    round.forEach((message, msgIndex) => {
                        const messageDiv = document.createElement('div');
                        messageDiv.className = `round-message ${message.role}`;
                        messageDiv.contentEditable = true;
                        messageDiv.dataset.role = message.role;
                        messageDiv.dataset.roundIndex = roundIndex;
                        messageDiv.dataset.msgIndex = msgIndex;
                        messageDiv.textContent = message.content;
                        roundContent.appendChild(messageDiv);
                    });
                    
                    roundContainer.appendChild(roundContent);
                    container.appendChild(roundContainer);
                });
                
            
            // 自动滚动到最新的一轮（最后）
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 100);

                if (rounds.length === 0) {
                    container.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-color-secondary);">暂无对话记录</div>';
                }
            }
            
            showModal('memory-modal');
        }

        function saveContextModalData() {
            const contextType = APP_DATA.activeModalContext;
            
            if (contextType === 'prompt') {
                const textarea = document.getElementById('memory-content');
                currentContact.prompt = textarea.value;
                alert('Prompt 已保存！');
                saveData();
                hideModal('memory-modal');
          } else if (contextType === 'long') {
    // 获取所有修改后的记忆
    const textareas = document.querySelectorAll('#memory-content-container textarea');
    
    // 更新现有的记忆数组
    if (currentContact.longMemories && currentContact.longMemories.length > 0) {
        textareas.forEach((textarea, index) => {
            if (currentContact.longMemories[index]) {
                currentContact.longMemories[index].content = textarea.value;
            }
        });
    }
    
    alert('长期记忆已保存！');
    saveData();
    hideModal('memory-modal');
            } else if (contextType === 'short') {
                // 需求5: 保存修改后的临时记忆
                const roundContainers = document.querySelectorAll('.round-container');
                const newHistory = [];
                
                roundContainers.forEach((container, roundIndex) => {
                    const messages = container.querySelectorAll('.round-message');
                    messages.forEach(msgDiv => {
                        const role = msgDiv.dataset.role;
                        const content = msgDiv.textContent.trim();
                        if (content) {
                            newHistory.push({ role, content });
                        }
                    });
                });
                
                if (newHistory.length > 0) {
                currentContact.history = newHistory;
                // 设置标记，但不自动跳转
                window.needRefreshChat = true;
                alert('临时记忆已更新！');
                saveData();
                hideModal('memory-modal');
                // 不自动跳转，让用户手动返回
                } else {
                    alert('对话内容不能为空！');
                }
            }
        }
        
// 清空临时记忆
function clearShortTermMemory() {
    if (!currentContact) return;
    
    if (currentContact.history.length === 0) {
        alert('临时记忆已经是空的！');
        return;
    }
    
    if (confirm('确定要清空所有临时记忆吗？\n\n这将删除所有对话历史，无法恢复！')) {
            currentContact.history = [];
    
    // 立即更新聊天界面（如果正在聊天）
    if (document.getElementById('chat-window').style.display === 'flex') {
        renderMessages([]); // 传入空数组，清空显示
    }
        
        // 如果当前在聊天窗口，刷新显示
        if (document.getElementById('chat-window').style.display === 'flex') {
            renderMessages(currentContact.history);
        }
        
        saveData();
        alert('临时记忆已清空！');
        
        // 如果正在查看临时记忆弹窗，关闭它
        if (document.getElementById('memory-modal').style.display === 'flex' && 
            APP_DATA.activeModalContext === 'short') {
            hideModal('memory-modal');
        }
    }
}

// 清空长期记忆
function clearLongTermMemory() {
    if (!currentContact) return;
    
    if (confirm('确定要清空长期记忆吗？\n\n这将删除AI对这个角色的所有记忆，无法恢复！')) {
        // 清空两个地方
        currentContact.longMemory = '无';
        if (currentContact.longMemories) {
            currentContact.longMemories = [];
        }
        
        saveData();
        alert('长期记忆已清空！');
        
        if (document.getElementById('memory-modal').style.display === 'flex' && 
            APP_DATA.activeModalContext === 'long') {
            hideModal('memory-modal');
        }
    }
}


// 删除特定轮次的对话
function deleteRound(roundIndexToDelete) {
    if (!currentContact || !window.tempMemoryRounds) return;
    
    if (confirm('确定要删除这一轮对话吗？删除后无法恢复。')) {
        // 从临时存储的rounds中移除指定轮次
        window.tempMemoryRounds.splice(roundIndexToDelete, 1);
        
        // 重新构建历史记录
        const newHistory = [];
        window.tempMemoryRounds.forEach(round => {
            round.forEach(message => {
                newHistory.push(message);
            });
        });
        
        // 更新当前联系人的历史记录
        currentContact.history = newHistory;
        
        // 刷新临时记忆显示
        showMemoryModal('short');
        
        // 如果当前在聊天窗口，也刷新聊天显示
        if (document.getElementById('chat-window').style.display === 'flex') {
            renderMessages(currentContact.history);
        }
        
        // 保存数据
        saveData();
        alert('已删除该轮对话');
    }
}
        function loadAvatarPreview(data, elementId) {
            const previewElement = document.getElementById(elementId);
            if (!previewElement) return;
            previewElement.innerHTML = '';
            
            if (data && data.startsWith('data:image')) {
                const img = document.createElement('img');
                img.src = data;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                previewElement.appendChild(img);
            } else {
                previewElement.textContent = 'AI';
                previewElement.style.display = 'flex';
                previewElement.style.justifyContent = 'center';
                previewElement.style.alignItems = 'center';
                previewElement.style.backgroundColor = 'var(--accent-color)';
                previewElement.style.color = 'white';
                previewElement.style.fontSize = elementId === 'current-ai-avatar-preview' ? '36px' : '20px';
            }
        }

        document.getElementById('ai-avatar-file').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // 检查文件大小（限制为2MB）
            if (file.size > 2 * 1024 * 1024) {
                alert('头像图片大小不能超过2MB');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64Image = e.target.result;
                document.getElementById('ai-avatar-base64').value = base64Image;
                loadAvatarPreview(base64Image, 'current-ai-avatar-preview');
            };
            reader.readAsDataURL(file);
        });
// 数据迁移：将旧格式的历史转换为新格式
function migrateHistoryData() {
    let needsMigration = false;
    
    APP_DATA.contacts.forEach(contact => {
        const newHistory = [];
        let tempSegments = [];
        
        contact.history.forEach((msg, index) => {
            if (msg.role === 'ai') {
                // 检查是否包含反斜线分割
                if (msg.content.includes('\\') && !msg.isSegment) {
                    needsMigration = true;
                    // 分割消息
                    const sentences = splitByBackslash(msg.content);
                    sentences.forEach((sentence, segIndex) => {
                        newHistory.push({
                            role: 'ai',
                            content: sentence,
                            isSegment: true,
                            segmentIndex: segIndex
                        });
                    });
                } else {
                    newHistory.push(msg);
                }
            } else {
                newHistory.push(msg);
            }
        });
        
        contact.history = newHistory;
    });
    
    if (needsMigration) {
        saveData();
        console.log('历史数据已迁移为新格式');
    }
}



// 从点击的气泡重新生成
function regenerateFromBubble() {
    const menu = document.getElementById('ai-context-menu');
    const bubble = window.lastClickedBubble;
    
    // 关闭菜单
    if (menu) menu.style.display = 'none';
    
    if (!bubble || !currentContact) return;
    
    // 检查是否是正在输入的气泡
    const isTypingBubble = bubble.classList.contains('typing-indicator');
    
    if (isTypingBubble) {
        // 1. 立即停止当前请求
        isTyping = false;
        currentAIRequest = null; // 取消请求标记
        
        // 新增：取消正在进行的网络请求
        if (currentController) {
            currentController.abort();
            currentController = null;
        }
        
        // 2. 删除这个加载中的气泡
        const msgDiv = bubble.closest('.chat-message');
        if (msgDiv) {
            msgDiv.remove();
        }
        
        // 3. 重新生成（找到最后一条用户消息重新请求）
        regenerateAIReply();
    } else {
        // 普通气泡的重新生成逻辑
        regenerateAIReply();
    }
}


// 【新增】确保消息容器的底部有足够空间
function ensureMessageSpace() {
    const container = document.getElementById('chat-messages');
    if (!container) return;
    
    // 强制滚动到底部，给新消息留出空间
    container.scrollTop = container.scrollHeight;
    
    // 添加一点底部padding，确保新消息不会紧贴输入框
    setTimeout(() => {
        container.style.paddingBottom = '80px'; // 临时增加padding
        scrollToBottomInstant();
    }, 50);
}

// 【新增】滚动到特定元素
function scrollToElement(element) {
    const container = document.getElementById('chat-messages');
    if (!container || !element) return;
    
    // 计算元素在容器中的位置
    const elementRect = element.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    // 如果元素在容器底部以下，滚动到它
    if (elementRect.bottom > containerRect.bottom - 100) {
        const scrollTop = container.scrollTop + (elementRect.bottom - containerRect.bottom) + 120;
        container.scrollTop = scrollTop;
    }
}        document.addEventListener('DOMContentLoaded', () => {
            // 数据迁移：为已有的预设添加lastUsedTime字段
    if (APP_DATA.presets) {
        let needsMigration = false;
        APP_DATA.presets.forEach(preset => {
            if (!preset.lastUsedTime) {
                preset.lastUsedTime = Date.now(); // 设置为当前时间
                needsMigration = true;
            }
        });
        
        if (needsMigration) {
            saveData();
            console.log('预设数据已迁移，添加了最后使用时间字段');
        }
    }
            migrateHistoryData(); 
            renderContacts();
            toggleTheme(APP_DATA.currentTheme); 
            loadSettings();
            initPresetSystem();
         });
     
// 记忆弹窗返回按钮
    function goBackInMemoryModal() {
           document.getElementById('memory-modal').style.display = 'none';
           showPage('options-page');
}
    // 更新总结设置
function updateSummaryThreshold() {
    if (!currentContact) return;
    const input = document.getElementById('summary-threshold');
    const num = parseInt(input.value);
    if (num >= 5 && num <= 100) {
        currentContact.summaryThreshold = num;
        saveData();
        alert('已更新设置：每' + num + '轮对话总结一次');
    } else {
        alert('请输入5-100的数字');
    }
}



// 删除记忆
function deleteMemory(memoryId) {
    if (!confirm('删除这条记忆？')) return;
    const index = currentContact.longMemories.findIndex(m => m.id == memoryId);
    if (index > -1) {
        currentContact.longMemories.splice(index, 1);
        currentContact.longMemory = currentContact.longMemories.slice(-3).map(m=>m.content).join('\n');
        saveData();
        showMemoryModal('long'); // 重新加载页面
    }
}    
     // 自动切换主题（根据当前模式切换到相反模式）
function toggleThemeAuto() {
    const isDark = document.documentElement.classList.contains('dark-mode');
    const newMode = isDark ? 'light' : 'dark';
    toggleTheme(newMode);
    updateSwitchPosition(newMode);
}

// 更新滑块位置
function updateSwitchPosition(mode) {
    const thumb = document.querySelector('.theme-switch-thumb');
    if (thumb) {
        // 滑块位置会在CSS中通过 .dark-mode 类自动控制
        // 这里只是确保状态同步
        console.log('主题已切换到：', mode);
    }
}

// 初始化时根据当前主题设置滑块位置
document.addEventListener('DOMContentLoaded', function() {
    const isDark = document.documentElement.classList.contains('dark-mode');
    updateSwitchPosition(isDark ? 'dark' : 'light');
});
     
// 点击弹窗外部关闭所有弹窗
document.addEventListener('click', function(event) {
    const activeOverlays = document.querySelectorAll('.overlay[style*="display: flex"]');
    
    activeOverlays.forEach(overlay => {
        // 检查点击的是否是 overlay 背景（不是弹窗内容）
        if (event.target === overlay) {
            // 先移除激活状态（如果有淡出动画）
            overlay.classList.remove('active');
            
            // 延迟隐藏
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        }
    });
});

// 阻止点击弹窗内容时关闭弹窗
document.addEventListener('click', function(event) {
    if (event.target.closest('.modal-content')) {
        event.stopPropagation();
    }
});

function regenerateAIReply() {
    if (!currentContact) return;
    
    const menu = document.getElementById('ai-context-menu');
    if (menu) menu.style.display = 'none';
    
    const history = currentContact.history;
    
    // 1. 找到最后一条用户消息的位置
    let lastUserIndex = -1;
    let userMessage = '';
    
    for (let i = history.length - 1; i >= 0; i--) {
        if (history[i].role === 'user') {
            lastUserIndex = i;
            userMessage = history[i].content;
            break;
        }
    }
    
    if (lastUserIndex === -1) {
        console.log('没有找到用户消息');
        return;
    }
    
    console.log('找到用户消息位置:', lastUserIndex, '内容:', userMessage);
    console.log('删除前的history长度:', history.length);
    
    // 2. 删除这个用户消息之后的所有AI消息（整轮AI回复）
    const aiMessagesToDelete = [];
    
    // 先找出所有要删除的AI消息索引
    for (let i = lastUserIndex + 1; i < history.length; i++) {
        if (history[i].role === 'ai') {
            aiMessagesToDelete.push(i);
        }
    }
    
    console.log('要删除的AI消息数量:', aiMessagesToDelete.length, '索引:', aiMessagesToDelete);
    
    // 从后往前删除（避免索引变化问题）
    for (let i = aiMessagesToDelete.length - 1; i >= 0; i--) {
        const indexToDelete = aiMessagesToDelete[i];
        history.splice(indexToDelete, 1);
    }
    
    console.log('删除后的history长度:', history.length);
    
    // 3. 立即保存数据
    saveData();
    
    // 4. 重新渲染界面（现在只显示到用户消息，AI消息都被删除了）
    renderMessages(history);
    
    // 5. 清除输入框（确保不会显示用户消息）
    const textarea = document.getElementById('chat-textarea');
    if (textarea) {
        textarea.value = '';
        textarea.style.height = '36px';
    }
    
        // 6. 立即重新生成AI回复
    if (!currentContact || isTyping) return;
    
    console.log('开始重新生成AI回复，用户消息:', userMessage);
    
    isTyping = true;
    const {msgDiv, bubble} = appendMessageToDOM('', 'ai', true);
    
    mockAIResponse(userMessage, currentContact).then(aiReply => {
        console.log('AI回复收到:', aiReply);
        
        bubble.classList.remove('typing-indicator');
        bubble.innerHTML = '';
        
        typeMessageInMultipleBubbles(aiReply, bubble, msgDiv).then(({sentences, fullReply}) => {
            console.log('分割后的句子:', sentences);
            
            // 保存新生成的AI回复到历史记录
            if (sentences && sentences.length > 1) {
                sentences.forEach((sentence, index) => {
                    currentContact.history.push({ 
                        role: 'ai', 
                        content: sentence,
                        isSegment: true,
                        segmentIndex: index
                    });
                });
            } else {
                currentContact.history.push({ role: 'ai', content: fullReply });
                currentContact.lastChatTime = Date.now();

            }
            
            isTyping = false;
            simulateMemorySummary(currentContact);
            saveData();
            
            console.log('重新生成完成，最终history长度:', currentContact.history.length);
        });
    }).catch(error => {
        console.error('AI生成失败:', error);
        isTyping = false;
        bubble.textContent = '重新生成失败，请重试';
    });
}

// 温度滑块实时更新
document.getElementById('temperature').addEventListener('input', function() {
    document.getElementById('temperature-value').textContent = this.value;
});

// 加载时更新滑块显示
document.addEventListener('DOMContentLoaded', function() {
    const tempSlider = document.getElementById('temperature');
    const tempValue = document.getElementById('temperature-value');
    if (tempSlider && tempValue) {
        tempValue.textContent = tempSlider.value;
    }
});

function initParamSliders() {
    const tempTrack = document.getElementById('temp-track');
    const tempThumb = document.getElementById('temp-slider-thumb');
    const tempValue = document.getElementById('temperature-value');
    const tempInput = document.getElementById('temperature');

    const tokenTrack = document.getElementById('maxTokens-track');
    const tokenThumb = document.getElementById('maxTokens-thumb');
    const tokenValue = document.getElementById('maxTokens-value');
    const tokenInput = document.getElementById('maxTokens-input');

    function setupSlider(track, thumb, display, input, min, max, isFloat) {
        if (!track || !thumb) return;
        let isDragging = false;

        const update = (clientX) => {
            const rect = track.getBoundingClientRect();
            let percent = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            let value = min + (percent / 100) * (max - min);
            
            if (isFloat) {
                value = parseFloat(value.toFixed(1));
            } else {
                // 修改点：改为更平滑的 128 步进，避免大跨度跳回
                value = Math.round(value / 128) * 128;
                if (value > max) value = max;
                if (value < min) value = min;
            }
            
            const finalPercent = ((value - min) / (max - min)) * 100;
            thumb.style.left = finalPercent + '%';
            display.textContent = value;
            input.value = value;
        };

        const onMouseDown = (e) => { isDragging = true; update(e.clientX); };
        const onMouseMove = (e) => { if (isDragging) update(e.clientX); };
        const onMouseUp = () => { isDragging = false; };
        const onTouchStart = (e) => { isDragging = true; update(e.touches[0].clientX); e.preventDefault(); };
        const onTouchMove = (e) => { if (isDragging) update(e.touches[0].clientX); };

        track.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        thumb.addEventListener('touchstart', onTouchStart, {passive: false});
        document.addEventListener('touchmove', onTouchMove, {passive: false});
        document.addEventListener('touchend', onMouseUp);

        // 初始化位置：直接从现有数据读取
        const currentVal = isFloat ? (parseFloat(input.value) || 0.7) : (parseInt(input.value) || 2048);
        const initPercent = ((currentVal - min) / (max - min)) * 100;
        thumb.style.left = initPercent + '%';
        display.textContent = currentVal;
    }

    setupSlider(tempTrack, tempThumb, tempValue, tempInput, 0.1, 2.0, true);
    setupSlider(tokenTrack, tokenThumb, tokenValue, tokenInput, 256, 4096, false);
}

// 页面加载后立即启动
document.addEventListener('DOMContentLoaded', initParamSliders);

// 计算缓存大小并更新显示
function updateCacheSize() {
    try {
        // 计算总数据大小
        const dataStr = JSON.stringify(APP_DATA);
        const dataSize = new Blob([dataStr]).size; // 字节
        
        // 转换为人性化的显示单位
        let displaySize, displayUnit;
        if (dataSize < 1024) {
            displaySize = dataSize;
            displayUnit = 'B';
        } else if (dataSize < 1024 * 1024) {
            displaySize = (dataSize / 1024).toFixed(1);
            displayUnit = 'KB';
        } else {
            displaySize = (dataSize / (1024 * 1024)).toFixed(2);
            displayUnit = 'MB';
        }
        
        // 计算进度条（假设最大5MB）
        const maxSize = 5 * 1024 * 1024; // 5MB
        const percentage = Math.min(100, (dataSize / maxSize) * 100);
        
        // 更新显示
        const sizeElement = document.getElementById('cache-size');
        const progressElement = document.getElementById('cache-progress');
        
        if (sizeElement) {
            sizeElement.textContent = `${displaySize} ${displayUnit}`;
        }
        if (progressElement) {
            progressElement.style.width = `${percentage}%`;
            
            // 根据使用率改变颜色
            if (percentage > 90) {
                progressElement.style.background = 'var(--danger-color)';
            } else if (percentage > 70) {
                progressElement.style.background = 'var(--warning-color)';
            } else {
                progressElement.style.background = 'var(--accent-color)';
            }
        }
    } catch (error) {
        console.error('计算缓存大小失败:', error);
        const sizeElement = document.getElementById('cache-size');
        if (sizeElement) {
            sizeElement.textContent = '计算失败';
        }
    }
}

// 在数据变化时更新缓存显示
function saveData() {
    console.log('保存数据到本地存储:', APP_DATA); // 调试用
    localStorage.setItem('AI_PHONE_APP_DATA', JSON.stringify(APP_DATA));
}

// 页面加载时计算缓存大小
document.addEventListener('DOMContentLoaded', function() {
    // 延迟一点确保页面加载完成
    setTimeout(updateCacheSize, 500);
});

// 在导入/导出数据后也更新显示
function exportData() {
    const dataStr = JSON.stringify(APP_DATA, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
    
    const exportFileDefaultName = 'ai_chat_data.json';
    
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
    
    alert('数据已导出为 JSON 文件');
    updateCacheSize(); // 导出后更新显示
}

function importData() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const importedData = JSON.parse(e.target.result);
                APP_DATA = importedData;
                saveData();
                alert('数据导入成功！页面将刷新');
                location.reload();
            } catch (error) {
                alert('文件格式错误，请选择正确的JSON文件');
            }
        };
        reader.readAsText(file);
    };
    
    input.click();
}

// 点击空白处退出管理模式
document.addEventListener('click', function(event) {
    if (isManageMode) {
        // 检查点击的是否是管理相关元素
        const isManageButton = event.target.closest('.manage-button');
        const isContactItem = event.target.closest('.contact-item');
        const isBatchToolbar = event.target.closest('.batch-toolbar');
        
        // 如果点击的不是这些元素，退出所有管理模式
        if (!isManageButton && !isContactItem && !isBatchToolbar) {
            // 直接退出所有模式
            isManageMode = false;
            batchMode = false;
            selectedContacts.clear();
            document.getElementById('batch-toolbar').classList.remove('show');
            renderContacts(); // 重新渲染，退出编辑模式
        }
    }
});

// 紧急修复聊天功能
function quickFixChat() {
    const textarea = document.getElementById('chat-textarea');
    if (!textarea) return;
    
    // 移除所有现有的事件监听器
    const newTextarea = textarea.cloneNode(true);
    textarea.parentNode.replaceChild(newTextarea, textarea);
    
    // 重新绑定事件
    newTextarea.addEventListener('keydown', function(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    });
    
    newTextarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });
}


// 修复回车问题的终极方案
function initChatInput() {
    const textarea = document.getElementById('chat-textarea');
    if (!textarea) {
        setTimeout(initChatInput, 100);
        return;
    }
    
    // 移除所有旧事件
    const newTextarea = textarea.cloneNode(true);
    textarea.parentNode.replaceChild(newTextarea, textarea);
    
    // 绑定回车事件 - 最简单的实现
    newTextarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            // Shift+Enter = 换行
            if (e.shiftKey) {
                return; // 允许默认行为
            }
            
            // 纯Enter = 发送
            e.preventDefault();
            
            const text = this.value.trim();
            if (text && currentContact && !isTyping) {
                // 保存文本，清空输入框
                const messageText = text;
                this.value = '';
                this.style.height = '36px';
                
                // 延迟执行，确保输入框清空
                setTimeout(() => {
                    // 手动执行发送逻辑
                    appendMessageToDOM(messageText, 'user');
                    currentContact.history.push({ role: 'user', content: messageText });
                    currentContact.lastChatTime = Date.now();

                    // AI回复
                    isTyping = true;
                    const {msgDiv, bubble} = appendMessageToDOM('', 'ai', true);
                    
        mockAIResponse(messageText, currentContact).then(aiReply => {
            bubble.classList.remove('typing-indicator');

                        bubble.innerHTML = '';
                        
                        typeMessageInMultipleBubbles(aiReply, bubble, msgDiv).then(({sentences, fullReply}) => {
                            if (sentences && sentences.length > 1) {
                                sentences.forEach((sentence, index) => {
                                    currentContact.history.push({ 
                                        role: 'ai', 
                                        content: sentence,
                                        isSegment: true,
                                        segmentIndex: index
                                    });
                                });
                            } else {
                                currentContact.history.push({ role: 'ai', content: fullReply });
                                currentContact.lastChatTime = Date.now();

                            }
                            
                            isTyping = false;
                            simulateMemorySummary(currentContact);
                            saveData();
                        });
                    });
                }, 10);
            }
        }
    });
    
    // 自动调整高度
    newTextarea.addEventListener('input', function() {
        this.style.height = 'auto';
        const height = Math.min(this.scrollHeight, 100);
        this.style.height = height + 'px';
    });
}

// 页面加载后初始化
setTimeout(initChatInput, 500);

function refreshAllData() {
    const refreshBtn = document.querySelector('.refresh-btn');
    const icon = refreshBtn?.querySelector('i');
    
// 先保存当前数据
    saveData();
        
    // 延迟后刷新整个网页
    setTimeout(() => {
        location.reload();
    }, 300);

    if (icon) {
        // 1. 点击后转几圈
        let rotation = 0;
        let circles = 0;
        const maxCircles = 1; // 转3圈
        
        const spin = () => {
            rotation += 5; 
            icon.style.transform = `rotate(${rotation}deg)`;
            
            // 每360度算一圈
            if (rotation >= 360) {
                rotation = 0;
                circles++;
            }
            
            // 转够圈数就停
            if (circles < maxCircles) {
                requestAnimationFrame(spin);
            } else {
                icon.style.transform = 'rotate(0deg)';
                // 刷新完成后提示
                setTimeout(() => {
                    alert('已刷新');
                }, 100);
            }
        };
        
        // 开始转
        spin();
        
        // 2. 执行刷新逻辑
        const savedData = localStorage.getItem('AI_PHONE_APP_DATA');
        if (savedData) {
            try {
                APP_DATA = JSON.parse(savedData);
            } catch (error) {
                console.error('数据解析失败:', error);
            }
        }
        renderContacts();
    }
}

// 监听滚动加载
document.addEventListener('DOMContentLoaded', function() {
    const messagesContainer = document.getElementById('chat-messages');
    if (messagesContainer) {
        messagesContainer.addEventListener('scroll', function() {
            // 滚动到顶部附近时加载更多
            if (this.scrollTop < 100 && currentStartIndex > 0 && !isLoadingMore) {
                loadMoreMessages();
            }
        });
    }
});

// 监听所有滚动事件关闭菜单
window.addEventListener('scroll', closeAIMenu);
document.getElementById('chat-messages')?.addEventListener('scroll', closeAIMenu);

function doCreateNewPreset() {
    // 直接打开编辑预设界面（不创建预设对象）
    const newPresetId = 'new_' + Date.now(); // 临时ID
    editPreset(newPresetId); // 使用现有的编辑函数
    
    // 在编辑界面中设置空值
    setTimeout(() => {
        const nameInput = document.getElementById('edit-preset-name');
        const urlInput = document.getElementById('edit-api-url');
        const keyInput = document.getElementById('edit-api-key');
        const modelInput = document.getElementById('edit-default-model');
        
        if (nameInput) nameInput.value = '';
        if (urlInput) urlInput.value = '';
        if (keyInput) keyInput.value = '';
        if (modelInput) modelInput.value = '';
        
        // 聚焦到预设名输入框（可选，如果不需要自动聚焦可以去掉）
        // if (nameInput) nameInput.focus();
    }, 100);
}

function refreshPresetList() {
    const list = document.getElementById('preset-list');
    
    console.log('刷新预设列表，预设数量:', APP_DATA.presets ? APP_DATA.presets.length : 0);
    
    if (!APP_DATA.presets || APP_DATA.presets.length === 0) {
        list.innerHTML = `
            <div style="text-align: center; padding: 40px; color: var(--text-color-secondary);">
                <div style="font-size: 48px; margin-bottom: 20px;">📁</div>
                <div>无预设</div>
            </div>
        `;

    } else {
        // 【新增】按最后使用时间排序（最新的在前面）
        const sortedPresets = [...APP_DATA.presets].sort((a, b) => {
            // 获取最后使用时间，如果没有则用0
            const timeA = a.lastUsedTime || 0;
            const timeB = b.lastUsedTime || 0;
            
            // 倒序排序：时间大的（新的）在前面
            return timeB - timeA;
        });
        
        // 如果有预设，显示预设列表（按排序后的顺序）
        list.innerHTML = '';
        sortedPresets.forEach(preset => {  // ← 这里改为 sortedPresets
            const div = document.createElement('div');
            div.style.cssText = `
                padding: 12px 15px; margin-bottom: 8px; border-radius: 10px;
                background: var(--input-bg); border: 1px solid var(--input-border);
                position: relative;
                min-height: 60px; /* 固定最小高度 */
            `;
            
            // 主内容区域（点击选择）
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
                cursor: pointer;
                margin-right: 70px; /* 给按钮留空间 */
            `;
            
            contentDiv.innerHTML = `
                <div style="font-weight: bold; color: var(--text-color-primary); font-size: 17px;">
                    ${preset.name}
                </div>
                <div style="font-size: 14px; color: var(--accent-color); margin-top: 8px;">
                    ${preset.defaultModel || '无模型'}
                </div>
            `;
            
            contentDiv.onclick = function() {
    console.log('选择预设:', preset.name);
    
    // 1. 先加载预设数据
    loadPreset(preset.id);
    
    // 2. 关闭弹窗（用hideModal确保动画正确）
    hideModal('preset-modal');
    
    // 3. 【重要】保存当前设置
    saveData();
    
    // 4. 更新主页面显示
    document.getElementById('api-preset-display').value = preset.name;
    
    // 5. 隐藏API输入字段（因为现在有预设了）
    const apiFieldsContainer = document.getElementById('api-fields-container');
    if (apiFieldsContainer) {
        apiFieldsContainer.style.display = 'none';
    }
    document.getElementById('save-preset-btn').style.display = 'none';
    
    console.log('已选择预设:', preset.name);
};
            
            div.appendChild(contentDiv);
            
            // 操作按钮容器
            const actionsDiv = document.createElement('div');
                        actionsDiv.style.cssText = `
                position: absolute;
                right: 10px;
                top: 50%;  /* 垂直居中 */
                transform: translateY(-50%);  /* 垂直居中 */
                display: flex;
                gap: 6px;
            `;
            
            // 编辑按钮
            const editBtn = document.createElement('button');
            editBtn.innerHTML = '✎';
            editBtn.style.cssText = `
                width: 30px;
                height: 30px;
                border-radius: 6px;
                background: var(--accent-color);
                color: white;
                border: none;
                cursor: pointer;
                font-size: 14px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            editBtn.title = '编辑预设';
            editBtn.onclick = function(e) {
                e.stopPropagation(); // 阻止冒泡，避免触发选择
                editPreset(preset.id);
            };
            
            // 删除按钮
            const deleteBtn = document.createElement('button');
            deleteBtn.innerHTML = '×';
            deleteBtn.style.cssText = `
                width: 30px;
                height: 30px;
                border-radius: 6px;
                background: var(--danger-color);
                color: white;
                border: none;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            deleteBtn.title = '删除预设';
            deleteBtn.onclick = function(e) {
                e.stopPropagation(); // 阻止冒泡
                deletePreset(preset.id);
            };
            
            actionsDiv.appendChild(editBtn);
            actionsDiv.appendChild(deleteBtn);
            div.appendChild(actionsDiv);
            
            list.appendChild(div);
        });
    }

// 【新增】确保列表滚动到顶部
    setTimeout(() => {
        if (list) {
            list.scrollTop = 0;
        }
    }, 50);
}

function openPresetManager() {
    // 显示弹窗
    const modal = document.getElementById('preset-modal');
    modal.style.display = 'flex';
    modal.offsetWidth; // 触发重排
    modal.classList.add('active');
    
    // 然后刷新预设列表
    refreshPresetList();
}


// 显示模型选择弹窗
function showModelSelectDialog(models) {
    // 创建弹窗
    const modal = document.createElement('div');
    modal.id = 'model-select-modal';
    modal.className = 'overlay';
    modal.style.display = 'flex';
    modal.style.zIndex = '2000';
    
    modal.innerHTML = `
    <div style="
        background: var(--bg-color-secondary); 
        border-radius: 20px; 
        width: 90vw;
        max-width: 420px; 
        height: 80vh;
        max-height: 700px;
        display: flex; 
        flex-direction: column; 
        overflow: hidden;
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    ">
        <!-- 标题 -->
        <div style="
            padding: 24px 24px 16px 24px; 
            flex-shrink: 0;
        ">
            <h4 style="
                margin: 0; 
                color: var(--text-color-primary);
                font-size: 20px;
                font-weight: 600;
                text-align: center;
            ">
                选择模型 (${models.length}个)
            </h4>
        </div>
        
        <!-- 搜索框 - 左右有边距 -->
        <div style="
            padding: 0 24px 16px 24px; 
            flex-shrink: 0;
        ">
            <input type="text" id="model-search-input" 
                   placeholder="搜索模型..." 
                   style="
                        width: 100%; 
                        padding: 15px 18px;
                        border-radius: 14px; 
                        border: 1px solid var(--input-border); 
                        background: var(--input-bg); 
                        color: var(--text-color-primary);
                        font-size: 16px;
                        box-sizing: border-box;
                        outline: none;
                   ">
        </div>
        
        <!-- 模型列表容器 - 关键：独立滚动区域 -->
        <div style="
            flex: 1; 
            overflow: hidden;
            position: relative;
            margin: 0 24px;
            background: var(--bg-color-secondary);
            border-radius: 12px;
        ">
            <div id="model-items-container" style="
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                overflow-y: auto;
                overflow-x: hidden;
                scrollbar-width: none;
                -ms-overflow-style: none;
                -webkit-overflow-scrolling: touch;
                padding: 0 12px 100px 12px; /* 底部100px确保不被遮挡 */
            ">
                <!-- 模型列表在这里 -->
            </div>
        </div>
        
        <!-- 底部按钮 - 绝对定位在容器外 -->
        <div style="
            padding: 20px 24px 24px 24px; 
            flex-shrink: 0;
            background: var(--bg-color-secondary);
            border-top: 1px solid var(--input-border);
        ">
            <button onclick="document.getElementById('model-list-modal').remove()" 
                    style="
                        width: 100%; 
                        padding: 18px; 
                        border-radius: 14px;
                        background: var(--input-bg); 
                        color: var(--text-color-primary);
                        border: 1px solid var(--input-border);
                        font-size: 17px;
                        font-weight: 500;
                        cursor: pointer;
                    ">
                取消
            </button>
        </div>
    </div>
`;
    
    document.body.appendChild(modal);
    
    // 填充模型列表
    const container = document.getElementById('model-list-container');
    renderModelList(models, container);
    
    // 搜索功能
    const searchInput = document.getElementById('model-search');
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => {
            const modelId = (model.id || model).toLowerCase();
            return modelId.includes(searchTerm);
        });
        renderModelList(filteredModels, container);
    });
    
    // 点击外部关闭
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            modal.remove();
        }
    });
    
   
}

// 渲染模型列表
function renderModelList(models, container) {
    container.innerHTML = '';
    
    if (models.length === 0) {
        container.innerHTML = `
            <div style="padding: 30px; text-align: center; color: var(--text-color-secondary);">
                未找到匹配的模型
            </div>
        `;
        return;
    }
    
    models.forEach((model, index) => {
        const modelId = model.id || model;
        const modelName = modelId.split('/').pop(); // 取最后一部分
        
        const item = document.createElement('div');
        item.className = 'model-item';
        // 修改item.style.cssText
item.style.cssText = `
    padding: 18px 20px; 
    margin: 0 auto 12px auto; /* 居中：左右auto */
    border-radius: 14px;
    border: 1px solid var(--input-border); 
    cursor: pointer;
    background: var(--input-bg); 
    transition: all 0.2s;
    width: 100%; 
    max-width: 100%; /* 确保不超过容器 */
    box-sizing: border-box;
    word-break: break-word;
    text-align: left; /* 文字左对齐 */
    display: block; /* 确保居中生效 */
`;

// 修改内容HTML，文字左对齐但整体居中
item.innerHTML = `
    <div style="
        font-weight: 600; 
        color: var(--text-color-primary);
        font-size: 17px;
        margin-bottom: 8px;
        text-align: left;
    ">
        ${displayName}
    </div>
    <div style="
        font-size: 14px; 
        color: var(--text-color-secondary); 
        line-height: 1.4;
        text-align: left;
        opacity: 0.8;
    ">
        ${modelId}
    </div>
`;
        
        item.onclick = function() {
            document.getElementById('ai-model').value = modelId;
            document.getElementById('model-select-modal').remove();
        };
        
        item.addEventListener('mouseenter', function() {
            this.style.backgroundColor = 'var(--input-bg)';
        });
        
        item.addEventListener('mouseleave', function() {
            this.style.backgroundColor = '';
        });
        
        container.appendChild(item);
    });
}

async function openModelSelector() {
    // 先检查API信息
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    
    if (!apiUrl || !apiKey) {
        alert('请先填写API URL和API Key');
        return;
    }
    
    // 显示加载弹窗
    const loadingModal = document.createElement('div');
    loadingModal.id = 'loading-model-modal';
    loadingModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
    `;
    
    loadingModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); padding: 30px; border-radius: 16px; 
                    min-width: 200px; text-align: center;">
            <div style="margin-bottom: 15px;">
                <i class="fa-solid fa-spinner fa-spin" style="font-size: 24px;"></i>
            </div>
            <div>正在获取模型列表...</div>
        </div>
    `;
    
    document.body.appendChild(loadingModal);
    
    try {
        // 尝试获取模型列表
        const models = await fetchModelList(apiUrl, apiKey);
        
        // 移除加载弹窗
        loadingModal.remove();
        
        if (models.length === 0) {
            // 获取失败，显示手动输入
            showManualInputModal();
        } else {
            // 显示模型选择列表
            showModelListModal(models);
        }
        
    } catch (error) {
        // 移除加载弹窗
        loadingModal.remove();
        
        console.error('获取模型失败:', error);
        
        // 更友好的错误提示
        let errorMsg = '获取模型失败: ' + error.message;
        if (error.message.includes('无法找到可用的模型列表端点')) {
            errorMsg = '无法自动获取模型列表。\n\n可能原因：\n1. 该API提供商不支持自动获取模型列表\n2. 模型列表端点与标准OpenAI格式不同\n3. 需要手动输入模型名称';
        }
        
        alert(errorMsg);
        // 显示手动输入
        showManualInputModal();
    }
}

// 获取模型列表
async function fetchModelList(apiUrl, apiKey) {
    console.log('开始获取模型列表，API URL:', apiUrl);
    
    // 尝试多种可能的模型列表端点
    const possibleEndpoints = [];
    
    // 1. 从聊天URL推断模型列表URL
    if (apiUrl.includes('/chat/completions')) {
        // 尝试替换为 /models
        possibleEndpoints.push(apiUrl.replace('/chat/completions', '/models'));
        // 尝试替换为 /v1/models
        possibleEndpoints.push(apiUrl.replace('/v1/chat/completions', '/v1/models'));
        // 尝试移除路径部分
        const baseUrl = apiUrl.split('/chat/completions')[0];
        possibleEndpoints.push(baseUrl + '/models');
        possibleEndpoints.push(baseUrl + '/v1/models');
    }
    
    // 2. 添加一些常见公益站的特定端点
    if (apiUrl.includes('openrouter.ai')) {
        possibleEndpoints.push('https://openrouter.ai/api/v1/models');
    }
    if (apiUrl.includes('api.openai.com')) {
        possibleEndpoints.push('https://api.openai.com/v1/models');
    }
    
    // 3. 最后尝试直接使用 /models
    possibleEndpoints.push(apiUrl.replace(/\/chat\/completions.*$/, '') + '/models');
    
    // 去重
    const uniqueEndpoints = [...new Set(possibleEndpoints.filter(url => url && url !== apiUrl))];
    
    console.log('尝试的端点列表:', uniqueEndpoints);
    
    let lastError = null;
    
    // 尝试每个可能的端点
    for (const modelsUrl of uniqueEndpoints) {
        try {
            console.log(`尝试端点: ${modelsUrl}`);
            
            const response = await fetch(modelsUrl, {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                timeout: 8000 // 8秒超时
            });
            
            if (!response.ok) {
                console.log(`端点 ${modelsUrl} 返回错误: ${response.status}`);
                continue; // 尝试下一个端点
            }
            
            const data = await response.json();
            console.log('获取到的原始数据:', data);
            
            // 多种格式的模型列表提取
            let models = [];
            
            if (Array.isArray(data)) {
                models = data;
            } else if (data.data && Array.isArray(data.data)) {
                models = data.data;
            } else if (data.models && Array.isArray(data.models)) {
                models = data.models;
            } else if (data.result && Array.isArray(data.result)) {
                models = data.result; // 有些API用result字段
            }
            
            // 提取模型ID
            const modelList = models.map(item => {
                if (typeof item === 'string') {
                    return { id: item };
                } else if (item.id) {
                    return { id: item.id };
                } else if (item.model) {
                    return { id: item.model }; // 有些用model字段
                }
                return null;
            }).filter(item => item && item.id);
            
            console.log(`成功从 ${modelsUrl} 获取到 ${modelList.length} 个模型`);
            
            if (modelList.length > 0) {
                return modelList;
            }
            
        } catch (error) {
            console.log(`端点 ${modelsUrl} 失败:`, error.message);
            lastError = error;
            continue; // 继续尝试下一个
        }
    }
    
    // 所有端点都失败了
    throw new Error(lastError ? `获取模型列表失败: ${lastError.message}` : '无法找到可用的模型列表端点');
}

// 为fetch添加timeout支持
if (!fetch.timeout) {
    fetch.timeout = function(resource, options = {}) {
        const { timeout = 8000 } = options;
        
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        
        return fetch(resource, {
            ...options,
            signal: controller.signal
        }).then(response => {
            clearTimeout(id);
            return response;
        }).catch(error => {
            clearTimeout(id);
            throw error;
        });
    };
}
// 显示模型列表弹窗
function showModelListForEdit(models) {
    const modal = document.createElement('div');
    modal.id = 'model-list-edit-modal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    modal.innerHTML = `
    <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                width: 100%; max-width: 320px; max-height: 70vh;
                display: flex; flex-direction: column;">
        <div style="padding: 20px; border-bottom: 1px solid var(--input-border);">
            <h4 style="margin: 0; color: var(--text-color-primary);">选择模型 (${models.length}个)</h4>
        </div>
        
        <div style="padding: 15px; flex: 1; overflow-y: auto;">
            <input type="text" id="model-search-edit-input" 
                   placeholder="搜索模型..." 
                   style="width: 90%; padding: 10px 15px; margin: 0 auto 15px auto;
                          border-radius: 10px; border: 1px solid var(--input-border); 
                          background: var(--input-bg); color: var(--text-color-primary);
                          display: block;">
            
            <div id="model-items-edit-container" style="max-height: 50vh; overflow-y: auto;">
                <!-- 模型列表会在这里动态生成 -->
            </div>
        </div>
        
        <div style="padding: 15px; border-top: 1px solid var(--input-border); text-align: center;">
            <button onclick="document.getElementById('model-list-edit-modal').remove()" 
                    style="padding: 10px 20px; border-radius: 8px;
                           background: var(--input-bg); color: var(--text-color-primary);
                           border: 1px solid var(--input-border); cursor: pointer;">
                取消
            </button>
        </div>
    </div>
    `;
    
    document.body.appendChild(modal);
    
    // 填充模型列表
    renderModelsForEdit(models);
    
    // 搜索功能
    const searchInput = document.getElementById('model-search-edit-input');
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => {
            const modelId = (model.id || model).toLowerCase();
            return modelId.includes(searchTerm);
        });
        renderModelsForEdit(filteredModels);
    });
    
    // 点击外部关闭
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            modal.remove();
        }
    });
    
    
}

function renderModelsForEdit(models) {
    const container = document.getElementById('model-items-edit-container');
    container.innerHTML = '';
    
    if (models.length === 0) {
        container.innerHTML = `
            <div style="padding: 30px; text-align: center; color: var(--text-color-secondary);">
                未找到匹配的模型
            </div>
        `;
        return;
    }
    
    models.forEach((model) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop();
        
        const item = document.createElement('div');
        item.style.cssText = `
            padding: 12px 15px; margin: 0 10px 8px 10px; border-radius: 10px;
            border: 1px solid var(--input-border); cursor: pointer;
            background: var(--input-bg); transition: all 0.2s;
            width: calc(100% - 20px);
            box-sizing: border-box;
            overflow: hidden;
            word-break: break-word;
        `;
        
        item.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary);">
                ${displayName}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px;">
                ${modelId}
            </div>
        `;
        
        item.onclick = function() {
            // 更新编辑弹窗中的模型输入框
            document.getElementById('edit-default-model').value = modelId;
            // 关闭模型选择弹窗
            document.getElementById('model-list-edit-modal').remove();
        };
        
        // 悬停效果
        item.addEventListener('mouseenter', function() {
            this.style.backgroundColor = 'rgba(var(--accent-color-rgb), 0.1)';
            this.style.borderColor = 'var(--accent-color)';
        });
        
        item.addEventListener('mouseleave', function() {
            this.style.backgroundColor = '';
            this.style.borderColor = '';
        });
        
        container.appendChild(item);
    });
}

// 显示手动输入弹窗（备用）
function showManualInputModal() {
    const modelName = prompt('请输入模型名称（例如：qwen-72b-chat）:', 
                            document.getElementById('ai-model').value);
    if (modelName && modelName.trim()) {
        document.getElementById('ai-model').value = modelName.trim();
    }
}

function editPreset(presetId) {
    const isNewPreset = presetId.toString().startsWith('new_');
    let preset;
    
    if (isNewPreset) {
        // 新建模式，创建临时预设对象
        preset = {
            id: presetId,
            name: '',
            apiUrl: '',
            apiKey: '',
            defaultModel: ''
        };
    } else {
        // 编辑现有预设
        preset = APP_DATA.presets.find(p => p.id == presetId);
    }
    
    if (!preset) return;    
    // 先关闭API弹窗，等待动画完成
    const presetModal = document.getElementById('preset-modal');
    if (presetModal && presetModal.style.display === 'flex') {
        // 开始关闭动画
        presetModal.classList.remove('active');
        
                // 【立即创建编辑弹窗，不要等待！】
        const editModal = document.createElement('div');
        editModal.id = 'edit-preset-modal';
        editModal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
            
            editModal.innerHTML = `
    <div style="
        background: var(--bg-color-secondary);
        border-radius: 16px;
        padding: 20px;  // 内边距也改小一点
        width: 90%;
        max-width: 300px;  // 改这里，更小一点
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    ">
                    <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">
            ${isNewPreset ? '新建配置' : '编辑配置'}
        </h4>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                            配置名称
                        </label>
                        <input type="text" id="edit-preset-name" 
                               style="width: 100%; padding: 12px; border-radius: 8px; 
                                      border: 1px solid var(--input-border); 
                                      background: var(--input-bg); color: var(--text-color-primary);
                                      cursor: pointer; box-sizing: border-box;"
                               value="${preset.name || ''}">
                    </div>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                            API URL
                        </label>
                        <input type="text" id="edit-api-url" 
                               style="width: 100%; padding: 12px; border-radius: 8px; 
                                      border: 1px solid var(--input-border); 
                                      background: var(--input-bg); color: var(--text-color-primary);
                                      cursor: pointer; box-sizing: border-box;"
                               value="${preset.apiUrl || ''}">
                    </div>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                            API Key
                        </label>
                        <input type="password" id="edit-api-key" 
                               style="width: 100%; padding: 12px; border-radius: 8px; 
                                      border: 1px solid var(--input-border); 
                                      background: var(--input-bg); color: var(--text-color-primary);
                                      cursor: pointer; box-sizing: border-box;"
                               value="${preset.apiKey || ''}">
                    </div>
                    
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                            模型
                        </label>
                        <input type="text" id="edit-default-model" readonly
                               style="width: 100%; padding: 12px; border-radius: 8px; 
                                      border: 1px solid var(--input-border); 
                                      background: var(--input-bg); color: var(--text-color-primary);
                                      cursor: pointer; box-sizing: border-box;"
                               value="${preset.defaultModel || ''}"
                               placeholder="点击选择模型"
                               onclick="openModelSelectorForEdit()">
                    </div>
                    
                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button onclick="closeEditPresetModal()"
                                style="padding: 10px 20px; border-radius: 8px; 
                                       background: var(--input-bg); color: var(--text-color-primary);
                                       border: 1px solid var(--input-border); cursor: pointer;">
                            取消
                        </button>
                        <button onclick="savePresetEdit('${presetId}')"
                                style="padding: 10px 20px; border-radius: 8px; 
                                       background: var(--accent-color); color: white;
                                       border: none; cursor: pointer;">
                            保存
                        </button>
                    </div>
                </div>
            `;
            
            // 延迟一点开始淡入（和API弹窗淡出同时）
        setTimeout(() => {
            editModal.style.opacity = '1';
        }, 10);

            document.body.appendChild(editModal);
            
            // 点击外部关闭
            editModal.addEventListener('click', function(e) {
                if (e.target === editModal) {
                    closeEditPresetModal();
                }
            });
            
         // 等待动画完成后隐藏API弹窗
        setTimeout(() => {
            presetModal.style.display = 'none';
        }, 300);
        
    } else {
        // 如果API弹窗本来就没显示，直接创建编辑弹窗
        const editModal = document.createElement('div');
        editModal.id = 'edit-preset-modal';
        editModal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: modalFadeIn 0.3s ease;
        `;
        
        editModal.innerHTML = `
            <div style="
                background: var(--bg-color-secondary);
                border-radius: 16px;
                padding: 24px;
                width: 90%;
                max-width: 350px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            ">
                <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">
                    编辑
                </h4>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                        配置名称
                    </label>
                    <input type="text" id="edit-preset-name" 
                           style="width: 100%; padding: 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  cursor: pointer; box-sizing: border-box;"
                           value="${preset.name || ''}">
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                        API URL
                    </label>
                    <input type="text" id="edit-api-url" 
                           style="width: 100%; padding: 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  cursor: pointer; box-sizing: border-box;"
                           value="${preset.apiUrl || ''}">
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                        API Key
                    </label>
                    <input type="password" id="edit-api-key" 
                           style="width: 100%; padding: 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  cursor: pointer; box-sizing: border-box;"
                           value="${preset.apiKey || ''}">
                </div>
                
                <div style="margin-bottom: 24px;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-color-primary);">
                        模型
                    </label>
                    <input type="text" id="edit-default-model" readonly
                           style="width: 100%; padding: 12px; border-radius: 8px; 
                                  border: 1px solid var(--input-border); 
                                  background: var(--input-bg); color: var(--text-color-primary);
                                  cursor: pointer; box-sizing: border-box;"
                           value="${preset.defaultModel || ''}"
                           placeholder="点击选择模型"
                           onclick="openModelSelectorForEdit()">
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button onclick="closeEditPresetModal()"
                            style="padding: 10px 20px; border-radius: 8px; 
                                   background: var(--input-bg); color: var(--text-color-primary);
                                   border: 1px solid var(--input-border); cursor: pointer;">
                        取消
                    </button>
                    <button onclick="savePresetEdit('${presetId}')"
                            style="padding: 10px 20px; border-radius: 8px; 
                                   background: var(--accent-color); color: white;
                                   border: none; cursor: pointer;">
                        保存
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(editModal);
        
        // 点击外部关闭
        editModal.addEventListener('click', function(e) {
            if (e.target === editModal) {
                closeEditPresetModal();
            }
        });
    }
}

function savePresetEdit(presetId) {
    const isNewPreset = presetId.toString().startsWith('new_');
    let preset;
    
    if (isNewPreset) {
        // 新建配置
        preset = {
            id: Date.now(),
            name: '',
            apiUrl: '',
            apiKey: '',
            defaultModel: ''
        };
        APP_DATA.presets.push(preset);
    } else {
        // 编辑现有配置
        preset = APP_DATA.presets.find(p => p.id == presetId);
    }
    
    if (!preset) return;
    
    const name = document.getElementById('edit-preset-name').value.trim();
    const apiUrl = document.getElementById('edit-api-url').value.trim();
    const apiKey = document.getElementById('edit-api-key').value.trim();
    const defaultModel = document.getElementById('edit-default-model').value.trim();
    
    if (!name) {
        alert('配置名称不能为空');
        return;
    }
    
    if (!apiUrl || !apiKey) {
        alert('API URL 和 API Key 不能为空');
        return;
    }
    
    // 更新预设信息
    preset.name = name;
    preset.apiUrl = apiUrl;
    preset.apiKey = apiKey;
    preset.defaultModel = defaultModel;
    
// 【新增】如果是当前选中的预设，更新使用时间
    if (APP_DATA.currentPresetId === preset.id) {
        preset.lastUsedTime = Date.now();
}
    // 如果是新建的预设并且没有当前预设，就设为当前
    if (isNewPreset && !APP_DATA.currentPresetId) {
        APP_DATA.currentPresetId = preset.id;
        document.getElementById('api-preset-display').value = preset.name;
        
        // 同步到settings
        APP_DATA.settings.apiUrl = apiUrl;
        APP_DATA.settings.apiKey = apiKey;
        APP_DATA.settings.aiModel = defaultModel;
    }
    
    // 保存数据
    saveData();
    
    // 移除编辑弹窗
    const editModal = document.getElementById('edit-preset-modal');
    if (editModal) {
        editModal.style.opacity = '0';
        editModal.style.transition = 'opacity 0.3s ease';
        
        // 等待动画完成
        setTimeout(() => {
            if (editModal && editModal.parentNode) {
                editModal.remove();
            }
            
            // 刷新预设列表
            refreshPresetList();
            
            // 显示API弹窗
            showModal('preset-modal');
            
            // 显示成功消息
            setTimeout(() => {
                alert(isNewPreset ? '配置创建成功！' : '配置已更新');
            }, 100);
            
        }, 300);
    } else {
        refreshPresetList();
        showModal('preset-modal');
        alert(isNewPreset ? '配置创建成功！' : '配置已更新');
    }
}


function deletePreset(presetId) {
    const preset = APP_DATA.presets.find(p => p.id == presetId);
    if (!preset) return;
    
    if (!confirm(`确定要删除配置 "${preset.name}" 吗？此操作不可撤销。`)) {
        return;
    }
    
    // 如果要删除的是当前选中的预设
    if (APP_DATA.currentPresetId === presetId) {
        // 清除当前预设
        APP_DATA.currentPresetId = null;
        
        // 显示API输入字段
        document.getElementById('api-fields-container').style.display = 'block';
        document.getElementById('api-preset-display').value = '新建配置';
        document.getElementById('save-preset-btn').style.display = 'block';
        
        // 清空输入框
        document.getElementById('api-url').value = '';
        document.getElementById('api-key').value = '';
        document.getElementById('ai-model').value = '';
    }
    
    // 从数组中删除
    APP_DATA.presets = APP_DATA.presets.filter(p => p.id !== presetId);
    
    // 如果删除后没有预设了，确保预设数组存在
    if (APP_DATA.presets.length === 0) {
        APP_DATA.presets = [];
    }
    
    // 保存数据
    saveData();
    
    // 刷新预设列表
    refreshPresetList();
    
    alert('配置已删除');
}

async function openModelSelectorForEdit() {
    // 获取当前编辑弹窗中的API信息
    const apiUrl = document.getElementById('edit-api-url').value.trim();
    const apiKey = document.getElementById('edit-api-key').value.trim();
    
    if (!apiUrl || !apiKey) {
        alert('请先填写API URL和API Key');
        return;
    }
    
    // 显示加载弹窗
    const loadingModal = document.createElement('div');
    loadingModal.id = 'loading-edit-model-modal';
    loadingModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
    `;
    
    loadingModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); padding: 30px; border-radius: 16px; 
                    min-width: 200px; text-align: center;">
            <div style="margin-bottom: 15px;">
                <i class="fa-solid fa-spinner fa-spin" style="font-size: 24px;"></i>
            </div>
            <div>正在获取模型列表...</div>
        </div>
    `;
    
    document.body.appendChild(loadingModal);
    
    try {
        // 获取模型列表
        const models = await fetchModelList(apiUrl, apiKey);
        
        // 移除加载弹窗
        loadingModal.remove();
        
        if (models.length === 0) {
            alert('未获取到模型列表，请手动输入模型名称');
            return;
        }
        
        // 显示模型选择弹窗
        showModelListForEdit(models);
    } catch (error) {
        // 移除加载弹窗
        loadingModal.remove();
        
        console.error('获取模型失败:', error);
        
        let errorMsg = '获取模型失败: ' + error.message;
        if (error.message.includes('无法找到可用的模型列表端点')) {
            errorMsg = '无法自动获取模型列表。\n\n请手动输入模型名称，或检查：\n1. API URL是否正确\n2. API Key是否有权限\n3. 该API是否支持模型列表查询';
        }
        
        alert(errorMsg);
    }
}



function showModelListForEdit(models, presetId) {
    const modal = document.createElement('div');
    modal.id = 'model-list-edit-modal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    modal.innerHTML = `
    <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                width: 100%; max-width: 320px; max-height: 70vh;
                display: flex; flex-direction: column;">
        <div style="padding: 20px; border-bottom: 1px solid var(--input-border);">
            <h4 style="margin: 0; color: var(--text-color-primary);">选择模型 (${models.length}个)</h4>
        </div>
        
        <div style="padding: 15px; flex: 1; overflow-y: auto;">
            <input type="text" id="model-search-edit-input" 
                   placeholder="搜索模型..." 
                   style="width: 90%; padding: 10px 15px; margin: 0 auto 15px auto;
                          border-radius: 10px; border: 1px solid var(--input-border); 
                          background: var(--input-bg); color: var(--text-color-primary);
                          display: block;">
            
            <div id="model-items-edit-container">
                <!-- 模型列表会在这里动态生成 -->
            </div>
        </div>
    </div>
    `;
    
    document.body.appendChild(modal);
    
    // 填充模型列表
    renderModelsForEdit(models, presetId);
    
    // 搜索功能
    const searchInput = document.getElementById('model-search-edit-input');
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => {
            const modelId = (model.id || model).toLowerCase();
            return modelId.includes(searchTerm);
        });
        renderModelsForEdit(filteredModels, presetId);
    });
    
    // 点击外部关闭
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            modal.remove();
        }
    });
    
    
}

function renderModelsForEdit(models, presetId) {
    const container = document.getElementById('model-items-edit-container');
    container.innerHTML = '';
    
    if (models.length === 0) {
        container.innerHTML = `
            <div style="padding: 30px; text-align: center; color: var(--text-color-secondary);">
                未找到匹配的模型
            </div>
        `;
        return;
    }
    
    models.forEach((model) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop();
        
        const item = document.createElement('div');
        item.style.cssText = `
            padding: 12px 15px; margin: 0 10px 8px 10px; border-radius: 10px;
            border: 1px solid var(--input-border); cursor: pointer;
            background: var(--input-bg); transition: all 0.2s;
            width: calc(100% - 20px);
            box-sizing: border-box;
            overflow: hidden;
            word-break: break-word;
        `;
        
        item.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary);">
                ${displayName}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px;">
                ${modelId}
            </div>
        `;
        
        item.onclick = function() {
            // 更新编辑弹窗中的模型输入框
            document.getElementById('edit-default-model').value = modelId;
            // 关闭模型选择弹窗
            document.getElementById('model-list-edit-modal').remove();
        };
        
        container.appendChild(item);
    });
}

// 测试公益站API的辅助函数
function testPublicAPI(apiUrl, apiKey, modelName) {
    console.log("测试公益站API:", { apiUrl, apiKey, modelName });
    
    // 创建一个测试弹窗
    const testModal = document.createElement('div');
    testModal.id = 'test-api-modal';
    testModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
    `;
    
    testModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); border-radius: 16px; padding: 24px; 
                    width: 90%; max-width: 400px;">
            <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">
                测试API连接
            </h4>
            
            <div id="test-status" style="margin-bottom: 20px;">
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <i class="fa-solid fa-spinner fa-spin" style="margin-right: 10px;"></i>
                    <span>正在测试连接...</span>
                </div>
                <div id="test-details" style="font-size: 13px; color: var(--text-color-secondary);">
                    
                </div>
            </div>
            
            <div style="text-align: center;">
                <button onclick="document.getElementById('test-api-modal').remove()" 
                        style="padding: 10px 20px; border-radius: 8px;
                               background: var(--accent-color); color: white;
                               border: none; cursor: pointer;">
                    关闭
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(testModal);
    
    // 执行测试
    setTimeout(async () => {
        const statusEl = document.getElementById('test-status');
        const detailsEl = document.getElementById('test-details');
        
        try {
            // 测试1：获取模型列表
            detailsEl.innerHTML = '1. 正在获取模型列表...';
            const models = await fetchModelList(apiUrl, apiKey);
            
            detailsEl.innerHTML += `<br>✓ 成功获取到 ${models.length} 个模型`;
            
            // 测试2：发送测试请求
            detailsEl.innerHTML += '<br>2. 正在发送测试消息...';
            
            const testResponse = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: modelName || models[0]?.id,
                    messages: [{ role: 'user', content: 'Hello' }],
                    max_tokens: 10
                })
            });
            
            if (testResponse.ok) {
                const data = await testResponse.json();
                detailsEl.innerHTML += '<br>✓ API响应正常';
                
                statusEl.innerHTML = `
                    <div style="color: #07C160;">
                        <i class="fa-solid fa-check-circle" style="margin-right: 10px;"></i>
                        <span>API连接测试成功！</span>
                    </div>
                `;
            } else {
                detailsEl.innerHTML += `<br>✗ API响应错误: ${testResponse.status}`;
                statusEl.innerHTML = `
                    <div style="color: #C26D5E;">
                        <i class="fa-solid fa-times-circle" style="margin-right: 10px;"></i>
                        <span>API响应错误</span>
                    </div>
                `;
            }
            
        } catch (error) {
            detailsEl.innerHTML += `<br>✗ 测试失败: ${error.message}`;
            statusEl.innerHTML = `
                <div style="color: #C26D5E;">
                    <i class="fa-solid fa-times-circle" style="margin-right: 10px;"></i>
                    <span>API连接失败</span>
                </div>
            `;
        }
    }, 100);
}

function closeEditPresetModal() {
    const editModal = document.getElementById('edit-preset-modal');
    
    if (editModal) {
        // 淡出效果
        editModal.style.opacity = '0';
        editModal.style.transition = 'opacity 0.3s ease';
        
        // 等待动画完成后移除
        setTimeout(() => {
            if (editModal && editModal.parentNode) {
                editModal.remove();
            }
            
            // 显示API弹窗
            showModal('preset-modal');
        }, 300);
    } else {
        showModal('preset-modal');
    }
}

// 强制关闭所有弹窗
function forceCloseAllModals() {
    // 关闭所有.overlay弹窗
    document.querySelectorAll('.overlay').forEach(modal => {
        modal.style.display = 'none';
        modal.classList.remove('active');
    });
    
    // 关闭动态创建的弹窗
    const dynamicModals = [
        'edit-preset-modal',
        'model-list-modal', 
        'model-list-edit-modal',
        'loading-model-modal',
        'loading-edit-model-modal'
    ];
    
    dynamicModals.forEach(id => {
        const modal = document.getElementById(id);
        if (modal) modal.remove();
    });
    
    // 确保预设弹窗显示正常
    const presetModal = document.getElementById('preset-modal');
    if (presetModal) {
        presetModal.style.display = 'none';
        presetModal.classList.remove('active');
    }
    
    console.log('已强制关闭所有弹窗');
}

function selectPreset(presetId) {
    const apiFieldsContainer = document.getElementById('api-fields-container');
    const modelContainer = document.getElementById('current-preset-model-container');
    
    if (presetId === 'new') {
        // 新建配置模式
        document.getElementById('api-preset-display').value = '新建配置';
        document.getElementById('api-url').value = '';
        document.getElementById('api-key').value = '';
        document.getElementById('ai-model').value = '';
        
        // 【新增】隐藏当前预设模型选择框
        if (modelContainer) {
            modelContainer.style.display = 'none';
        }
        
        // 显示API输入字段（新建配置模式）
        if (apiFieldsContainer) {
            apiFieldsContainer.style.display = 'block';
        }
        
        document.getElementById('save-preset-btn').style.display = 'block';
        APP_DATA.currentPresetId = null;
    } else {
        // 加载现有预设
        loadPreset(presetId);
    }
}

// 打开当前预设的模型选择器
async function openCurrentPresetModelSelector() {
    if (!APP_DATA.currentPresetId) {
        alert('请先选择一个预设');
        return;
    }
    
    const preset = APP_DATA.presets.find(p => p.id == APP_DATA.currentPresetId);
    if (!preset) {
        alert('预设不存在');
        return;
    }
    
    const apiUrl = preset.apiUrl || '';
    const apiKey = preset.apiKey || '';
    
    if (!apiUrl || !apiKey) {
        alert('请先在编辑预设中填写API URL和API Key');
        return;
    }
    
    // 显示加载弹窗
    const loadingModal = document.createElement('div');
    loadingModal.id = 'loading-current-model-modal';
    loadingModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
    `;
    
    loadingModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); padding: 30px; border-radius: 16px; 
                    min-width: 200px; text-align: center;">
            <div style="margin-bottom: 15px;">
                <i class="fa-solid fa-spinner fa-spin" style="font-size: 24px;"></i>
            </div>
            <div>正在获取模型列表...</div>
        </div>
    `;
    
    document.body.appendChild(loadingModal);
    
    try {
        // 获取模型列表
        const models = await fetchModelList(apiUrl, apiKey);
        
        // 移除加载弹窗
        loadingModal.remove();
        
        if (models.length === 0) {
            alert('未获取到模型列表，请手动输入模型名称');
            return;
        }
        
        // 显示模型选择弹窗
        showCurrentPresetModelList(models);
        
    } catch (error) {
        // 移除加载弹窗
        loadingModal.remove();
        
        console.error('获取模型失败:', error);
        
        let errorMsg = '获取模型失败: ' + error.message;
        if (error.message.includes('无法找到可用的模型列表端点')) {
            errorMsg = '无法自动获取模型列表。\n\n请先在编辑预设中手动输入模型名称';
        }
        
        alert(errorMsg);
    }
}

// 显示当前预设的模型列表
function showCurrentPresetModelList(models) {
    const modal = document.createElement('div');
    modal.id = 'current-model-list-modal';
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    modal.innerHTML = `
    <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                width: 100%; max-width: 400px; max-height: 70vh;
                display: flex; flex-direction: column;">
        <div style="padding: 20px; border-bottom: 1px solid var(--input-border);">
            <h4 style="margin: 0; color: var(--text-color-primary);">选择模型 (${models.length}个)</h4>
        </div>
        
        <div style="padding: 15px; flex: 1; overflow-y: auto;">
            <input type="text" id="current-model-search-input" 
                   placeholder="搜索模型..." 
                   style="width: 90%; padding: 10px 15px; margin: 0 auto 15px auto;
                          border-radius: 10px; border: 1px solid var(--input-border); 
                          background: var(--input-bg); color: var(--text-color-primary);
                          display: block;">
            
            <div id="current-model-items-container" style="max-height: 50vh; overflow-y: auto;">
                <!-- 模型列表会在这里动态生成 -->
            </div>
        </div>
        
        <div style="padding: 15px; border-top: 1px solid var(--input-border); text-align: center;">
            <button onclick="document.getElementById('current-model-list-modal').remove()" 
                    style="padding: 10px 20px; border-radius: 8px;
                           background: var(--input-bg); color: var(--text-color-primary);
                           border: 1px solid var(--input-border); cursor: pointer;">
                取消
            </button>
        </div>
    </div>
    `;
    
    document.body.appendChild(modal);
    
    // 填充模型列表
    renderCurrentPresetModels(models);
    
    // 搜索功能
    const searchInput = document.getElementById('current-model-search-input');
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredModels = models.filter(model => {
            const modelId = (model.id || model).toLowerCase();
            return modelId.includes(searchTerm);
        });
        renderCurrentPresetModels(filteredModels);
    });
    
    // 点击外部关闭
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

// 渲染当前预设的模型列表
function renderCurrentPresetModels(models) {
    const container = document.getElementById('current-model-items-container');
    container.innerHTML = '';
    
    if (models.length === 0) {
        container.innerHTML = `
            <div style="padding: 30px; text-align: center; color: var(--text-color-secondary);">
                未找到匹配的模型
            </div>
        `;
        return;
    }
    
    models.forEach((model) => {
        const modelId = model.id || model;
        const displayName = modelId.split('/').pop();
        
        const item = document.createElement('div');
        item.style.cssText = `
            padding: 12px 15px; margin: 0 10px 8px 10px; border-radius: 10px;
            border: 1px solid var(--input-border); cursor: pointer;
            background: var(--input-bg); transition: all 0.2s;
            width: calc(100% - 20px);
            box-sizing: border-box;
            overflow: hidden;
            word-break: break-word;
        `;
        
        item.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary);">
                ${displayName}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px;">
                ${modelId}
            </div>
        `;
        
        item.onclick = function() {
            // 更新当前预设的模型
            if (APP_DATA.currentPresetId) {
                const preset = APP_DATA.presets.find(p => p.id == APP_DATA.currentPresetId);
                if (preset) {
                    preset.defaultModel = modelId;
                    document.getElementById('current-preset-model').value = modelId;
                    APP_DATA.settings.aiModel = modelId;
                    saveData();
                }
            }
            
            // 关闭模型选择弹窗
            document.getElementById('current-model-list-modal').remove();
        };
        
        container.appendChild(item);
    });
}
// ==================== 深预设和正则功能 ====================

// 加载深预设和正则设置
function loadDeepPresetAndRegexSettings() {
    // 更新开关状态
    updateSwitchState('deep-preset-switch', APP_DATA.deepPresetEnabled);
    updateSwitchState('regex-switch', APP_DATA.regexEnabled);
    
    // 更新显示框内容
    updateDeepPresetDisplay();
    updateRegexDisplay();
}

// 更新开关状态
function updateSwitchState(switchId, enabled) {
    const switchElement = document.getElementById(switchId);
    if (!switchElement) return;
    
    const thumb = switchElement.querySelector('.theme-switch-thumb');
    if (!thumb) return;
    
    if (enabled) {
        thumb.style.left = 'calc(100% - 19px)'; // 右边
        switchElement.style.background = 'var(--accent-color)';
    } else {
        thumb.style.left = '1px'; // 左边
        switchElement.style.background = 'var(--input-border)';
    }
}

// 更新深预设显示
function updateDeepPresetDisplay() {
    const display = document.getElementById('deep-preset-display');
    if (!display) return;
    
    if (APP_DATA.currentDeepPresetId) {
        const preset = APP_DATA.deepPresets.find(p => p.id == APP_DATA.currentDeepPresetId);
        if (preset) {
            display.value = preset.name;
            return;
        }
    }
    display.value = '未选择预设';
}

// 更新正则显示
function updateRegexDisplay() {
    const display = document.getElementById('regex-display');
    if (!display) return;
    
    if (APP_DATA.currentRegexId) {
        const regex = APP_DATA.regexPatterns.find(r => r.id == APP_DATA.currentRegexId);
        if (regex) {
            display.value = regex.name;
            return;
        }
    }
    display.value = '未选择正则';
}

// 切换深预设开关
function toggleDeepPreset() {
    APP_DATA.deepPresetEnabled = !APP_DATA.deepPresetEnabled;
    updateSwitchState('deep-preset-switch', APP_DATA.deepPresetEnabled);
    saveData();
}

// 切换正则开关
function toggleRegex() {
    APP_DATA.regexEnabled = !APP_DATA.regexEnabled;
    updateSwitchState('regex-switch', APP_DATA.regexEnabled);
    saveData();
}

// 打开深预设管理弹窗
function openDeepPresetManager() {
    refreshDeepPresetList();
    showModal('deep-preset-modal');
}

// 打开正则管理弹窗
function openRegexManager() {
    refreshRegexList();
    showModal('regex-modal');
}

// 刷新深预设列表
function refreshDeepPresetList() {
    const list = document.getElementById('deep-preset-list');
    if (!list) return;
    
    if (!APP_DATA.deepPresets || APP_DATA.deepPresets.length === 0) {
        list.innerHTML = `
            <div style="text-align: center; padding: 30px; color: var(--text-color-secondary);">
                <div style="font-size: 36px; margin-bottom: 10px;">📁</div>
                <div>无预设</div>
            </div>
        `;
        return;
    }
    
    // 按最后使用时间排序
    const sortedPresets = [...APP_DATA.deepPresets].sort((a, b) => {
        const timeA = a.lastUsedTime || 0;
        const timeB = b.lastUsedTime || 0;
        return timeB - timeA;
    });
    
    list.innerHTML = '';
    sortedPresets.forEach(preset => {
        const div = document.createElement('div');
        div.style.cssText = `
            padding: 12px 15px; margin-bottom: 8px; border-radius: 10px;
            background: var(--input-bg); border: 1px solid var(--input-border);
            position: relative;
            min-height: 60px;
        `;
        
        // 主内容区域（点击选择）
        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = `
            cursor: pointer;
            margin-right: 40px; /* 给删除按钮留空间 */
        `;
        
        contentDiv.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary); font-size: 17px;">
                ${preset.name}
            </div>
            <div style="font-size: 13px; color: var(--text-color-secondary); margin-top: 6px; line-height: 1.4;">
                ${preset.content.substring(0, 50)}${preset.content.length > 50 ? '...' : ''}
            </div>
        `;
        
        contentDiv.onclick = function() {
            selectDeepPreset(preset.id);
        };
        
        div.appendChild(contentDiv);
        
        // 删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.innerHTML = '×';
        deleteBtn.style.cssText = `
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            border-radius: 6px;
            background: var(--danger-color);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        deleteBtn.title = '删除预设';
        deleteBtn.onclick = function(e) {
            e.stopPropagation(); // 阻止冒泡
            deleteDeepPreset(preset.id);
        };
        
        div.appendChild(deleteBtn);
        list.appendChild(div);
    });
}

// 刷新正则列表
function refreshRegexList() {
    const list = document.getElementById('regex-list');
    if (!list) return;
    
    if (!APP_DATA.regexPatterns || APP_DATA.regexPatterns.length === 0) {
        list.innerHTML = `
            <div style="text-align: center; padding: 30px; color: var(--text-color-secondary);">
                <div style="font-size: 36px; margin-bottom: 10px;">📄</div>
                <div>无正则</div>
            </div>
        `;
        return;
    }
    
    // 按最后使用时间排序
    const sortedRegex = [...APP_DATA.regexPatterns].sort((a, b) => {
        const timeA = a.lastUsedTime || 0;
        const timeB = b.lastUsedTime || 0;
        return timeB - timeA;
    });
    
    list.innerHTML = '';
    sortedRegex.forEach(regex => {
        const div = document.createElement('div');
        div.style.cssText = `
            padding: 12px 15px; margin-bottom: 8px; border-radius: 10px;
            background: var(--input-bg); border: 1px solid var(--input-border);
            position: relative;
            min-height: 60px;
        `;
        
        // 主内容区域（点击选择）
        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = `
            cursor: pointer;
            margin-right: 40px; /* 给删除按钮留空间 */
        `;
        
        contentDiv.innerHTML = `
            <div style="font-weight: bold; color: var(--text-color-primary); font-size: 17px;">
                ${regex.name}
            </div>
            <div style="font-size: 12px; color: var(--text-color-secondary); margin-top: 4px; line-height: 1.3;">
                <div style="margin-bottom: 2px;">模式: ${regex.pattern.substring(0, 40)}${regex.pattern.length > 40 ? '...' : ''}</div>
                <div>替换: ${regex.replacement.substring(0, 40)}${regex.replacement.length > 40 ? '...' : ''}</div>
            </div>
        `;
        
        contentDiv.onclick = function() {
            selectRegex(regex.id);
        };
        
        div.appendChild(contentDiv);
        
        // 删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.innerHTML = '×';
        deleteBtn.style.cssText = `
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            border-radius: 6px;
            background: var(--danger-color);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        deleteBtn.title = '删除正则';
        deleteBtn.onclick = function(e) {
            e.stopPropagation(); // 阻止冒泡
            deleteRegex(regex.id);
        };
        
        div.appendChild(deleteBtn);
        list.appendChild(div);
    });
}

// 选择深预设
function selectDeepPreset(presetId) {
    const preset = APP_DATA.deepPresets.find(p => p.id == presetId);
    if (!preset) return;
    
    APP_DATA.currentDeepPresetId = presetId;
    preset.lastUsedTime = Date.now();
    updateDeepPresetDisplay();
    saveData();
    hideModal('deep-preset-modal');
}

// 选择正则
function selectRegex(regexId) {
    const regex = APP_DATA.regexPatterns.find(r => r.id == regexId);
    if (!regex) return;
    
    APP_DATA.currentRegexId = regexId;
    regex.lastUsedTime = Date.now();
    updateRegexDisplay();
    saveData();
    hideModal('regex-modal');
}

// 删除深预设
function deleteDeepPreset(presetId) {
    if (!confirm('确定要删除这个预设吗？此操作不可撤销。')) {
        return;
    }
    
    // 如果要删除的是当前选中的预设
    if (APP_DATA.currentDeepPresetId === presetId) {
        APP_DATA.currentDeepPresetId = null;
        updateDeepPresetDisplay();
    }
    
    // 从数组中删除
    APP_DATA.deepPresets = APP_DATA.deepPresets.filter(p => p.id !== presetId);
    saveData();
    refreshDeepPresetList();
}

// 删除正则
function deleteRegex(regexId) {
    if (!confirm('确定要删除这个正则吗？此操作不可撤销。')) {
        return;
    }
    
    // 如果要删除的是当前选中的正则
    if (APP_DATA.currentRegexId === regexId) {
        APP_DATA.currentRegexId = null;
        updateRegexDisplay();
    }
    
    // 从数组中删除
    APP_DATA.regexPatterns = APP_DATA.regexPatterns.filter(r => r.id !== regexId);
    saveData();
    refreshRegexList();
}

// 导入深预设文件
function importDeepPresetFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,.txt';
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const fileContent = e.target.result;
                let presetName = file.name.replace(/\.[^/.]+$/, "");
                let presetContent = "";

                try {
                    // 尝试解析为 JSON
                    const presetData = JSON.parse(fileContent);
                    
                    // 自动寻找可能的字段名
                    presetContent = presetData.content || presetData.text || presetData.value || 
                                    (typeof presetData === 'string' ? presetData : JSON.stringify(presetData));
                    
                    if (presetData.name) {
                        presetName = presetData.name;
                    }
                } catch (jsonError) {
                    // 如果不是 JSON，直接作为纯文本
                    presetContent = fileContent;
                }
                
                if (!presetContent || presetContent.trim() === "") {
                    alert("文件内容为空，无法导入");
                    return;
                }

                // 创建预设对象并保存
                const newPreset = {
                    id: Date.now(),
                    name: presetName,
                    content: presetContent,
                    lastUsedTime: Date.now()
                };

                if (!APP_DATA.deepPresets) APP_DATA.deepPresets = [];
                APP_DATA.deepPresets.push(newPreset);
                saveData();
                
                refreshDeepPresetList();
                selectDeepPreset(newPreset.id);
                
                alert('预设导入成功！');
            } catch (error) {
                alert('导入过程中出错：' + error.message);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

// 导入正则文件
function importRegexFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,.txt';
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const fileContent = e.target.result;
                let regexData;
                
                try {
                    regexData = JSON.parse(fileContent);
                } catch (jsonError) {
                    alert('请提供有效的 JSON 格式文件。');
                    return;
                }

                // --- 智能识别逻辑 ---
                // 1. 找名称
                let name = regexData.name || regexData.title || file.name.replace(/\.[^/.]+$/, "");
                
                // 2. 找匹配模式 (Pattern)
                let pattern = regexData.pattern || regexData.regex || regexData.match;
                
                // 3. 找替换内容 (Replacement)
                let replacement = regexData.replacement || regexData.replace || regexData.result || "";

                if (!pattern) {
                    alert('导入失败：未在文件中找到“pattern”或“regex”匹配规则。');
                    return;
                }

                const newRegex = {
                    id: Date.now(),
                    name: name,
                    pattern: pattern,
                    replacement: String(replacement), // 确保是字符串
                    lastUsedTime: Date.now()
                };

                if (!APP_DATA.regexPatterns) APP_DATA.regexPatterns = [];
                APP_DATA.regexPatterns.push(newRegex);
                saveData();
                
                refreshRegexList();
                selectRegex(newRegex.id);
                
                alert('正则规则导入成功！');
            } catch (error) {
                alert('导入出错：' + error.message);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

// 创建新的深预设（空预设，用于手动创建）
function createNewDeepPreset() {
    const presetName = prompt('请输入预设名称：', '新预设');
    if (!presetName || !presetName.trim()) return;
    
    const presetContent = prompt('请输入预设内容：', '');
    if (presetContent === null) return; // 用户取消
    
    const newPreset = {
        id: Date.now(),
        name: presetName.trim(),
        content: presetContent || '',
        lastUsedTime: Date.now()
    };
    
    APP_DATA.deepPresets.push(newPreset);
    saveData();
    refreshDeepPresetList();
    selectDeepPreset(newPreset.id);
}

// 创建新的正则（空正则，用于手动创建）
function createNewRegex() {
    const regexName = prompt('请输入正则名称：', '新正则');
    if (!regexName || !regexName.trim()) return;
    
    const regexPattern = prompt('请输入正则表达式：', '');
    if (regexPattern === null) return;
    
    const regexReplacement = prompt('请输入替换内容（可为空）：', '');
    
    const newRegex = {
        id: Date.now(),
        name: regexName.trim(),
        pattern: regexPattern,
        replacement: regexReplacement || '',
        lastUsedTime: Date.now()
    };
    
    APP_DATA.regexPatterns.push(newRegex);
    saveData();
    refreshRegexList();
    selectRegex(newRegex.id);
}

// 在AI对话中应用深预设
function applyDeepPresetToPrompt() {
    if (!APP_DATA.deepPresetEnabled || !APP_DATA.currentDeepPresetId) {
        return '';
    }
    
    const preset = APP_DATA.deepPresets.find(p => p.id == APP_DATA.currentDeepPresetId);
    if (!preset) return '';
    
    return `\n【深预设】\n${preset.content}\n`;
}

// 在AI回复后应用正则处理
function applyRegexToText(text) {
    if (!APP_DATA.regexEnabled || !APP_DATA.currentRegexId) {
        return text;
    }
    
    const regex = APP_DATA.regexPatterns.find(r => r.id == APP_DATA.currentRegexId);
    if (!regex) return text;
    
    try {
        const pattern = new RegExp(regex.pattern, 'g');
        return text.replace(pattern, regex.replacement);
    } catch (error) {
        console.error('正则处理错误:', error);
        return text;
    }
}
 async function sendPushNotification(messageText) {
    // 如果页面在前台，不发送通知
    if (document.visibilityState === 'visible') {
        console.log('页面在前台，跳过推送通知');
        return;
    }
    
    // 你的 Cloudflare Worker URL（末尾加斜杠确保正确路由）
    const WORKER_URL = "https://lkgo-push.ginkgo-yinxing.workers.dev/";
    
    try {
        const response = await fetch(WORKER_URL, {
            method: "POST",
            mode: "cors",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ 
                action: 'send',
                message: messageText
            })
        });
        
        const result = await response.json();
        console.log("【推送结果】", result);
        
    } catch (e) {
        console.error("【推送失败】", e);
    }
}


	// 控制静音音频播放的函数
function toggleSilentAudio(shouldPlay) {
    const audio = document.getElementById('silent-audio');
    if (!audio) return;
    
    if (shouldPlay) {
        audio.play().catch(e => console.log("音频播放被拦截:", e));
    } else {
        audio.pause();
    }
}

// 确保变量在全局范围内
let isKeepAliveEnabled = false;

async function toggleKeepAlive() {
    const track = document.getElementById('keep-alive-switch');
    const thumb = track.querySelector('.theme-switch-thumb');
    const audio = document.getElementById('silent-audio');
    
    if (!audio) return;

    isKeepAliveEnabled = !isKeepAliveEnabled;
    
    if (isKeepAliveEnabled) {
        // UI 表现
        thumb.style.left = 'calc(100% - 28px)'; 
        track.style.background = 'var(--accent-color)';
        
        // 强制开启循环模式
        audio.loop = true;
        audio.volume = 0.5; 
        
        try {
            await audio.play();
            console.log("✅ 后台保活已启动并设置为循环模式");
        } catch (e) {
            console.warn("❌ 播放失败:", e);
            isKeepAliveEnabled = false;
            thumb.style.left = '2px';
            track.style.background = 'var(--input-border)';
        }
    } else {
        // 关闭
        thumb.style.left = '2px';
        track.style.background = 'var(--input-border)';
        audio.pause();
    }
}

// --- 新增：双重保险，确保音频结束时自动重新播放 ---
document.getElementById('silent-audio').addEventListener('ended', function() {
    if (isKeepAliveEnabled) {
        this.play();
    }
}, false);

async function checkAndReactivateSubscription() {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
        console.log('浏览器不支持 Push API');
        return;
    }

    try {
        const registration = await navigator.serviceWorker.ready;
        const subscription = await registration.pushManager.getSubscription();
        
        if (subscription) {
            console.log('已存在推送订阅');
            // 将订阅信息发送到服务器
            await sendSubscriptionToServer(subscription);
        } else {
            console.log('尚未订阅推送');
        }
    } catch (error) {
        console.error('检查订阅状态失败:', error);
    }
}

// 页面加载完成后运行
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(checkAndReactivateSubscription, 2000); // 延迟2秒确保SDK加载完成
});

async function requestPushPermission() {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
        alert('您的浏览器不支持推送通知');
        return;
    }

    try {
        // 请求通知权限
        const permission = await Notification.requestPermission();
        
        if (permission === 'granted') {
            // 注册 Service Worker
            const registration = await navigator.serviceWorker.register('./sw.js');
            await navigator.serviceWorker.ready;
            
            console.log('Service Worker 已注册');
            
            // 订阅推送
            const subscription = await registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
            });
            
            console.log('推送订阅成功:', subscription);
            
            // 发送订阅到服务器
            const sent = await sendSubscriptionToServer(subscription);
            
            if (sent) {
                alert('推送通知已启用！');
            } else {
                alert('推送通知启用失败，请重试');
            }
        } else {
            alert('您拒绝了推送通知权限');
        }
    } catch (error) {
        console.error('启用推送通知失败:', error);
        alert('启用推送通知失败: ' + error.message);
    }
}


// 辅助函数：Base64 转换
function urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');
    const rawData = atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

// 发送订阅信息到服务器
async function sendSubscriptionToServer(subscription) {
    try {
        const response = await fetch('您的服务器端点/subscribe', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(subscription)
        });
        
        if (!response.ok) {
            throw new Error('发送订阅信息失败');
        }
        
        console.log('订阅信息已发送到服务器');
    } catch (error) {
        console.error('发送订阅信息失败:', error);
    }
}

if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
            .then(registration => {
                console.log('Service Worker 注册成功:', registration);
            })
            .catch(error => {
                console.error('Service Worker 注册失败:', error);
            });
    });
}

// 页面加载时检查授权状态
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        window.OneSignalDeferred = window.OneSignalDeferred || [];
        OneSignalDeferred.push(function(OneSignal) {
            const isSubscribed = OneSignal.User.PushSubscription.optedIn;
            const btn = document.getElementById('push-auth-btn');
            if (btn && isSubscribed) {
                btn.textContent = '已开启';
                btn.style.background = 'var(--accent-color)';
                btn.disabled = true;
            }
        });
    }, 2000);
});

// ==================== 紧急修复功能 ====================
function emergencyFix() {
    // 显示修复选项弹窗
    const fixModal = document.createElement('div');
    fixModal.id = 'emergency-fix-modal';
    fixModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.6); z-index: 9999;
        display: flex; justify-content: center; align-items: center;
        padding: 20px;
    `;
    
    fixModal.innerHTML = `
        <div style="background: var(--bg-color-secondary); border-radius: 16px; 
                    width: 90%; max-width: 320px; padding: 24px;">
            <h4 style="margin: 0 0 20px 0; color: var(--danger-color); text-align: center;">
                🔧 紧急修复
            </h4>
            
            <p style="color: var(--text-color-secondary); font-size: 14px; margin-bottom: 20px; text-align: center;">
                如果某个聊天卡死了，请选择修复方式：
            </p>
            
            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button onclick="fixTypingState()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: var(--accent-color); color: white;
                    font-size: 15px; cursor: pointer;">
                    🔄 解除卡死状态
                </button>
                
                <button onclick="showForcePagedLoadSelector()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: #FF6B6B; color: white;
                    font-size: 15px; cursor: pointer;">
                    ⚡ 强制分页加载（消息过多卡死用这个）
                </button>
                
                <button onclick="fixAndRerender()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: var(--warning-color); color: white;
                    font-size: 15px; cursor: pointer;">
                    🔃 重新渲染聊天界面
                </button>
                
                <button onclick="showChatSelector()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: var(--input-bg); color: var(--text-color-primary);
                    border: 1px solid var(--input-border);
                    font-size: 15px; cursor: pointer;">
                    🗑️ 清空某个聊天的历史
                </button>
                
                <button onclick="document.getElementById('emergency-fix-modal').remove()" style="
                    padding: 14px; border-radius: 10px; border: none;
                    background: var(--input-bg); color: var(--text-color-secondary);
                    font-size: 15px; cursor: pointer; margin-top: 10px;">
                    取消
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(fixModal);
    
    // 点击外部关闭
    fixModal.addEventListener('click', function(e) {
        if (e.target === fixModal) {
            fixModal.remove();
        }
    });
}

// 修复1：解除卡死状态
function fixTypingState() {
    // 重置所有状态变量
    isTyping = false;
    currentAIRequest = null;
    
    // 取消正在进行的网络请求
    if (currentController) {
        currentController.abort();
        currentController = null;
    }
    
    // 移除所有正在加载的气泡
    document.querySelectorAll('.typing-indicator').forEach(el => {
        const msgDiv = el.closest('.chat-message');
        if (msgDiv) msgDiv.remove();
    });
    
    // 关闭修复弹窗
    const modal = document.getElementById('emergency-fix-modal');
    if (modal) modal.remove();
    
    alert('✅ 已解除卡死状态！\n\n现在可以继续聊天了。');
}

// 修复2：重新渲染聊天界面
function fixAndRerender() {
    // 先解除卡死状态
    isTyping = false;
    currentAIRequest = null;
    if (currentController) {
        currentController.abort();
        currentController = null;
    }
    
    // 如果当前有聊天，重新渲染
    if (currentContact) {
        const container = document.getElementById('chat-messages');
        if (container) {
            container.innerHTML = '';
            renderMessages(currentContact.history);
        }
    }
    
    // 关闭修复弹窗
    const modal = document.getElementById('emergency-fix-modal');
    if (modal) modal.remove();
    
    alert('✅ 已重新渲染聊天界面！');
}

// 修复3：显示聊天选择器（清空历史）
function showChatSelector() {
    const modal = document.getElementById('emergency-fix-modal');
    if (!modal) return;
    
    // 更新弹窗内容为聊天列表
    const content = modal.querySelector('div');
    if (!content) return;
    
    let chatListHTML = '';
    APP_DATA.contacts.forEach(contact => {
        chatListHTML += `
            <button onclick="clearChatHistory(${contact.id})" style="
                padding: 12px; border-radius: 8px; border: none;
                background: var(--input-bg); color: var(--text-color-primary);
                border: 1px solid var(--input-border);
                font-size: 14px; cursor: pointer; text-align: left;
                display: flex; justify-content: space-between; align-items: center;">
                <span>${contact.name}</span>
                <span style="color: var(--text-color-secondary); font-size: 12px;">
                    ${contact.history.length} 条消息
                </span>
            </button>
        `;
    });
    
    content.innerHTML = `
        <h4 style="margin: 0 0 20px 0; color: var(--text-color-primary); text-align: center;">
            选择要清空的聊天
        </h4>
        
        <p style="color: var(--danger-color); font-size: 13px; margin-bottom: 15px; text-align: center;">
            ⚠️ 清空后无法恢复！
        </p>
        
        <div style="display: flex; flex-direction: column; gap: 10px; max-height: 50vh; overflow-y: auto;">
            ${chatListHTML || '<p style="text-align: center; color: var(--text-color-secondary);">没有聊天记录</p>'}
        </div>
        
        <button onclick="document.getElementById('emergency-fix-modal').remove()" style="
            width: 100%; padding: 14px; border-radius: 10px; border: none;
            background: var(--input-bg); color: var(--text-color-secondary);
            font-size: 15px; cursor: pointer; margin-top: 15px;">
            返回
        </button>
    `;
}

// 清空指定聊天的历史
function clearChatHistory(contactId) {
    const contact = APP_DATA.contacts.find(c => c.id === contactId);
    if (!contact) return;
    
    if (!confirm(`确定要清空「${contact.name}」的所有聊天记录吗？\n\n此操作无法撤销！`)) {
        return;
    }
    
    // 清空历史
    contact.history = [];
    saveData();
    
    // 如果当前正在这个聊天中，重新渲染
    if (currentContact && currentContact.id === contactId) {
        const container = document.getElementById('chat-messages');
        if (container) {
            container.innerHTML = '';
        }
    }
    
    // 关闭弹窗
    const modal = document.getElementById('emergency-fix-modal');
    if (modal) modal.remove();
    
    alert(`✅ 已清空「${contact.name}」的聊天记录！`);
}

// 修复4：显示强制分页加载选择器
function showForcePagedLoadSelector() {
    const modal = document.getElementById('emergency-fix-modal');
    if (!modal) return;
    
    // 更新弹窗内容为聊天列表
    const content = modal.querySelector('div');
    if (!content) return;
    
    let chatListHTML = '';
    APP_DATA.contacts.forEach(contact => {
        const msgCount = contact.history.length;
        const isLarge = msgCount > 100;
        chatListHTML += `
            <button onclick="forcePagedLoad(${contact.id})" style="
                padding: 12px; border-radius: 8px; border: none;
                background: ${isLarge ? 'rgba(255, 107, 107, 0.1)' : 'var(--input-bg)'}; 
                color: var(--text-color-primary);
                border: 1px solid ${isLarge ? '#FF6B6B' : 'var(--input-border)'};
                font-size: 14px; cursor: pointer; text-align: left;
                display: flex; justify-content: space-between; align-items: center;">
                <span>${contact.name}</span>
                <span style="color: ${isLarge ? '#FF6B6B' : 'var(--text-color-secondary)'}; font-size: 12px; font-weight: ${isLarge ? 'bold' : 'normal'};">
                    ${msgCount} 条消息 ${isLarge ? '⚠️' : ''}
                </span>
            </button>
        `;
    });
    
    content.innerHTML = `
        <h4 style="margin: 0 0 15px 0; color: #FF6B6B; text-align: center;">
            ⚡ 强制分页加载
        </h4>
        
        <p style="color: var(--text-color-secondary); font-size: 13px; margin-bottom: 15px; text-align: center; line-height: 1.5;">
            选择卡死的聊天，系统将只加载最近20条消息。<br>
            <span style="color: #FF6B6B;">红色标记的聊天消息过多，建议处理。</span>
        </p>
        
        <div style="display: flex; flex-direction: column; gap: 10px; max-height: 45vh; overflow-y: auto;">
            ${chatListHTML || '<p style="text-align: center; color: var(--text-color-secondary);">没有聊天记录</p>'}
        </div>
        
        <button onclick="emergencyFix()" style="
            width: 100%; padding: 14px; border-radius: 10px; border: none;
            background: var(--input-bg); color: var(--text-color-secondary);
            font-size: 15px; cursor: pointer; margin-top: 15px;">
            返回
        </button>
    `;
}

// 强制分页加载指定聊天
function forcePagedLoad(contactId) {
    const contact = APP_DATA.contacts.find(c => c.id === contactId);
    if (!contact) return;
    
    const msgCount = contact.history.length;
    
    // 关闭修复弹窗
    const modal = document.getElementById('emergency-fix-modal');
    if (modal) modal.remove();
    
    // 重置所有状态
    isTyping = false;
    currentAIRequest = null;
    if (currentController) {
        currentController.abort();
        currentController = null;
    }
    
    // 设置当前聊天
    APP_DATA.currentChatId = contactId;
    currentContact = contact;
    
    // 强制只渲染最后20条
    currentStartIndex = Math.max(0, contact.history.length - 20);
    
    // 显示聊天窗口
    document.querySelectorAll('.page').forEach(page => {
        page.style.display = 'none';
    });
    
    const chatWindow = document.getElementById('chat-window');
    chatWindow.style.display = 'flex';
    document.getElementById('chat-role-name').textContent = contact.name;
    
    // 清空消息容器
    const container = document.getElementById('chat-messages');
    if (container) {
        container.innerHTML = '<div id="loading-more" style="display:none; text-align:center; padding:10px; color:var(--text-color-secondary);">加载中...</div>';
    }
    
    // 只渲染最后20条消息
    const recentMessages = contact.history.slice(-20);
    
    // 延迟渲染，确保DOM已更新
    setTimeout(() => {
        recentMessages.forEach(msg => {
            appendMessageToDOM(msg.content, msg.role, false);
        });
        
        scrollToBottomInstant();
        
        alert(`✅ 已强制分页加载「${contact.name}」！\n\n原有 ${msgCount} 条消息，当前只显示最近 20 条。\n\n向上滚动可以加载更多历史消息。`);
    }, 100);
}

// 切换流式输出开关
function toggleStream() {
    APP_DATA.settings.stream = !APP_DATA.settings.stream;
    updateSwitchState('stream-switch', APP_DATA.settings.stream);
    saveData();
}

// Base64 转换函数
function urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');
    const rawData = atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

// 发送订阅到服务器
async function sendSubscriptionToServer(subscription) {
    try {
        const response = await fetch(WORKER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'subscribe',
                subscription: subscription
            })
        });
        
        if (!response.ok) {
            throw new Error('订阅失败');
        }
        
        console.log('订阅成功发送到服务器');
        return true;
    } catch (error) {
        console.error('发送订阅失败:', error);
        return false;
    }
}


</script>

<!-- 配置管理弹窗 -->
<div id="preset-modal" class="overlay">
    <div class="modal-content" style="width: 90%; max-width: 320px; max-height: 70vh;">
  
  <h4 style="margin-top: 0; margin-bottom: 20px; color: var(--text-color-primary);">配置管理</h4>
        
        <div id="preset-list" style="max-height: 50vh; overflow-y: auto; margin-bottom: 10px; padding-right: 5px;">
        </div>
        
        <!-- 新建配置按钮 -->
        <div style="text-align: center; padding-top: 15px; border-top: 1px solid var(--input-border);">
            <button onclick="doCreateNewPreset()" 
                    style="width: 100%; padding: 14px; border-radius: var(--radius-default); 
                           background: var(--accent-color); color: white; border: none; 
                           cursor: pointer; font-size: 16px; margin-bottom: 10px;">
                <i class="fas fa-plus-circle"></i> 新建配置
            </button>
          
        </div>
    </div>
</div>

</body>
